% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/simulation.R
\name{eFun}
\alias{eFun}
\title{Generate Eigenfunction Basis}
\usage{
eFun(argvals, M, type = c("Fourier", "Poly", "PolyHigh", "Wiener"))
}
\arguments{
\item{argvals}{Numeric vector of evaluation points in [0, 1].}

\item{M}{Number of eigenfunctions to generate.}

\item{type}{Character. Type of eigenfunction system:
\describe{
\item{Fourier}{Fourier basis: 1, sqrt(2)\emph{sin(2}pi\emph{k}t), sqrt(2)\emph{cos(2}pi\emph{k}t)}
\item{Poly}{Orthonormal Legendre polynomials of degrees 0, 1, ..., M-1}
\item{PolyHigh}{Orthonormal Legendre polynomials starting at degree 2}
\item{Wiener}{Wiener process eigenfunctions: sqrt(2)*sin((k-0.5)\emph{pi}t)}
}}
}
\value{
A matrix of dimension \code{length(argvals) x M} containing the
eigenfunction values. Each column is an eigenfunction, normalized to
have unit L2 norm on [0, 1].
}
\description{
Evaluates orthonormal eigenfunction bases at specified argument values.
These eigenfunctions can be used for Karhunen-Loeve simulation.
}
\details{
The eigenfunctions are orthonormal with respect to the L2 inner product:
\code{integral(phi_j * phi_k) = 1} if \code{j == k}, \code{0} otherwise.

\describe{
\item{Fourier}{Suitable for periodic data. First function is constant.}
\item{Poly}{Orthonormalized Legendre polynomials. Good for smooth data.}
\item{PolyHigh}{Legendre polynomials starting at degree 2, useful when
linear and constant components are handled separately.}
\item{Wiener}{Eigenfunctions of the Brownian motion covariance.
Eigenvalues decay as 1/((k-0.5)*pi)^2.}
}
}
\examples{
t <- seq(0, 1, length.out = 100)

# Generate Fourier basis
phi_fourier <- eFun(t, M = 5, type = "Fourier")
matplot(t, phi_fourier, type = "l", lty = 1,
        main = "Fourier Eigenfunctions", ylab = expression(phi(t)))

# Generate Wiener eigenfunctions
phi_wiener <- eFun(t, M = 5, type = "Wiener")
matplot(t, phi_wiener, type = "l", lty = 1,
        main = "Wiener Eigenfunctions", ylab = expression(phi(t)))

# Check orthonormality (should be identity matrix)
dt <- diff(t)[1]
gram <- t(phi_fourier) \%*\% phi_fourier * dt
round(gram, 2)
}
\seealso{
\code{\link{eVal}}, \code{\link{simFunData}}
}
