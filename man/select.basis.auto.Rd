% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/basis.R
\name{select.basis.auto}
\alias{select.basis.auto}
\title{Automatic Per-Curve Basis Type and Number Selection}
\usage{
select.basis.auto(
  fdataobj,
  criterion = c("GCV", "AIC", "BIC"),
  nbasis.range = NULL,
  lambda.pspline = NULL,
  use.seasonal.hint = TRUE
)
}
\arguments{
\item{fdataobj}{An fdata object.}

\item{criterion}{Model selection criterion: "GCV" (default), "AIC", or "BIC".}

\item{nbasis.range}{Optional numeric vector of length 2 specifying
\code{c(min, max)} for nbasis search range. If NULL, automatic ranges
are used: Fourier 3-25, P-spline 6-40 (or limited by data length).}

\item{lambda.pspline}{Smoothing parameter for P-splines. If NULL (default),
lambda is automatically selected from a grid for each curve.}

\item{use.seasonal.hint}{Logical. If TRUE (default), uses FFT-based
seasonality detection to inform basis preference. Seasonal curves start
Fourier search from 5 basis functions.}
}
\value{
A list of class "basis.auto" with:
\describe{
\item{basis.type}{Character vector ("pspline" or "fourier") for each curve}
\item{nbasis}{Integer vector of selected nbasis per curve}
\item{score}{Numeric vector of best criterion scores}
\item{coefficients}{List of coefficient vectors for each curve}
\item{fitted}{fdata object with fitted values}
\item{edf}{Numeric vector of effective degrees of freedom}
\item{seasonal.detected}{Logical vector indicating detected seasonality}
\item{lambda}{Numeric vector of lambda values (NA for Fourier curves)}
\item{criterion}{Character string of criterion used}
\item{original}{Original fdata object}
}
}
\description{
Selects the optimal basis type (Fourier or P-spline) and number of basis
functions for each curve individually using model selection criteria.
This is useful when working with mixed datasets containing both seasonal
and non-seasonal curves.
}
\details{
For each curve, the function searches over:
\itemize{
\item Fourier basis: odd nbasis values from 3 (or 5 if seasonal) to min(m/3, 25)
\item P-spline basis: nbasis from 6 to min(m/2, 40), with lambda from
grid \{0.001, 0.01, 0.1, 1, 10, 100\} if lambda.pspline is NULL
}

The function uses parallel processing (via Rust/rayon) for efficiency
when processing multiple curves.
}
\examples{
# Generate mixed data: some seasonal, some polynomial
set.seed(42)
t <- seq(0, 10, length.out = 100)

# 3 seasonal curves
X_seasonal <- matrix(0, 3, 100)
for (i in 1:3) {
  X_seasonal[i, ] <- sin(2 * pi * t / 2.5) + rnorm(100, sd = 0.2)
}

# 3 polynomial curves
X_poly <- matrix(0, 3, 100)
for (i in 1:3) {
  X_poly[i, ] <- 0.1 * t^2 - t + rnorm(100, sd = 0.5)
}

fd <- fdata(rbind(X_seasonal, X_poly), argvals = t)

# Auto-select optimal basis for each curve
result <- select.basis.auto(fd)
print(result)

# Should detect: first 3 as Fourier, last 3 as P-spline
table(result$basis.type)
}
\seealso{
\code{\link{fdata2basis_cv}} for global basis selection,
\code{\link{pspline}} for P-spline fitting
}
