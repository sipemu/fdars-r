% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fdata.R, R/irregFdata.R
\name{fdata2basis}
\alias{fdata2basis}
\alias{fdata2basis.fdata}
\alias{fdata2basis.irregFdata}
\title{Convert Functional Data to Basis Coefficients}
\usage{
fdata2basis(x, nbasis = 10, type = c("bspline", "fourier"), ...)

\method{fdata2basis}{fdata}(x, nbasis = 10, type = c("bspline", "fourier"), ...)

\method{fdata2basis}{irregFdata}(x, nbasis = 10, type = c("bspline", "fourier"), ...)
}
\arguments{
\item{x}{An object of class 'fdata' or 'irregFdata'.}

\item{nbasis}{Number of basis functions (default 10).}

\item{type}{Type of basis: "bspline" (default) or "fourier".}

\item{...}{Additional arguments (currently unused).}
}
\value{
A matrix of coefficients (n x nbasis).
}
\description{
Project functional data onto a basis system and return coefficients.
Supports B-spline and Fourier basis. Works with both regular \code{fdata}
and irregular \code{irregFdata} objects.
}
\details{
For regular \code{fdata} objects, all curves are projected onto the same
basis evaluated at the common grid points.

For irregular \code{irregFdata} objects, each curve is individually
fitted to the basis using least squares at its own observation points.
This is the preferred approach for sparse/irregularly sampled data as it
avoids interpolation artifacts.
}
\examples{
# Regular fdata
t <- seq(0, 1, length.out = 50)
X <- matrix(0, 20, 50)
for (i in 1:20) X[i, ] <- sin(2*pi*t) + rnorm(50, sd = 0.1)
fd <- fdata(X, argvals = t)
coefs <- fdata2basis(fd, nbasis = 10, type = "bspline")

# Irregular fdata (sparsified)
ifd <- sparsify(fd, minObs = 10, maxObs = 20, seed = 42)
coefs_irreg <- fdata2basis(ifd, nbasis = 10, type = "bspline")
}
