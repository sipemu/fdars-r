% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/metric.R
\name{metric}
\alias{metric}
\title{Distance Metrics for Functional Data}
\usage{
metric(fdataobj, fdataref = NULL, method = "lp", ...)
}
\arguments{
\item{fdataobj}{An object of class 'fdata'.}

\item{fdataref}{An object of class 'fdata'. If NULL, computes self-distances.}

\item{method}{Distance method to use. One of:
\itemize{
\item "lp" - Lp metric (default)
\item "hausdorff" - Hausdorff distance
\item "dtw" - Dynamic Time Warping
\item "pca" - Semi-metric based on PCA scores
\item "deriv" - Semi-metric based on derivatives
\item "basis" - Semi-metric based on basis coefficients
\item "fourier" - Semi-metric based on FFT coefficients
\item "hshift" - Semi-metric with horizontal shift
\item "kl" - Symmetric Kullback-Leibler divergence
}}

\item{...}{Additional arguments passed to the specific distance function.}
}
\value{
A distance matrix.
}
\description{
Functions for computing various distance metrics between functional data.
Compute Distance Metric for Functional Data
}
\details{
Unified interface for computing various distance metrics between functional
data objects. This function dispatches to the appropriate specialized
distance function based on the method parameter.

This function provides a convenient unified interface for all distance
computations in fdars. The additional arguments in \code{...} are passed
to the underlying distance function:

\itemize{
\item lp: lp, w
\item hausdorff: (none)
\item dtw: p, w
\item pca: ncomp
\item deriv: nderiv, lp
\item basis: nbasis, basis, nderiv
\item fourier: nfreq
\item hshift: max_shift
\item kl: eps, normalize
}
}
\examples{
fd <- fdata(matrix(rnorm(200), 20, 10))

# Using different distance methods
D_lp <- metric(fd, method = "lp")
D_hausdorff <- metric(fd, method = "hausdorff")
D_pca <- metric(fd, method = "pca", ncomp = 3)

# Cross-distances
fd2 <- fdata(matrix(rnorm(100), 10, 10))
D_cross <- metric(fd, fd2, method = "lp")
}
