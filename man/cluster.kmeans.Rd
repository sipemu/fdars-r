% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/clustering.R
\name{cluster.kmeans}
\alias{cluster.kmeans}
\title{Clustering Functions for Functional Data}
\usage{
cluster.kmeans(
  fdataobj,
  ncl,
  metric = "L2",
  max.iter = 100,
  nstart = 10,
  seed = NULL,
  draw = FALSE,
  ...
)
}
\arguments{
\item{fdataobj}{An object of class 'fdata'.}

\item{ncl}{Number of clusters.}

\item{metric}{Either a string ("L2", "L1", "Linf") for fast Rust-based
distance computation, or a metric/semimetric function (e.g., \code{metric.lp},
\code{metric.hausdorff}, \code{semimetric.pca}). Using a function provides
flexibility but may be slower for semimetrics computed in R.}

\item{max.iter}{Maximum number of iterations (default 100).}

\item{nstart}{Number of random starts (default 10). The best result
(lowest within-cluster sum of squares) is returned.}

\item{seed}{Optional random seed for reproducibility.}

\item{draw}{Logical. If TRUE, plot the clustered curves (not yet implemented).}

\item{...}{Additional arguments passed to the metric function.}
}
\value{
A list of class 'cluster.kmeans' with components:
\describe{
\item{cluster}{Integer vector of cluster assignments (1 to ncl).}
\item{centers}{An fdata object containing the cluster centers.}
\item{withinss}{Within-cluster sum of squares for each cluster.}
\item{tot.withinss}{Total within-cluster sum of squares.}
\item{size}{Number of observations in each cluster.}
\item{fdataobj}{The input functional data object.}
}
}
\description{
Functions for clustering functional data, including k-means and related
algorithms.
Functional K-Means Clustering
}
\details{
Performs k-means clustering on functional data using the specified metric.
Uses k-means++ initialization for better initial centers.

When \code{metric} is a string ("L2", "L1", "Linf"), the entire k-means
algorithm runs in Rust with parallel processing, providing 50-200x speedup.

When \code{metric} is a function, distances are computed using that function.
Functions like \code{metric.lp}, \code{metric.hausdorff}, and \code{metric.DTW}
have Rust backends and remain fast. Semimetric functions (\code{semimetric.*})
are computed in R and will be slower for large datasets.
}
\examples{
# Create functional data with two groups
t <- seq(0, 1, length.out = 50)
n <- 30
X <- matrix(0, n, 50)
true_cluster <- rep(1:2, each = 15)
for (i in 1:n) {
  if (true_cluster[i] == 1) {
    X[i, ] <- sin(2*pi*t) + rnorm(50, sd = 0.1)
  } else {
    X[i, ] <- cos(2*pi*t) + rnorm(50, sd = 0.1)
  }
}
fd <- fdata(X, argvals = t)

# Cluster with string metric (fast Rust path)
result <- cluster.kmeans(fd, ncl = 2, metric = "L2")
table(result$cluster, true_cluster)

# Cluster with metric function (also fast - Rust backend)
result2 <- cluster.kmeans(fd, ncl = 2, metric = metric.lp)

# Cluster with semimetric (flexible but slower)
result3 <- cluster.kmeans(fd, ncl = 2, metric = semimetric.pca, ncomp = 3)
}
