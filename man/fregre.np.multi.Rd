% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fregre.R
\name{fregre.np.multi}
\alias{fregre.np.multi}
\title{Nonparametric Regression with Multiple Functional Predictors}
\usage{
fregre.np.multi(
  fdataobj.list,
  y,
  weights = NULL,
  h = NULL,
  knn = NULL,
  type.S = c("S.NW", "kNN.gCV", "kNN.lCV"),
  Ker = "norm",
  metric = metric.lp,
  cv.grid = NULL,
  cv.folds = 5,
  ...
)
}
\arguments{
\item{fdataobj.list}{A list of fdata objects (functional predictors).
All must have the same number of observations.}

\item{y}{Response vector (scalar).}

\item{weights}{Weights for combining distances. Can be:
\itemize{
\item NULL: Equal weights (1/p for each predictor)
\item Numeric vector: Fixed weights (will be normalized to sum to 1)
\item "cv": Cross-validate to find optimal weights
}}

\item{h}{Bandwidth for Nadaraya-Watson kernel (optional).}

\item{knn}{Maximum k for k-NN methods.}

\item{type.S}{Smoother type: "S.NW", "kNN.gCV", or "kNN.lCV".}

\item{Ker}{Kernel type (default "norm" for Gaussian).}

\item{metric}{Distance metric function (default metric.lp).}

\item{cv.grid}{Grid of weight values for CV (only used if weights = "cv").
Default is seq(0, 1, by = 0.1) for 2 predictors.}

\item{cv.folds}{Number of folds for weight CV (default 5).}

\item{...}{Additional arguments passed to metric function.}
}
\value{
An object of class 'fregre.np.multi' containing:
\describe{
\item{fdataobj.list}{List of functional predictors}
\item{y}{Response vector}
\item{weights}{Weights used (or optimized)}
\item{weights.cv}{CV results if weights = "cv"}
\item{fitted.values}{Fitted values}
\item{residuals}{Residuals}
\item{D.list}{List of distance matrices}
\item{D.combined}{Combined distance matrix}
}
}
\description{
Fits a nonparametric regression model with multiple functional predictors
using a weighted combination of distance matrices.
}
\examples{
# Create two functional predictors
set.seed(42)
n <- 50
m <- 30
t_grid <- seq(0, 1, length.out = m)

X1 <- matrix(0, n, m)
X2 <- matrix(0, n, m)
for (i in 1:n) {
  X1[i, ] <- sin(2 * pi * t_grid) * i/n + rnorm(m, sd = 0.1)
  X2[i, ] <- cos(2 * pi * t_grid) * i/n + rnorm(m, sd = 0.1)
}
y <- rowMeans(X1) + 0.5 * rowMeans(X2) + rnorm(n, sd = 0.1)

fd1 <- fdata(X1, argvals = t_grid)
fd2 <- fdata(X2, argvals = t_grid)

# Fit with equal weights
fit1 <- fregre.np.multi(list(fd1, fd2), y)

# Fit with cross-validated weights
fit2 <- fregre.np.multi(list(fd1, fd2), y, weights = "cv")
}
