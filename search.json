[{"path":"https://sipemu.github.io/fdars-r/CHANGELOG.html","id":null,"dir":"","previous_headings":"","what":"Changelog","title":"Changelog","text":"notable changes fdars documented file.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/CHANGELOG.html","id":"changed","dir":"","previous_headings":"[0.5.2] - 2025-01-09","what":"Changed","title":"Changelog","text":"fdata2basis.cv() → fdata2basis_cv() fdata2basis.2d() → fdata2basis_2d() basis2fdata.2d() → basis2fdata_2d()","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/CHANGELOG.html","id":"added","dir":"","previous_headings":"[0.5.1] - 2024-12-16","what":"Added","title":"Changelog","text":"normalize() function scale curves unit Lp norm Vignette basis representation optimal basis selection","code":""},{"path":"https://sipemu.github.io/fdars-r/CHANGELOG.html","id":"changed-1","dir":"","previous_headings":"[0.5.1] - 2024-12-16","what":"Changed","title":"Changelog","text":"Renamed norm.fdata() norm() cleaner API Renamed covariance kernel functions cov.* kernel_* avoid S3 dispatch conflicts","code":""},{"path":"https://sipemu.github.io/fdars-r/CHANGELOG.html","id":"fixed","dir":"","previous_headings":"[0.5.1] - 2024-12-16","what":"Fixed","title":"Changelog","text":"Plot functions now display called directly (plot(fd) shows plot, p <- plot(fd) ) S3 method dispatch conflict cov() generic function","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/CHANGELOG.html","id":"added-1","dir":"","previous_headings":"[0.5.0] - 2024-12-14","what":"Added","title":"Changelog","text":"basis2fdata() - reconstruct functional data basis coefficients basis.gcv(), basis.aic(), basis.bic() - goodness--fit metrics fdata2basis_cv() - cross-validation optimal nbasis selection pspline() - P-spline smoothing automatic lambda selection fdata2basis_2d(), basis2fdata_2d() - 2D tensor product basis support pspline.2d() - 2D P-spline anisotropic penalties","code":""},{"path":"https://sipemu.github.io/fdars-r/CHANGELOG.html","id":"changed-2","dir":"","previous_headings":"[0.5.0] - 2024-12-14","what":"Changed","title":"Changelog","text":"Plot functions now return ggplot objects without auto-printing (use print(p) display) Removed hardcoded theme_minimal() plots - respects ggplot2::theme_set() Fixed white lines 2D surface plots using facets","code":""},{"path":"https://sipemu.github.io/fdars-r/CHANGELOG.html","id":"fixed-1","dir":"","previous_headings":"[0.5.0] - 2024-12-14","what":"Fixed","title":"Changelog","text":"Windows binary now built R 4.2.2 compatibility older R versions","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/CHANGELOG.html","id":"added-2","dir":"","previous_headings":"[0.4.0] - 2024-12-13","what":"Added","title":"Changelog","text":"id metadata slots fdata objects storing curve identifiers associated data Outlier plot labeling: plot(outliergram, label = \"id\") label = \"column_name\" magnitudeshape() labeling support (renamed MS.plot)","code":""},{"path":"https://sipemu.github.io/fdars-r/CHANGELOG.html","id":"changed-3","dir":"","previous_headings":"[0.4.0] - 2024-12-13","what":"Changed","title":"Changelog","text":"Auto-reduce alpha show.mean = TRUE plot.fdata()","code":""},{"path":"https://sipemu.github.io/fdars-r/CHANGELOG.html","id":"fixed-2","dir":"","previous_headings":"[0.4.0] - 2024-12-13","what":"Fixed","title":"Changelog","text":"Vignette error: extract data mean fdata object correctly","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/CHANGELOG.html","id":"added-3","dir":"","previous_headings":"[0.3.4] - 2024-12-13","what":"Added","title":"Changelog","text":"fregre.np.multi() regression multiple functional predictors","code":""},{"path":"https://sipemu.github.io/fdars-r/CHANGELOG.html","id":"fixed-3","dir":"","previous_headings":"[0.3.4] - 2024-12-13","what":"Fixed","title":"Changelog","text":"plot.group.distance() error handling Missing depth wrapper functions","code":""},{"path":"https://sipemu.github.io/fdars-r/CHANGELOG.html","id":"changed-4","dir":"","previous_headings":"[0.3.4] - 2024-12-13","what":"Changed","title":"Changelog","text":"Documented null hypothesis group.test()","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/CHANGELOG.html","id":"added-4","dir":"","previous_headings":"[0.3.3] - 2024-12-12","what":"Added","title":"Changelog","text":"Enhanced plot.fdata() group coloring, mean curves, confidence intervals group.distance() measuring distances groups curves group.test() permutation test group differences","code":""},{"path":"https://sipemu.github.io/fdars-r/CHANGELOG.html","id":"fixed-4","dir":"","previous_headings":"[0.3.3] - 2024-12-12","what":"Fixed","title":"Changelog","text":"Release workflow now generates documentation building","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/CHANGELOG.html","id":"fixed-5","dir":"","previous_headings":"[0.3.2] - 2024-12-12","what":"Fixed","title":"Changelog","text":"mean(fd) now returns fdata object (returning matrix) Missing %||% operator definition","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/CHANGELOG.html","id":"added-5","dir":"","previous_headings":"[0.3.1] - 2024-12-12","what":"Added","title":"Changelog","text":"outliergram() visualization (MEI vs MBD plot) plot.fdata2pc() FPCA visualization (components, variance, scores)","code":""},{"path":"https://sipemu.github.io/fdars-r/CHANGELOG.html","id":"changed-5","dir":"","previous_headings":"[0.3.1] - 2024-12-12","what":"Changed","title":"Changelog","text":"Renamed fdata.deriv() deriv() consistency","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/CHANGELOG.html","id":"added-6","dir":"","previous_headings":"[0.3.0] - 2024-12-11","what":"Added","title":"Changelog","text":"Covariance kernel functions: cov.Exponential(), cov.Matern(), cov.Gaussian(), etc. make_gaussian_process() simulating Gaussian process realizations 2D functional data support functions Unified API: depth(), median(), trimmed(), trimvar() method parameter","code":""},{"path":"https://sipemu.github.io/fdars-r/CHANGELOG.html","id":"changed-6","dir":"","previous_headings":"[0.3.0] - 2024-12-11","what":"Changed","title":"Changelog","text":"Cleaned API: removed backward compatibility shims Renamed functions consistency (e.g., fdata.mean -> mean.fdata) plots now use ggplot2 instead base R graphics","code":""},{"path":"https://sipemu.github.io/fdars-r/CHANGELOG.html","id":"added-from-02x-development","dir":"","previous_headings":"[0.3.0] - 2024-12-11","what":"Added (from 0.2.x development)","title":"Changelog","text":"Band depth (depth.BD, depth.MBD, depth.MEI) Functional boxplot (boxplot.fdata) MS-plot outlier detection Fuzzy c-means clustering (cluster.fcm) Geometric median (gmed) Curve registration (register.fd) Local averages feature extraction (localavg.fdata) Optimal k selection k-means (cluster.optim) k-NN bandwidth selection nonparametric regression","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/CHANGELOG.html","id":"initial-release","dir":"","previous_headings":"[0.1.0] - 2024-12-10","what":"Initial Release","title":"Changelog","text":"Core functional data structure: fdata() 1D 2D functional data Depth functions: FM, mode, RP, RT, FSD, KFSD, RPD (Rust backend) Statistics: mean, variance, standard deviation, covariance Distance metrics: Lp, Hausdorff, DTW, KL divergence Semimetrics: basis projection, Fourier, horizontal shift, PCA, derivative Regression: fregre.pc(), fregre.basis(), fregre.np() CV variants Outlier detection: outliers.depth.pond(), outliers.depth.trim(), outliers.lrt() Smoothing: Nadaraya-Watson, local linear, local polynomial, k-NN Clustering: functional k-means Hypothesis testing: flm.test(), fmean.test.fdata() Utilities: Simpson integration, inner product, derivatives","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/basis-representation.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Finding the Best Basis Representation","text":"Basis representation fundamental functional data analysis. Instead working raw observations discrete points, represent curves linear combinations basis functions: X(t)=∑k=1KckBk(t)X(t) = \\sum_{k=1}^{K} c_k B_k(t) Bk(t)B_k(t) basis functions ckc_k coefficients. approach provides: Smoothing: Reduces noise projecting onto lower-dimensional space Dimensionality reduction: Represents infinite-dimensional functions finite coefficients Regularization: Controls curve smoothness basis choice penalties fdars provides tools find optimal basis representation data.","code":"library(fdars) #>  #> Attaching package: 'fdars' #> The following objects are masked from 'package:stats': #>  #>     cov, decompose, deriv, median, sd, var #> The following object is masked from 'package:base': #>  #>     norm library(ggplot2) theme_set(theme_minimal()) set.seed(42)"},{"path":"https://sipemu.github.io/fdars-r/articles/basis-representation.html","id":"creating-example-data","dir":"Articles","previous_headings":"","what":"Creating Example Data","title":"Finding the Best Basis Representation","text":"Let’s create functional data known signal plus noise:","code":"# Generate noisy functional data t <- seq(0, 1, length.out = 100) n <- 30  # number of curves  # True underlying signal: mixture of sin waves true_signal <- function(t) sin(2 * pi * t) + 0.5 * sin(4 * pi * t)  # Generate noisy observations X <- matrix(0, n, length(t)) for (i in 1:n) {   X[i, ] <- true_signal(t) + rnorm(length(t), sd = 0.3) } fd <- fdata(X, argvals = t)  # Plot the data plot(fd, alpha = 0.3)"},{"path":"https://sipemu.github.io/fdars-r/articles/basis-representation.html","id":"choosing-a-basis-type","dir":"Articles","previous_headings":"","what":"Choosing a Basis Type","title":"Finding the Best Basis Representation","text":"fdars supports two main basis types:","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/basis-representation.html","id":"b-splines-default","dir":"Articles","previous_headings":"Choosing a Basis Type","what":"B-splines (default)","title":"Finding the Best Basis Representation","text":"Best non-periodic data Local support: basis function non-zero limited region Good capturing local features Computationally efficient","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/basis-representation.html","id":"fourier-basis","dir":"Articles","previous_headings":"Choosing a Basis Type","what":"Fourier Basis","title":"Finding the Best Basis Representation","text":"Best periodic data (cycles, seasonal patterns) Global support: basis function spans entire domain Natural data harmonic structure  sinusoidal data, Fourier basis natural since true signal composed sine waves.","code":"# Compare B-spline and Fourier representations coefs_bspline <- fdata2basis(fd, nbasis = 15, type = \"bspline\") coefs_fourier <- fdata2basis(fd, nbasis = 15, type = \"fourier\")  # Reconstruct fd_bspline <- basis2fdata(coefs_bspline, argvals = t, type = \"bspline\") fd_fourier <- basis2fdata(coefs_fourier, argvals = t, type = \"fourier\")  # Plot comparison for first curve df_compare <- data.frame(   t = rep(t, 3),   value = c(fd$data[1, ], fd_bspline$data[1, ], fd_fourier$data[1, ]),   type = factor(rep(c(\"Original\", \"B-spline (K=15)\", \"Fourier (K=15)\"), each = length(t)),                 levels = c(\"Original\", \"B-spline (K=15)\", \"Fourier (K=15)\")) )  ggplot(df_compare, aes(x = t, y = value, color = type, linewidth = type)) +   geom_line() +   scale_color_manual(values = c(\"Original\" = \"gray50\", \"B-spline (K=15)\" = \"blue\",                                  \"Fourier (K=15)\" = \"red\")) +   scale_linewidth_manual(values = c(\"Original\" = 0.5, \"B-spline (K=15)\" = 1,                                      \"Fourier (K=15)\" = 1)) +   labs(x = \"t\", y = \"X(t)\", title = \"Basis Representation Comparison\") +   theme(legend.position = \"bottom\", legend.title = element_blank()) +   guides(linewidth = \"none\")"},{"path":"https://sipemu.github.io/fdars-r/articles/basis-representation.html","id":"selecting-the-number-of-basis-functions","dir":"Articles","previous_headings":"","what":"Selecting the Number of Basis Functions","title":"Finding the Best Basis Representation","text":"key question: many basis functions use? : Underfitting (misses important features) many: Overfitting (fits noise)","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/basis-representation.html","id":"information-criteria","dir":"Articles","previous_headings":"Selecting the Number of Basis Functions","what":"Information Criteria","title":"Finding the Best Basis Representation","text":"fdars provides three criteria evaluate basis representations:  Interpretation: GCV (Generalized Cross-Validation): Often good default, balances fit complexity AIC: Tends select slightly complex models BIC: conservative, penalizes complexity strongly larger samples","code":"# Compute criteria for different nbasis values nbasis_range <- 5:25  gcv_scores <- sapply(nbasis_range, function(k) basis.gcv(fd, nbasis = k, type = \"fourier\")) aic_scores <- sapply(nbasis_range, function(k) basis.aic(fd, nbasis = k, type = \"fourier\")) bic_scores <- sapply(nbasis_range, function(k) basis.bic(fd, nbasis = k, type = \"fourier\"))  # Find optimal values opt_gcv <- nbasis_range[which.min(gcv_scores)] opt_aic <- nbasis_range[which.min(aic_scores)] opt_bic <- nbasis_range[which.min(bic_scores)]  # Create data frame for plotting df_criteria <- data.frame(   nbasis = rep(nbasis_range, 3),   score = c(gcv_scores, aic_scores, bic_scores),   criterion = rep(c(\"GCV\", \"AIC\", \"BIC\"), each = length(nbasis_range)),   optimal = c(nbasis_range == opt_gcv, nbasis_range == opt_aic, nbasis_range == opt_bic) )  df_optimal <- data.frame(   criterion = c(\"GCV\", \"AIC\", \"BIC\"),   nbasis = c(opt_gcv, opt_aic, opt_bic) )  ggplot(df_criteria, aes(x = nbasis, y = score)) +   geom_line(color = \"steelblue\") +   geom_point(color = \"steelblue\") +   geom_vline(data = df_optimal, aes(xintercept = nbasis),              linetype = \"dashed\", color = \"red\") +   facet_wrap(~ criterion, scales = \"free_y\") +   labs(x = \"Number of basis functions\", y = \"Score\",        title = \"Information Criteria for Basis Selection\") +   theme_minimal() cat(\"Optimal nbasis - GCV:\", opt_gcv, \"\\n\") #> Optimal nbasis - GCV: 5 cat(\"Optimal nbasis - AIC:\", opt_aic, \"\\n\") #> Optimal nbasis - AIC: 5 cat(\"Optimal nbasis - BIC:\", opt_bic, \"\\n\") #> Optimal nbasis - BIC: 5"},{"path":"https://sipemu.github.io/fdars-r/articles/basis-representation.html","id":"complex-signal-example-b-spline-vs-fourier","dir":"Articles","previous_headings":"Selecting the Number of Basis Functions","what":"Complex Signal Example: B-spline vs Fourier","title":"Finding the Best Basis Representation","text":"previous example used sinusoidal signal ideally suited Fourier basis. Let’s now consider complex non-periodic signal ’s better suited B-splines:  signal three distinct features challenge different basis types: Polynomial trend: Smooth, spanning full domain Gaussian bump t=0.3t=0.3: localized feature Sharp edge t=0.7t=0.7: non-smooth transition Let’s see basis type handles better:  Important: Note curves plotted scale. B-spline basis achieves substantially lower GCV score, confirming ’s better choice non-periodic signal localized features. Now let’s visualize optimal basis representation captures complex signal:  Key observations: B-splines better localized features (like Gaussian bump) Fourier basis needs functions approximate non-periodic signals Information criteria help select basis type number functions","code":"# Generate data with non-periodic features set.seed(123) t2 <- seq(0, 1, length.out = 100) n2 <- 30  # Complex signal: polynomial trend + localized bump complex_signal <- function(t) {   trend <- 2 * t^2 - t   bump <- 0.8 * exp(-((t - 0.3)^2) / (2 * 0.05^2))   sharp <- 0.5 * sqrt(pmax(0, t - 0.7))   trend + bump + sharp }  X2 <- matrix(0, n2, length(t2)) for (i in 1:n2) {   X2[i, ] <- complex_signal(t2) + rnorm(length(t2), sd = 0.15) } fd2 <- fdata(X2, argvals = t2)  # Plot the raw complex signal data plot(fd2) +   labs(title = \"Complex Signal: Polynomial Trend + Gaussian Bump + Sharp Edge\",        x = \"t\", y = \"Value\") # Compare B-spline vs Fourier for this data nbasis_range <- 5:25  # B-spline criteria gcv_bspline <- sapply(nbasis_range, function(k) basis.gcv(fd2, nbasis = k, type = \"bspline\")) aic_bspline <- sapply(nbasis_range, function(k) basis.aic(fd2, nbasis = k, type = \"bspline\"))  # Fourier criteria gcv_fourier <- sapply(nbasis_range, function(k) basis.gcv(fd2, nbasis = k, type = \"fourier\")) aic_fourier <- sapply(nbasis_range, function(k) basis.aic(fd2, nbasis = k, type = \"fourier\"))  # Find optimal nbasis for each type opt_bspline <- nbasis_range[which.min(gcv_bspline)] opt_fourier <- nbasis_range[which.min(gcv_fourier)]  cat(\"Optimal B-spline nbasis:\", opt_bspline, \"(GCV:\", round(min(gcv_bspline), 4), \")\\n\") #> Optimal B-spline nbasis: 15 (GCV: 0.0259 ) cat(\"Optimal Fourier nbasis:\", opt_fourier, \"(GCV:\", round(min(gcv_fourier), 4), \")\\n\") #> Optimal Fourier nbasis: 14 (GCV: 0.048 ) cat(\"\\nB-spline wins with\", round((1 - min(gcv_bspline)/min(gcv_fourier)) * 100, 1),     \"% lower GCV score\\n\") #>  #> B-spline wins with 46.1 % lower GCV score  # Create comparison plot - use SAME scale to show B-spline advantage df_gcv <- data.frame(   nbasis = rep(nbasis_range, 2),   GCV = c(gcv_bspline, gcv_fourier),   basis = rep(c(\"B-spline\", \"Fourier\"), each = length(nbasis_range)) )  ggplot(df_gcv, aes(x = nbasis, y = GCV, color = basis)) +   geom_line(linewidth = 1) +   geom_point(size = 2) +   geom_hline(yintercept = min(gcv_bspline), linetype = \"dashed\",              color = \"steelblue\", alpha = 0.5) +   geom_hline(yintercept = min(gcv_fourier), linetype = \"dashed\",              color = \"coral\", alpha = 0.5) +   annotate(\"text\", x = 24, y = min(gcv_bspline), label = \"B-spline optimum\",            vjust = -0.5, hjust = 1, size = 3, color = \"steelblue\") +   annotate(\"text\", x = 24, y = min(gcv_fourier), label = \"Fourier optimum\",            vjust = 1.5, hjust = 1, size = 3, color = \"coral\") +   labs(x = \"Number of basis functions\", y = \"GCV Score (lower is better)\",        title = \"GCV Comparison: B-spline vs Fourier for Non-Periodic Signal\",        subtitle = \"B-spline clearly outperforms Fourier for this complex signal\") +   scale_color_manual(values = c(\"B-spline\" = \"steelblue\", \"Fourier\" = \"coral\")) +   theme(legend.position = \"bottom\") # Fit both bases at their optimal values coefs_bspline <- fdata2basis(fd2, nbasis = opt_bspline, type = \"bspline\") coefs_fourier <- fdata2basis(fd2, nbasis = opt_fourier, type = \"fourier\") fitted_bspline <- basis2fdata(coefs_bspline, argvals = t2, type = \"bspline\") fitted_fourier <- basis2fdata(coefs_fourier, argvals = t2, type = \"fourier\")  # Plot comparison for one curve i <- 1 df_fit <- data.frame(   t = rep(t2, 4),   value = c(fd2$data[i, ], complex_signal(t2),             fitted_bspline$data[i, ], fitted_fourier$data[i, ]),   type = factor(rep(c(\"Observed (noisy)\", \"True signal\",                       paste0(\"B-spline (K=\", opt_bspline, \")\"),                       paste0(\"Fourier (K=\", opt_fourier, \")\")), each = length(t2)),                 levels = c(\"Observed (noisy)\", \"True signal\",                            paste0(\"B-spline (K=\", opt_bspline, \")\"),                            paste0(\"Fourier (K=\", opt_fourier, \")\"))) )  ggplot(df_fit, aes(x = t, y = value, color = type, linetype = type, linewidth = type)) +   geom_line() +   scale_color_manual(values = c(\"Observed (noisy)\" = \"gray70\",                                  \"True signal\" = \"black\",                                  setNames(\"steelblue\", paste0(\"B-spline (K=\", opt_bspline, \")\")),                                  setNames(\"coral\", paste0(\"Fourier (K=\", opt_fourier, \")\")))) +   scale_linetype_manual(values = c(\"Observed (noisy)\" = \"solid\",                                     \"True signal\" = \"dashed\",                                     setNames(\"solid\", paste0(\"B-spline (K=\", opt_bspline, \")\")),                                     setNames(\"solid\", paste0(\"Fourier (K=\", opt_fourier, \")\")))) +   scale_linewidth_manual(values = c(\"Observed (noisy)\" = 0.4,                                      \"True signal\" = 1,                                      setNames(1, paste0(\"B-spline (K=\", opt_bspline, \")\")),                                      setNames(1, paste0(\"Fourier (K=\", opt_fourier, \")\")))) +   labs(x = \"t\", y = \"Value\", color = NULL, linetype = NULL,        title = \"Basis Representation Comparison: B-spline vs Fourier\",        subtitle = \"B-spline captures localized features; Fourier shows ringing artifacts\") +   theme(legend.position = \"bottom\") +   guides(linewidth = \"none\")"},{"path":"https://sipemu.github.io/fdars-r/articles/basis-representation.html","id":"automatic-selection-with-fdata2basis_cv","dir":"Articles","previous_headings":"Selecting the Number of Basis Functions","what":"Automatic Selection with fdata2basis_cv()","title":"Finding the Best Basis Representation","text":"convenience, use fdata2basis_cv() automatically find optimal number basis functions:  function returns optimal number basis functions fitted curves:","code":"# Automatic selection using GCV cv_result <- fdata2basis_cv(fd, nbasis.range = 5:25, type = \"fourier\", criterion = \"GCV\") print(cv_result) #> Basis Cross-Validation Results #> ============================== #> Criterion: GCV  #> Optimal nbasis: 5  #> Score at optimal: 0.09559293  #> Range tested: 5 - 25  # Visualize the selection plot(cv_result) # Plot the smoothed data plot(cv_result$fitted, alpha = 0.5, main = paste(\"Smoothed with\", cv_result$optimal.nbasis, \"Fourier basis\"))"},{"path":"https://sipemu.github.io/fdars-r/articles/basis-representation.html","id":"k-fold-cross-validation","dir":"Articles","previous_headings":"Selecting the Number of Basis Functions","what":"K-fold Cross-Validation","title":"Finding the Best Basis Representation","text":"robust estimate, use k-fold cross-validation:","code":"# K-fold cross-validation (slower but more robust) cv_kfold <- fdata2basis_cv(fd, nbasis.range = 5:25, type = \"fourier\",                             criterion = \"CV\", kfold = 10) print(cv_kfold$optimal.nbasis)"},{"path":"https://sipemu.github.io/fdars-r/articles/basis-representation.html","id":"p-spline-smoothing","dir":"Articles","previous_headings":"","what":"P-spline Smoothing","title":"Finding the Best Basis Representation","text":"P-splines (Penalized B-splines) offer alternative approach: instead selecting number basis functions, use many basis functions add roughness penalty: minimize||y−Bc||2+λc′D′Dc\\text{minimize} \\quad ||y - Bc||^2 + \\lambda c' D' D c : - BB B-spline basis matrix - cc coefficients - DD difference matrix (controls smoothness) - λ\\lambda penalty parameter","code":"# Fit P-spline with fixed lambda result_fixed <- pspline(fd[1], nbasis = 25, lambda = 10) print(result_fixed) #> P-spline Smoothing Results #> ========================== #> Number of curves: 1  #> Number of basis functions: 25  #> Penalty order: 2  #> Lambda: 1e+01  #> Effective df: 6.68  #> GCV: 1.151e-01  # Compare different lambda values lambdas <- c(0.01, 1, 100, 10000) df_lambda <- do.call(rbind, lapply(lambdas, function(lam) {   result <- pspline(fd[1], nbasis = 25, lambda = lam)   data.frame(     t = rep(t, 2),     value = c(fd$data[1, ], result$fdata$data[1, ]),     type = rep(c(\"Original\", \"Smoothed\"), each = length(t)),     lambda = paste(\"lambda =\", lam)   ) })) df_lambda$lambda <- factor(df_lambda$lambda, levels = paste(\"lambda =\", lambdas))  ggplot(df_lambda, aes(x = t, y = value, color = type, linewidth = type)) +   geom_line() +   scale_color_manual(values = c(\"Original\" = \"gray50\", \"Smoothed\" = \"blue\")) +   scale_linewidth_manual(values = c(\"Original\" = 0.5, \"Smoothed\" = 1)) +   facet_wrap(~ lambda, ncol = 2) +   labs(x = \"t\", y = \"X(t)\", title = \"P-spline Smoothing with Different Lambda\") +   theme_minimal() +   theme(legend.position = \"bottom\", legend.title = element_blank())"},{"path":"https://sipemu.github.io/fdars-r/articles/basis-representation.html","id":"automatic-lambda-selection","dir":"Articles","previous_headings":"P-spline Smoothing","what":"Automatic Lambda Selection","title":"Finding the Best Basis Representation","text":"P-splines can automatically select optimal smoothing parameter:","code":"# Automatic lambda selection using GCV result_auto <- pspline(fd[1], nbasis = 25, lambda.select = TRUE, criterion = \"GCV\") cat(\"Selected lambda:\", result_auto$lambda, \"\\n\") #> Selected lambda: 1.206793 cat(\"Effective df:\", round(result_auto$edf, 2), \"\\n\") #> Effective df: 9.99  # Plot result df_auto <- data.frame(   t = rep(t, 3),   value = c(fd$data[1, ], result_auto$fdata$data[1, ], true_signal(t)),   type = factor(c(rep(\"Observed\", length(t)),                   rep(\"P-spline\", length(t)),                   rep(\"True signal\", length(t))),                 levels = c(\"Observed\", \"P-spline\", \"True signal\")) )  ggplot(df_auto, aes(x = t, y = value, color = type, linetype = type, linewidth = type)) +   geom_line() +   scale_color_manual(values = c(\"Observed\" = \"gray50\", \"P-spline\" = \"blue\",                                  \"True signal\" = \"red\")) +   scale_linetype_manual(values = c(\"Observed\" = \"solid\", \"P-spline\" = \"solid\",                                     \"True signal\" = \"dashed\")) +   scale_linewidth_manual(values = c(\"Observed\" = 0.5, \"P-spline\" = 1, \"True signal\" = 1)) +   labs(x = \"t\", y = \"X(t)\", title = \"P-spline with Auto-selected Lambda\") +   theme_minimal() +   theme(legend.position = \"bottom\", legend.title = element_blank())"},{"path":"https://sipemu.github.io/fdars-r/articles/basis-representation.html","id":"smoothing-multiple-curves","dir":"Articles","previous_headings":"P-spline Smoothing","what":"Smoothing Multiple Curves","title":"Finding the Best Basis Representation","text":"P-splines work curve--curve, can smooth entire datasets:","code":"# Smooth all curves with automatic lambda selection result_all <- pspline(fd, nbasis = 25, lambda.select = TRUE)  # Plot smoothed data plot(result_all$fdata, alpha = 0.5, main = \"All curves smoothed with P-splines\")"},{"path":"https://sipemu.github.io/fdars-r/articles/basis-representation.html","id":"comparing-approaches","dir":"Articles","previous_headings":"","what":"Comparing Approaches","title":"Finding the Best Basis Representation","text":"Let’s compare different smoothing approaches:","code":"# Original noisy data fd_single <- fd[1]  # 1. Simple basis projection (Fourier) coefs <- fdata2basis(fd_single, nbasis = 9, type = \"fourier\") fd_fourier <- basis2fdata(coefs, argvals = t, type = \"fourier\")  # 2. Optimal basis via CV cv_opt <- fdata2basis_cv(fd_single, nbasis.range = 5:20, type = \"fourier\") fd_cv <- cv_opt$fitted  # 3. P-spline with automatic lambda ps_result <- pspline(fd_single, nbasis = 25, lambda.select = TRUE) fd_pspline <- ps_result$fdata  # Plot comparison df_comp <- data.frame(   t = rep(t, 5),   value = c(fd_single$data[1, ], fd_fourier$data[1, ], fd_cv$data[1, ],             fd_pspline$data[1, ], true_signal(t)),   method = factor(c(rep(\"Observed\", length(t)),                     rep(\"Fourier (K=9)\", length(t)),                     rep(paste0(\"CV-optimal (K=\", cv_opt$optimal.nbasis, \")\"), length(t)),                     rep(\"P-spline\", length(t)),                     rep(\"True signal\", length(t))),                   levels = c(\"Observed\", \"Fourier (K=9)\",                              paste0(\"CV-optimal (K=\", cv_opt$optimal.nbasis, \")\"),                              \"P-spline\", \"True signal\")) )  ggplot(df_comp, aes(x = t, y = value, color = method, linetype = method, linewidth = method)) +   geom_line() +   scale_color_manual(values = c(\"Observed\" = \"gray50\", \"Fourier (K=9)\" = \"blue\",                                  \"CV-optimal (K=9)\" = \"green\", \"P-spline\" = \"purple\",                                  \"True signal\" = \"red\",                                  setNames(\"green\", paste0(\"CV-optimal (K=\", cv_opt$optimal.nbasis, \")\")))) +   scale_linetype_manual(values = c(\"Observed\" = \"solid\", \"Fourier (K=9)\" = \"solid\",                                     \"CV-optimal (K=9)\" = \"solid\", \"P-spline\" = \"solid\",                                     \"True signal\" = \"dashed\",                                     setNames(\"solid\", paste0(\"CV-optimal (K=\", cv_opt$optimal.nbasis, \")\")))) +   scale_linewidth_manual(values = c(\"Observed\" = 0.5, \"Fourier (K=9)\" = 1,                                      \"CV-optimal (K=9)\" = 1, \"P-spline\" = 1,                                      \"True signal\" = 1,                                      setNames(1, paste0(\"CV-optimal (K=\", cv_opt$optimal.nbasis, \")\")))) +   labs(x = \"t\", y = \"X(t)\", title = \"Comparison of Smoothing Methods\", color = NULL) +   theme_minimal() +   theme(legend.position = \"bottom\") +   guides(linetype = \"none\", linewidth = \"none\")"},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/articles/basis-representation.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Finding the Best Basis Representation","text":"Fourier periodic patterns B-splines non-periodic data fdata2basis_cv() automatic nbasis selection basis.gcv(), basis.aic(), basis.bic() manual comparison Heavy noise scenarios want smooth derivatives Automatic smoothing parameter selection Validate comparing reconstructed curves original data","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/basis-representation.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Finding the Best Basis Representation","text":"Ramsay, J.O. Silverman, B.W. (2005). Functional Data Analysis. Springer. Eilers, P.H.C. Marx, B.D. (1996). Flexible smoothing B-splines penalties. Statistical Science, 11(2), 89-121.","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/clustering.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Functional Clustering","text":"Functional clustering groups curves clusters based similarity. fdars provides k-means clustering functional data : Multiple distance metrics k-means++ initialization Automatic optimal k selection","code":"library(fdars) #>  #> Attaching package: 'fdars' #> The following objects are masked from 'package:stats': #>  #>     cov, decompose, deriv, median, sd, var #> The following object is masked from 'package:base': #>  #>     norm library(ggplot2) theme_set(theme_minimal())  # Generate data with 3 distinct clusters set.seed(42) n_per_cluster <- 20 m <- 100 t_grid <- seq(0, 1, length.out = m)  # Cluster 1: Sine curves X1 <- matrix(0, n_per_cluster, m) for (i in 1:n_per_cluster) {   X1[i, ] <- sin(2 * pi * t_grid) + rnorm(m, sd = 0.15) }  # Cluster 2: Cosine curves X2 <- matrix(0, n_per_cluster, m) for (i in 1:n_per_cluster) {   X2[i, ] <- cos(2 * pi * t_grid) + rnorm(m, sd = 0.15) }  # Cluster 3: Linear curves X3 <- matrix(0, n_per_cluster, m) for (i in 1:n_per_cluster) {   X3[i, ] <- 2 * t_grid - 1 + rnorm(m, sd = 0.15) }  X <- rbind(X1, X2, X3) true_clusters <- rep(1:3, each = n_per_cluster)  fd <- fdata(X, argvals = t_grid) plot(fd)"},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/articles/clustering.html","id":"basic-usage","dir":"Articles","previous_headings":"K-Means Clustering","what":"Basic Usage","title":"Functional Clustering","text":"","code":"# Cluster into 3 groups km <- cluster.kmeans(fd, ncl = 3, seed = 123) print(km) #> Functional K-Means Clustering #> ============================= #> Number of clusters: 3  #> Number of observations: 60  #>  #> Cluster sizes: #> [1] 20 20 20 #>  #> Within-cluster sum of squares: #> [1] 0.4394 0.4486 0.4199 #>  #> Total within-cluster SS: 1.3079"},{"path":"https://sipemu.github.io/fdars-r/articles/clustering.html","id":"visualizing-results","dir":"Articles","previous_headings":"K-Means Clustering","what":"Visualizing Results","title":"Functional Clustering","text":"","code":"plot(km)"},{"path":"https://sipemu.github.io/fdars-r/articles/clustering.html","id":"examining-cluster-assignments","dir":"Articles","previous_headings":"K-Means Clustering","what":"Examining Cluster Assignments","title":"Functional Clustering","text":"","code":"# Compare to true clusters table(Predicted = km$cluster, True = true_clusters) #>          True #> Predicted  1  2  3 #>         1  0 20  0 #>         2  0  0 20 #>         3 20  0  0  # Cluster sizes km$size #> [1] 20 20 20  # Within-cluster sum of squares km$withinss #> [1] 0.4394076 0.4485967 0.4199106"},{"path":"https://sipemu.github.io/fdars-r/articles/clustering.html","id":"multiple-random-starts","dir":"Articles","previous_headings":"K-Means Clustering","what":"Multiple Random Starts","title":"Functional Clustering","text":"Use nstart run k-means multiple times keep best result:","code":"# 20 random starts km_multi <- cluster.kmeans(fd, ncl = 3, nstart = 20, seed = 123) cat(\"Total within-cluster SS:\", km_multi$tot.withinss, \"\\n\") #> Total within-cluster SS: 1.307915"},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/articles/clustering.html","id":"string-metrics-fast-rust-path","dir":"Articles","previous_headings":"Different Distance Metrics","what":"String Metrics (Fast Rust Path)","title":"Functional Clustering","text":"maximum speed, use string metrics run entirely Rust:","code":"# L2 (Euclidean) - default km_l2 <- cluster.kmeans(fd, ncl = 3, metric = \"L2\", seed = 123)  # L1 (Manhattan) km_l1 <- cluster.kmeans(fd, ncl = 3, metric = \"L1\", seed = 123)  # L-infinity km_linf <- cluster.kmeans(fd, ncl = 3, metric = \"Linf\", seed = 123)  cat(\"Total WSS - L2:\", km_l2$tot.withinss, \"\\n\") #> Total WSS - L2: 1.307915 cat(\"Total WSS - L1:\", km_l1$tot.withinss, \"\\n\") #> Total WSS - L1: 1.307915 cat(\"Total WSS - Linf:\", km_linf$tot.withinss, \"\\n\") #> Total WSS - Linf: 1.307915"},{"path":"https://sipemu.github.io/fdars-r/articles/clustering.html","id":"custom-metric-functions","dir":"Articles","previous_headings":"Different Distance Metrics","what":"Custom Metric Functions","title":"Functional Clustering","text":"flexibility, pass metric function:","code":"# Dynamic Time Warping km_dtw <- cluster.kmeans(fd, ncl = 3, metric = metric.DTW, seed = 123)  # Hausdorff distance km_haus <- cluster.kmeans(fd, ncl = 3, metric = metric.hausdorff, seed = 123)  # PCA-based semimetric km_pca <- cluster.kmeans(fd, ncl = 3, metric = semimetric.pca, ncomp = 5, seed = 123)"},{"path":"https://sipemu.github.io/fdars-r/articles/clustering.html","id":"optimal-number-of-clusters","dir":"Articles","previous_headings":"","what":"Optimal Number of Clusters","title":"Functional Clustering","text":"Choosing right number clusters crucial. cluster.optim provides three criteria selecting k.","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/clustering.html","id":"silhouette-score","dir":"Articles","previous_headings":"Optimal Number of Clusters","what":"Silhouette Score","title":"Functional Clustering","text":"Measures similar curves cluster vs clusters. Higher better.","code":"opt_sil <- cluster.optim(fd, ncl.range = 2:6,                          criterion = \"silhouette\", seed = 123) print(opt_sil) #> Optimal K-Means Clustering #> ========================== #> Criterion: silhouette  #> K range tested: 2 - 6  #> Optimal k: 3  #>  #> Scores by k: #>  k  score #>  2 0.5867 #>  3 0.7781 #>  4 0.5493 #>  5 0.2902 #>  6 0.0283 plot(opt_sil)"},{"path":"https://sipemu.github.io/fdars-r/articles/clustering.html","id":"calinski-harabasz-index","dir":"Articles","previous_headings":"Optimal Number of Clusters","what":"Calinski-Harabasz Index","title":"Functional Clustering","text":"Ratio -cluster within-cluster variance. Higher better.","code":"opt_ch <- cluster.optim(fd, ncl.range = 2:6,                         criterion = \"CH\", seed = 123) print(opt_ch) #> Optimal K-Means Clustering #> ========================== #> Criterion: CH  #> K range tested: 2 - 6  #> Optimal k: 3  #>  #> Scores by k: #>  k    score #>  2  80.3382 #>  3 480.8701 #>  4 323.4328 #>  5 245.7028 #>  6 198.0615 plot(opt_ch)"},{"path":"https://sipemu.github.io/fdars-r/articles/clustering.html","id":"elbow-method","dir":"Articles","previous_headings":"Optimal Number of Clusters","what":"Elbow Method","title":"Functional Clustering","text":"Plots within-cluster SS vs k. Look “elbow” adding clusters doesn’t help much.","code":"opt_elbow <- cluster.optim(fd, ncl.range = 2:6,                            criterion = \"elbow\", seed = 123) print(opt_elbow) #> Optimal K-Means Clustering #> ========================== #> Criterion: elbow  #> K range tested: 2 - 6  #> Optimal k: 3  #>  #> Scores by k: #>  k  score #>  2 9.6914 #>  3 1.3079 #>  4 1.2753 #>  5 1.2384 #>  6 1.2088 plot(opt_elbow)"},{"path":"https://sipemu.github.io/fdars-r/articles/clustering.html","id":"using-the-optimal-model","dir":"Articles","previous_headings":"Optimal Number of Clusters","what":"Using the Optimal Model","title":"Functional Clustering","text":"","code":"# Get the best model directly best_km <- opt_sil$best.model  # All models are stored all_models <- opt_sil$models"},{"path":"https://sipemu.github.io/fdars-r/articles/clustering.html","id":"k-means-initialization","dir":"Articles","previous_headings":"","what":"k-Means++ Initialization","title":"Functional Clustering","text":"k-means++ selects initial centers spread , improving convergence:","code":"# Get initial centers using k-means++ init_centers <- cluster.init(fd, ncl = 3, seed = 123) plot(init_centers)"},{"path":"https://sipemu.github.io/fdars-r/articles/clustering.html","id":"fuzzy-c-means-clustering","dir":"Articles","previous_headings":"","what":"Fuzzy C-Means Clustering","title":"Functional Clustering","text":"Unlike hard k-means curve belongs exactly one cluster, fuzzy c-means (FCM) assigns membership degrees cluster. useful clusters overlap want quantify uncertainty assignments.","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/clustering.html","id":"basic-fuzzy-clustering","dir":"Articles","previous_headings":"Fuzzy C-Means Clustering","what":"Basic Fuzzy Clustering","title":"Functional Clustering","text":"","code":"# Fuzzy clustering with 3 clusters fcm <- cluster.fcm(fd, ncl = 3, seed = 123) print(fcm) #> Fuzzy C-Means Clustering #> ======================== #> Number of clusters: 3  #> Number of observations: 60  #> Fuzziness parameter m: 2  #>  #> Cluster sizes (hard assignment): #>  #>  1  2  3  #> 20 20 20  #>  #> Objective function: 1.3055  #>  #> Average membership per cluster: #>    C1    C2    C3  #> 0.333 0.333 0.333"},{"path":"https://sipemu.github.io/fdars-r/articles/clustering.html","id":"understanding-membership-degrees","dir":"Articles","previous_headings":"Fuzzy C-Means Clustering","what":"Understanding Membership Degrees","title":"Functional Clustering","text":"curve membership degree cluster, summing 1:","code":"# View membership matrix for first 6 curves head(round(fcm$membership, 3)) #>      [,1]  [,2]  [,3] #> [1,]    0 0.001 0.999 #> [2,]    0 0.000 0.999 #> [3,]    0 0.000 0.999 #> [4,]    0 0.000 1.000 #> [5,]    0 0.000 0.999 #> [6,]    0 0.001 0.999  # Curves with high membership in one cluster (clear assignment) max_membership <- apply(fcm$membership, 1, max) clear_assignments <- which(max_membership > 0.8) cat(\"Curves with clear cluster assignment:\", length(clear_assignments), \"/\",     nrow(fcm$membership), \"\\n\") #> Curves with clear cluster assignment: 60 / 60  # Curves with ambiguous membership (between clusters) ambiguous <- which(max_membership < 0.6) cat(\"Ambiguous curves:\", length(ambiguous), \"\\n\") #> Ambiguous curves: 0"},{"path":"https://sipemu.github.io/fdars-r/articles/clustering.html","id":"visualizing-fuzzy-clusters","dir":"Articles","previous_headings":"Fuzzy C-Means Clustering","what":"Visualizing Fuzzy Clusters","title":"Functional Clustering","text":"","code":"# Plot curves colored by hard assignment plot(fcm, type = \"curves\") # Plot membership degrees as stacked bars plot(fcm, type = \"membership\")"},{"path":"https://sipemu.github.io/fdars-r/articles/clustering.html","id":"the-fuzziness-parameter","dir":"Articles","previous_headings":"Fuzzy C-Means Clustering","what":"The Fuzziness Parameter","title":"Functional Clustering","text":"parameter m controls degree fuzziness: - m close 1: Hard clustering (like k-means) - m = 2: Standard choice (default) - m > 2: Softer clusters overlap","code":"# Compare different fuzziness levels fcm_hard <- cluster.fcm(fd, ncl = 3, m = 1.1, seed = 123) fcm_soft <- cluster.fcm(fd, ncl = 3, m = 3, seed = 123)  cat(\"Hard (m=1.1) - avg max membership:\",     round(mean(apply(fcm_hard$membership, 1, max)), 3), \"\\n\") #> Hard (m=1.1) - avg max membership: 1 cat(\"Default (m=2) - avg max membership:\",     round(mean(apply(fcm$membership, 1, max)), 3), \"\\n\") #> Default (m=2) - avg max membership: 0.999 cat(\"Soft (m=3) - avg max membership:\",     round(mean(apply(fcm_soft$membership, 1, max)), 3), \"\\n\") #> Soft (m=3) - avg max membership: 0.961"},{"path":"https://sipemu.github.io/fdars-r/articles/clustering.html","id":"when-to-use-fuzzy-clustering","dir":"Articles","previous_headings":"Fuzzy C-Means Clustering","what":"When to Use Fuzzy Clustering","title":"Functional Clustering","text":"Fuzzy clustering particularly useful : Clusters overlap: Curves may genuinely belong multiple groups Uncertainty quantification: need confidence cluster assignments Outlier detection: Low maximum membership may indicate outliers Transition states: Data represents continuous transitions states","code":"# Identify potential outliers (low max membership) max_mem <- apply(fcm$membership, 1, max) potential_outliers <- which(max_mem < quantile(max_mem, 0.1)) cat(\"Potential outliers (low membership):\", potential_outliers, \"\\n\") #> Potential outliers (low membership): 10 22 27 29 30 59"},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/articles/clustering.html","id":"adjusted-rand-index","dir":"Articles","previous_headings":"Comparing Clustering Solutions","what":"Adjusted Rand Index","title":"Functional Clustering","text":"Compare two clusterings (requires external package):","code":"# If you have the mclust package library(mclust) adjustedRandIndex(km_l2$cluster, true_clusters)"},{"path":"https://sipemu.github.io/fdars-r/articles/clustering.html","id":"confusion-matrix","dir":"Articles","previous_headings":"Comparing Clustering Solutions","what":"Confusion Matrix","title":"Functional Clustering","text":"","code":"# Create contingency table conf_matrix <- table(Predicted = km$cluster, True = true_clusters) print(conf_matrix) #>          True #> Predicted  1  2  3 #>         1  0 20  0 #>         2  0  0 20 #>         3 20  0  0  # Accuracy (after optimal label matching) # Note: Cluster labels may be permuted max_matches <- 0 for (perm in list(c(1,2,3), c(1,3,2), c(2,1,3), c(2,3,1), c(3,1,2), c(3,2,1))) {   matched <- sum(km$cluster == perm[true_clusters])   max_matches <- max(max_matches, matched) } cat(\"Best matching accuracy:\", max_matches / length(true_clusters), \"\\n\") #> Best matching accuracy: 1"},{"path":"https://sipemu.github.io/fdars-r/articles/clustering.html","id":"visualizing-cluster-centers","dir":"Articles","previous_headings":"","what":"Visualizing Cluster Centers","title":"Functional Clustering","text":"","code":"# Extract centers centers <- km$centers  # Plot centers alone plot(centers)"},{"path":"https://sipemu.github.io/fdars-r/articles/clustering.html","id":"handling-overlapping-clusters","dir":"Articles","previous_headings":"","what":"Handling Overlapping Clusters","title":"Functional Clustering","text":"clusters overlap, different metrics may perform differently:","code":"# Create overlapping data set.seed(456) X_overlap <- matrix(0, 60, m) for (i in 1:30) {   X_overlap[i, ] <- sin(2 * pi * t_grid) + rnorm(m, sd = 0.3) } for (i in 31:60) {   X_overlap[i, ] <- sin(2 * pi * t_grid + 0.5) + rnorm(m, sd = 0.3) } fd_overlap <- fdata(X_overlap, argvals = t_grid)  # L2 may struggle with phase shifts km_overlap_l2 <- cluster.kmeans(fd_overlap, ncl = 2, metric = \"L2\", seed = 123)  # DTW handles phase shifts better km_overlap_dtw <- cluster.kmeans(fd_overlap, ncl = 2, metric = metric.DTW, seed = 123)  cat(\"L2 cluster balance:\", km_overlap_l2$size, \"\\n\") #> L2 cluster balance: 30 30 cat(\"DTW cluster balance:\", km_overlap_dtw$size, \"\\n\") #> DTW cluster balance: 30 30"},{"path":"https://sipemu.github.io/fdars-r/articles/clustering.html","id":"performance","dir":"Articles","previous_headings":"","what":"Performance","title":"Functional Clustering","text":"Rust backend provides fast clustering:","code":"# Benchmark with 500 curves X_large <- matrix(rnorm(500 * 200), 500, 200) fd_large <- fdata(X_large)  system.time(cluster.kmeans(fd_large, ncl = 5, metric = \"L2\", nstart = 10)) #>    user  system elapsed #>   0.234   0.000   0.078  system.time(cluster.kmeans(fd_large, ncl = 5, metric = metric.DTW, nstart = 10)) #>    user  system elapsed #>   4.567   0.000   1.234"},{"path":"https://sipemu.github.io/fdars-r/articles/clustering.html","id":"best-practices","dir":"Articles","previous_headings":"","what":"Best Practices","title":"Functional Clustering","text":"Standardize data curves different scales Use multiple random starts (nstart >= 10) Try different k values cluster.optim Compare metrics clusters may phase shifts Visualize results verify cluster quality","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/articles/clustering.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Functional Clustering","text":"Abraham, C., Cornillon, P.., Matzner-Løber, E., Molinari, N. (2003). Unsupervised curve clustering using B-splines. Scandinavian Journal Statistics, 30(3), 581-595. Bezdek, J.C. (1981). Pattern Recognition Fuzzy Objective Function Algorithms. Plenum Press. Jacques, J. Preda, C. (2014). Functional data clustering: survey. Advances Data Analysis Classification, 8(3), 231-255.","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/covariance-functions.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Covariance Functions and Gaussian Process Generation","text":"Covariance functions (also called kernels) fundamental building blocks Gaussian processes. define correlation structure function values different points, controlling properties like smoothness periodicity. fdars provides comprehensive set covariance functions generating synthetic functional data Gaussian processes.","code":"library(fdars) #>  #> Attaching package: 'fdars' #> The following objects are masked from 'package:stats': #>  #>     cov, decompose, deriv, median, sd, var #> The following object is masked from 'package:base': #>  #>     norm library(ggplot2) theme_set(theme_minimal())"},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/articles/covariance-functions.html","id":"gaussian-squared-exponential","dir":"Articles","previous_headings":"Available Covariance Functions","what":"Gaussian (Squared Exponential)","title":"Covariance Functions and Gaussian Process Generation","text":"common choice, producing infinitely differentiable (smooth) sample paths: k(s,t)=σ2exp(−(s−t)22ℓ2)k(s, t) = \\sigma^2 \\exp\\left(-\\frac{(s-t)^2}{2\\ell^2}\\right)  length_scale parameter controls correlation distance - smaller values produce rapidly varying functions:","code":"t <- seq(0, 1, length.out = 100)  # Create Gaussian covariance function cov_gauss <- kernel.gaussian(variance = 1, length_scale = 0.2) print(cov_gauss) #> Covariance Kernel: gaussian  #> Parameters: #>    variance = 1  #>    length_scale = 0.2  # Generate smooth GP samples fd_gauss <- make.gaussian.process(n = 10, t = t, cov = cov_gauss, seed = 42) plot(fd_gauss, main = \"Gaussian Covariance (smooth)\") # Generate data for different length scales ls_values <- c(0.05, 0.2, 0.5) df_ls <- do.call(rbind, lapply(ls_values, function(ls) {   fd <- make.gaussian.process(n = 5, t = t,                               cov = kernel.gaussian(length_scale = ls),                               seed = 42)   data.frame(     t = rep(t, 5),     value = as.vector(t(fd$data)),     curve = rep(1:5, each = length(t)),     length_scale = paste(\"length_scale =\", ls)   ) })) df_ls$length_scale <- factor(df_ls$length_scale,                               levels = paste(\"length_scale =\", ls_values))  ggplot(df_ls, aes(x = t, y = value, group = curve, color = factor(curve))) +   geom_line(alpha = 0.8) +   facet_wrap(~ length_scale) +   labs(x = \"t\", y = \"X(t)\", title = \"Effect of Length Scale\") +   theme_minimal() +   theme(legend.position = \"none\")"},{"path":"https://sipemu.github.io/fdars-r/articles/covariance-functions.html","id":"exponential","dir":"Articles","previous_headings":"Available Covariance Functions","what":"Exponential","title":"Covariance Functions and Gaussian Process Generation","text":"Produces rougher paths Gaussian (continuous differentiable): k(s,t)=σ2exp(−|s−t|ℓ)k(s, t) = \\sigma^2 \\exp\\left(-\\frac{|s-t|}{\\ell}\\right)","code":"cov_exp <- kernel.exponential(variance = 1, length_scale = 0.2) fd_exp <- make.gaussian.process(n = 10, t = t, cov = cov_exp, seed = 42) plot(fd_exp, main = \"Exponential Covariance (rough)\")"},{"path":"https://sipemu.github.io/fdars-r/articles/covariance-functions.html","id":"matern-family","dir":"Articles","previous_headings":"Available Covariance Functions","what":"Matern Family","title":"Covariance Functions and Gaussian Process Generation","text":"Matern covariance parameterized smoothness parameter ν\\nu. interpolates Exponential (ν=0.5\\nu = 0.5) Gaussian (ν→∞\\nu \\\\infty):  Common choices : - ν=0.5\\nu = 0.5: Equivalent Exponential (rough) - ν=1.5\\nu = 1.5: differentiable - ν=2.5\\nu = 2.5: Twice differentiable - ν=∞\\nu = \\infty: Equivalent Gaussian (infinitely smooth)","code":"# Generate data for different nu values nu_values <- c(0.5, 1.5, 2.5, Inf) nu_labels <- c(\"0.5\", \"1.5\", \"2.5\", \"Inf\") df_matern <- do.call(rbind, lapply(seq_along(nu_values), function(i) {   fd <- make.gaussian.process(n = 5, t = t,                               cov = kernel.matern(length_scale = 0.2, nu = nu_values[i]),                               seed = 42)   data.frame(     t = rep(t, 5),     value = as.vector(t(fd$data)),     curve = rep(1:5, each = length(t)),     nu = paste(\"Matern nu =\", nu_labels[i])   ) })) df_matern$nu <- factor(df_matern$nu,                         levels = paste(\"Matern nu =\", nu_labels))  ggplot(df_matern, aes(x = t, y = value, group = curve, color = factor(curve))) +   geom_line(alpha = 0.8) +   facet_wrap(~ nu, ncol = 2) +   labs(x = \"t\", y = \"X(t)\", title = \"Matern Covariance with Different Smoothness\") +   theme_minimal() +   theme(legend.position = \"none\")"},{"path":"https://sipemu.github.io/fdars-r/articles/covariance-functions.html","id":"brownian-motion","dir":"Articles","previous_headings":"Available Covariance Functions","what":"Brownian Motion","title":"Covariance Functions and Gaussian Process Generation","text":"Standard Brownian motion covariance: k(s,t)=σ2min(s,t)k(s, t) = \\sigma^2 \\min(s, t)  Note: Brownian covariance defined 1D domains.","code":"cov_brown <- kernel.brownian(variance = 1) fd_brown <- make.gaussian.process(n = 10, t = t, cov = cov_brown, seed = 42) plot(fd_brown, main = \"Brownian Motion\")"},{"path":"https://sipemu.github.io/fdars-r/articles/covariance-functions.html","id":"periodic","dir":"Articles","previous_headings":"Available Covariance Functions","what":"Periodic","title":"Covariance Functions and Gaussian Process Generation","text":"data periodic structure: k(s,t)=σ2exp(−2sin2(π|s−t|/p)ℓ2)k(s, t) = \\sigma^2 \\exp\\left(-\\frac{2\\sin^2(\\pi|s-t|/p)}{\\ell^2}\\right)","code":"t_long <- seq(0, 3, length.out = 200) cov_per <- kernel.periodic(variance = 1, length_scale = 0.5, period = 1) fd_per <- make.gaussian.process(n = 5, t = t_long, cov = cov_per, seed = 42) plot(fd_per, main = \"Periodic Covariance (period = 1)\")"},{"path":"https://sipemu.github.io/fdars-r/articles/covariance-functions.html","id":"linear","dir":"Articles","previous_headings":"Available Covariance Functions","what":"Linear","title":"Covariance Functions and Gaussian Process Generation","text":"Linear covariance produces functions linear combinations constant linear function: k(s,t)=σ2(s⋅t+c)k(s, t) = \\sigma^2 (s \\cdot t + c)","code":"cov_lin <- kernel.linear(variance = 1, offset = 0) fd_lin <- make.gaussian.process(n = 10, t = t, cov = cov_lin, seed = 42) plot(fd_lin, main = \"Linear Covariance\")"},{"path":"https://sipemu.github.io/fdars-r/articles/covariance-functions.html","id":"polynomial","dir":"Articles","previous_headings":"Available Covariance Functions","what":"Polynomial","title":"Covariance Functions and Gaussian Process Generation","text":"Generalization linear polynomial basis functions: k(s,t)=σ2(s⋅t+c)dk(s, t) = \\sigma^2 (s \\cdot t + c)^d","code":"cov_poly <- kernel.polynomial(variance = 1, offset = 1, degree = 3) fd_poly <- make.gaussian.process(n = 10, t = t, cov = cov_poly, seed = 42) plot(fd_poly, main = \"Polynomial Covariance (degree 3)\")"},{"path":"https://sipemu.github.io/fdars-r/articles/covariance-functions.html","id":"white-noise","dir":"Articles","previous_headings":"Available Covariance Functions","what":"White Noise","title":"Covariance Functions and Gaussian Process Generation","text":"Diagonal covariance representing independent noise: k(s,t)=σ2𝟏s=tk(s, t) = \\sigma^2 \\mathbf{1}_{s=t}","code":"cov_white <- kernel.whitenoise(variance = 0.5) fd_white <- make.gaussian.process(n = 5, t = t, cov = cov_white, seed = 42) plot(fd_white, main = \"White Noise\")"},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/articles/covariance-functions.html","id":"addition-kernel-add","dir":"Articles","previous_headings":"Combining Covariance Functions","what":"Addition (kernel.add)","title":"Covariance Functions and Gaussian Process Generation","text":"Sum covariance functions models independent components:","code":"# Signal + noise model cov_signal <- kernel.gaussian(variance = 1, length_scale = 0.2) cov_noise <- kernel.whitenoise(variance = 0.1) cov_total <- kernel.add(cov_signal, cov_noise)  fd_noisy <- make.gaussian.process(n = 5, t = t, cov = cov_total, seed = 42) plot(fd_noisy, main = \"Smooth signal + noise\")"},{"path":"https://sipemu.github.io/fdars-r/articles/covariance-functions.html","id":"multiplication-kernel-mult","dir":"Articles","previous_headings":"Combining Covariance Functions","what":"Multiplication (kernel.mult)","title":"Covariance Functions and Gaussian Process Generation","text":"Product covariance functions:","code":"# Locally periodic: smooth envelope modulating periodic behavior cov_envelope <- kernel.gaussian(variance = 1, length_scale = 0.5) cov_periodic <- kernel.periodic(period = 0.2) cov_local_per <- kernel.mult(cov_envelope, cov_periodic)  fd_local_per <- make.gaussian.process(n = 5, t = t, cov = cov_local_per, seed = 42) plot(fd_local_per, main = \"Locally periodic\")"},{"path":"https://sipemu.github.io/fdars-r/articles/covariance-functions.html","id":"mean-functions","dir":"Articles","previous_headings":"","what":"Mean Functions","title":"Covariance Functions and Gaussian Process Generation","text":"Gaussian processes can non-zero mean functions:","code":"# Scalar mean fd_mean5 <- make.gaussian.process(n = 10, t = t,                                    cov = kernel.gaussian(variance = 0.1),                                    mean = 5, seed = 42) plot(fd_mean5, main = \"Constant mean = 5\") # Function mean mean_func <- function(t) sin(2 * pi * t) fd_sinmean <- make.gaussian.process(n = 10, t = t,                                      cov = kernel.gaussian(variance = 0.1),                                      mean = mean_func, seed = 42) plot(fd_sinmean, main = \"Sinusoidal mean function\")"},{"path":"https://sipemu.github.io/fdars-r/articles/covariance-functions.html","id":"d-functional-data-surfaces","dir":"Articles","previous_headings":"","what":"2D Functional Data (Surfaces)","title":"Covariance Functions and Gaussian Process Generation","text":"Covariance functions can generate 2D functional data (surfaces):  Note: kernel.brownian() kernel.periodic() support 1D domains.","code":"s <- seq(0, 1, length.out = 30) t2d <- seq(0, 1, length.out = 30)  # Generate 2D GP samples fd2d <- make.gaussian.process(n = 4, t = list(s, t2d),                                cov = kernel.gaussian(length_scale = 0.3),                                seed = 42) plot(fd2d)"},{"path":"https://sipemu.github.io/fdars-r/articles/covariance-functions.html","id":"reproducibility","dir":"Articles","previous_headings":"","what":"Reproducibility","title":"Covariance Functions and Gaussian Process Generation","text":"Use seed parameter reproducible samples:","code":"fd1 <- make.gaussian.process(n = 3, t = t, cov = kernel.gaussian(), seed = 123) fd2 <- make.gaussian.process(n = 3, t = t, cov = kernel.gaussian(), seed = 123) all.equal(fd1$data, fd2$data)  # TRUE #> [1] TRUE"},{"path":"https://sipemu.github.io/fdars-r/articles/covariance-functions.html","id":"comparison-of-smoothness","dir":"Articles","previous_headings":"","what":"Comparison of Smoothness","title":"Covariance Functions and Gaussian Process Generation","text":"","code":"# Generate data for comparison kernels <- list(   list(name = \"Gaussian (very smooth)\", cov = kernel.gaussian()),   list(name = \"Matern 5/2\", cov = kernel.matern(nu = 2.5)),   list(name = \"Matern 3/2\", cov = kernel.matern(nu = 1.5)),   list(name = \"Exponential (rough)\", cov = kernel.exponential()) )  df_smooth_comp <- do.call(rbind, lapply(kernels, function(k) {   fd <- make.gaussian.process(n = 3, t = t, cov = k$cov, seed = 1)   data.frame(     t = rep(t, 3),     value = as.vector(t(fd$data)),     curve = rep(1:3, each = length(t)),     kernel = k$name   ) })) df_smooth_comp$kernel <- factor(df_smooth_comp$kernel,                                  levels = sapply(kernels, function(k) k$name))  ggplot(df_smooth_comp, aes(x = t, y = value, group = curve, color = factor(curve))) +   geom_line(alpha = 0.8) +   facet_wrap(~ kernel, ncol = 2) +   labs(x = \"t\", y = \"X(t)\", title = \"Comparison of Smoothness\") +   theme_minimal() +   theme(legend.position = \"none\")"},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/articles/covariance-functions.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Covariance Functions and Gaussian Process Generation","text":"Rasmussen, C.E. Williams, C.K.. (2006). Gaussian Processes Machine Learning. MIT Press. Ramsay, J.O. Silverman, B.W. (2005). Functional Data Analysis. Springer.","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/custom-plotting.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Custom Plotting with ggplot2","text":"fdars package provides convenient plot() autoplot() methods functional data objects. However, publication-quality figures specialized visualizations, may need control. vignette shows create fully customizable plots using ggplot2 directly.","code":"library(fdars) library(ggplot2) library(dplyr) library(tidyr) theme_set(theme_minimal())"},{"path":"https://sipemu.github.io/fdars-r/articles/custom-plotting.html","id":"understanding-the-fdata-structure","dir":"Articles","previous_headings":"","what":"Understanding the fdata Structure","title":"Custom Plotting with ggplot2","text":"fdata object contains: data: Matrix size [n, m] n number curves m number evaluation points argvals: Vector length m evaluation points (time/domain values) id: Character vector curve identifiers metadata: Optional data frame covariates","code":"# Create example data set.seed(42) n <- 30 m <- 100 t_grid <- seq(0, 2*pi, length.out = m)  # Generate curves from two groups X <- matrix(0, n, m) groups <- rep(c(\"Treatment\", \"Control\"), each = n/2) for (i in 1:n) {   if (groups[i] == \"Treatment\") {     X[i, ] <- sin(t_grid) + 0.5 + rnorm(m, sd = 0.2)   } else {     X[i, ] <- sin(t_grid) + rnorm(m, sd = 0.2)   } }  # Create fdata with metadata meta <- data.frame(   group = groups,   age = runif(n, 20, 60),   response = rnorm(n) )  fd <- fdata(X, argvals = t_grid,             id = paste0(\"subject_\", 1:n),             metadata = meta,             names = list(main = \"Example Data\",                         xlab = \"Time (s)\",                         ylab = \"Signal\"))  # Inspect the structure str(fd, max.level = 1) #> List of 7 #>  $ data    : num [1:30, 1:100] 0.7742 0.7402 0.0998 0.4991 0.767 ... #>  $ argvals : num [1:100] 0 0.0635 0.1269 0.1904 0.2539 ... #>  $ rangeval: num [1:2] 0 6.28 #>  $ names   :List of 3 #>  $ fdata2d : logi FALSE #>  $ id      : chr [1:30] \"subject_1\" \"subject_2\" \"subject_3\" \"subject_4\" ... #>  $ metadata:'data.frame':    30 obs. of  3 variables: #>  - attr(*, \"class\")= chr \"fdata\""},{"path":"https://sipemu.github.io/fdars-r/articles/custom-plotting.html","id":"converting-fdata-to-long-format","dir":"Articles","previous_headings":"","what":"Converting fdata to Long Format","title":"Custom Plotting with ggplot2","text":"key custom plotting converting wide matrix format long (tidy) format ggplot2 expects.","code":"# Function to convert fdata to long format fdata_to_long <- function(fd, include_metadata = TRUE) {   n <- nrow(fd$data)   m <- ncol(fd$data)    # Create base long-format data frame   df <- data.frame(     curve_id = rep(fd$id, each = m),     t = rep(fd$argvals, n),     value = as.vector(t(fd$data))   )    # Add metadata if requested and available   if (include_metadata && !is.null(fd$metadata)) {     # Expand metadata to match long format     meta_expanded <- fd$metadata[rep(seq_len(n), each = m), , drop = FALSE]     df <- cbind(df, meta_expanded)     rownames(df) <- NULL   }    df }  # Convert our data df_long <- fdata_to_long(fd) head(df_long) #>    curve_id          t     value     group      age response #> 1 subject_1 0.00000000 0.7741917 Treatment 29.85853 -1.11855 #> 2 subject_1 0.06346652 0.4504843 Treatment 29.85853 -1.11855 #> 3 subject_1 0.12693304 0.6992181 Treatment 29.85853 -1.11855 #> 4 subject_1 0.19039955 0.8158238 Treatment 29.85853 -1.11855 #> 5 subject_1 0.25386607 0.8320017 Treatment 29.85853 -1.11855 #> 6 subject_1 0.31733259 0.7908085 Treatment 29.85853 -1.11855"},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/articles/custom-plotting.html","id":"simple-spaghetti-plot","dir":"Articles","previous_headings":"Basic Custom Plots","what":"Simple Spaghetti Plot","title":"Custom Plotting with ggplot2","text":"","code":"ggplot(df_long, aes(x = t, y = value, group = curve_id)) +   geom_line(alpha = 0.5, linewidth = 0.3) +   labs(x = \"Time (s)\", y = \"Signal\", title = \"All Curves\") +   theme_minimal()"},{"path":"https://sipemu.github.io/fdars-r/articles/custom-plotting.html","id":"coloring-by-group","dir":"Articles","previous_headings":"Basic Custom Plots","what":"Coloring by Group","title":"Custom Plotting with ggplot2","text":"","code":"ggplot(df_long, aes(x = t, y = value, group = curve_id, color = group)) +   geom_line(alpha = 0.6, linewidth = 0.4) +   scale_color_manual(values = c(\"Treatment\" = \"#E69F00\", \"Control\" = \"#56B4E9\")) +   labs(x = \"Time (s)\", y = \"Signal\", color = \"Group\") +   theme_minimal() +   theme(legend.position = \"top\")"},{"path":"https://sipemu.github.io/fdars-r/articles/custom-plotting.html","id":"coloring-by-continuous-variable","dir":"Articles","previous_headings":"Basic Custom Plots","what":"Coloring by Continuous Variable","title":"Custom Plotting with ggplot2","text":"","code":"ggplot(df_long, aes(x = t, y = value, group = curve_id, color = age)) +   geom_line(alpha = 0.7, linewidth = 0.4) +   scale_color_viridis_c(option = \"plasma\") +   labs(x = \"Time (s)\", y = \"Signal\", color = \"Age\") +   theme_minimal()"},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/articles/custom-plotting.html","id":"mean-and-confidence-intervals-by-group","dir":"Articles","previous_headings":"Adding Summary Statistics","what":"Mean and Confidence Intervals by Group","title":"Custom Plotting with ggplot2","text":"","code":"# Compute group summaries df_summary <- df_long %>%   group_by(group, t) %>%   summarise(     mean = mean(value),     sd = sd(value),     n = n(),     se = sd / sqrt(n),     ci_lower = mean - 1.96 * se,     ci_upper = mean + 1.96 * se,     .groups = \"drop\"   )  # Plot with ribbons and mean lines ggplot() +   # Individual curves (faded)   geom_line(data = df_long,             aes(x = t, y = value, group = curve_id, color = group),             alpha = 0.2, linewidth = 0.3) +   # Confidence interval ribbons   geom_ribbon(data = df_summary,               aes(x = t, ymin = ci_lower, ymax = ci_upper, fill = group),               alpha = 0.3) +   # Mean lines   geom_line(data = df_summary,             aes(x = t, y = mean, color = group),             linewidth = 1.2) +   scale_color_manual(values = c(\"Treatment\" = \"#E69F00\", \"Control\" = \"#56B4E9\")) +   scale_fill_manual(values = c(\"Treatment\" = \"#E69F00\", \"Control\" = \"#56B4E9\")) +   labs(x = \"Time (s)\", y = \"Signal\",        title = \"Group Means with 95% CI\",        color = \"Group\", fill = \"Group\") +   theme_minimal() +   theme(legend.position = \"top\")"},{"path":"https://sipemu.github.io/fdars-r/articles/custom-plotting.html","id":"median-and-quantile-bands","dir":"Articles","previous_headings":"Adding Summary Statistics","what":"Median and Quantile Bands","title":"Custom Plotting with ggplot2","text":"","code":"df_quantiles <- df_long %>%   group_by(group, t) %>%   summarise(     median = median(value),     q25 = quantile(value, 0.25),     q75 = quantile(value, 0.75),     q10 = quantile(value, 0.10),     q90 = quantile(value, 0.90),     .groups = \"drop\"   )  ggplot(df_quantiles, aes(x = t)) +   # 10-90% band   geom_ribbon(aes(ymin = q10, ymax = q90, fill = group), alpha = 0.2) +   # 25-75% band (IQR)   geom_ribbon(aes(ymin = q25, ymax = q75, fill = group), alpha = 0.4) +   # Median line   geom_line(aes(y = median, color = group), linewidth = 1) +   scale_color_brewer(palette = \"Set1\") +   scale_fill_brewer(palette = \"Set1\") +   facet_wrap(~ group) +   labs(x = \"Time (s)\", y = \"Signal\",        title = \"Median with IQR and 10-90% Bands\") +   theme_minimal() +   theme(legend.position = \"none\")"},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/articles/custom-plotting.html","id":"highlighting-outliers","dir":"Articles","previous_headings":"Highlighting Specific Curves","what":"Highlighting Outliers","title":"Custom Plotting with ggplot2","text":"","code":"# Detect outliers using depth depths <- depth.MBD(fd) outlier_threshold <- quantile(depths, 0.1) outlier_ids <- fd$id[depths < outlier_threshold]  # Add outlier flag to data df_long$is_outlier <- df_long$curve_id %in% outlier_ids  ggplot(df_long, aes(x = t, y = value, group = curve_id)) +   # Non-outliers in gray   geom_line(data = filter(df_long, !is_outlier),             color = \"gray70\", alpha = 0.5, linewidth = 0.3) +   # Outliers in red   geom_line(data = filter(df_long, is_outlier),             color = \"red\", alpha = 0.8, linewidth = 0.6) +   labs(x = \"Time (s)\", y = \"Signal\",        title = \"Outlier Curves Highlighted\",        subtitle = paste(length(outlier_ids), \"outliers detected\")) +   theme_minimal()"},{"path":"https://sipemu.github.io/fdars-r/articles/custom-plotting.html","id":"highlighting-a-subset-with-labels","dir":"Articles","previous_headings":"Highlighting Specific Curves","what":"Highlighting a Subset with Labels","title":"Custom Plotting with ggplot2","text":"","code":"# Select specific curves to highlight highlight_ids <- c(\"subject_1\", \"subject_15\", \"subject_30\") df_long$highlight <- df_long$curve_id %in% highlight_ids  # Get endpoint positions for labels df_endpoints <- df_long %>%   filter(highlight) %>%   group_by(curve_id) %>%   filter(t == max(t))  ggplot(df_long, aes(x = t, y = value, group = curve_id)) +   geom_line(data = filter(df_long, !highlight),             color = \"gray80\", alpha = 0.5, linewidth = 0.3) +   geom_line(data = filter(df_long, highlight),             aes(color = curve_id), linewidth = 0.8) +   geom_text(data = df_endpoints,             aes(label = curve_id, color = curve_id),             hjust = -0.1, size = 3) +   scale_color_brewer(palette = \"Dark2\") +   coord_cartesian(xlim = c(0, max(t_grid) * 1.15)) +   labs(x = \"Time (s)\", y = \"Signal\") +   theme_minimal() +   theme(legend.position = \"none\")"},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/articles/custom-plotting.html","id":"facet-by-group","dir":"Articles","previous_headings":"Faceted Plots","what":"Facet by Group","title":"Custom Plotting with ggplot2","text":"### Facet Binned Continuous Variable","code":"ggplot(df_long, aes(x = t, y = value, group = curve_id)) +   geom_line(alpha = 0.5, linewidth = 0.3) +   facet_wrap(~ group, ncol = 2) +   labs(x = \"Time (s)\", y = \"Signal\") +   theme_bw() # Create age bins df_long$age_bin <- cut(df_long$age,                        breaks = c(20, 35, 50, 65),                        labels = c(\"Young (20-35)\", \"Middle (35-50)\", \"Senior (50-65)\"))  ggplot(df_long, aes(x = t, y = value, group = curve_id, color = group)) +   geom_line(alpha = 0.6, linewidth = 0.4) +   facet_wrap(~ age_bin, nrow = 1) +   scale_color_brewer(palette = \"Set1\") +   labs(x = \"Time (s)\", y = \"Signal\", color = \"Group\") +   theme_minimal() +   theme(legend.position = \"bottom\")"},{"path":"https://sipemu.github.io/fdars-r/articles/custom-plotting.html","id":"small-multiples-individual-curves","dir":"Articles","previous_headings":"Faceted Plots","what":"Small Multiples (Individual Curves)","title":"Custom Plotting with ggplot2","text":"","code":"# Show first 12 curves as small multiples selected_ids <- fd$id[1:12] df_subset <- filter(df_long, curve_id %in% selected_ids)  ggplot(df_subset, aes(x = t, y = value)) +   geom_line(color = \"steelblue\") +   facet_wrap(~ curve_id, ncol = 4, scales = \"free_y\") +   labs(x = \"Time\", y = \"Signal\") +   theme_minimal() +   theme(strip.text = element_text(size = 8))"},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/articles/custom-plotting.html","id":"rainbow-plot-curves-colored-by-index","dir":"Articles","previous_headings":"Advanced Visualizations","what":"Rainbow Plot (Curves Colored by Index)","title":"Custom Plotting with ggplot2","text":"","code":"# Add curve index curve_order <- match(df_long$curve_id, unique(df_long$curve_id)) df_long$curve_index <- curve_order  ggplot(df_long, aes(x = t, y = value, group = curve_id, color = curve_index)) +   geom_line(alpha = 0.7, linewidth = 0.4) +   scale_color_viridis_c(option = \"turbo\") +   labs(x = \"Time (s)\", y = \"Signal\", color = \"Curve #\") +   theme_minimal()"},{"path":"https://sipemu.github.io/fdars-r/articles/custom-plotting.html","id":"phase-plane-plot-value-vs-derivative","dir":"Articles","previous_headings":"Advanced Visualizations","what":"Phase Plane Plot (Value vs Derivative)","title":"Custom Plotting with ggplot2","text":"","code":"# Compute derivatives fd_deriv <- deriv(fd) df_deriv <- fdata_to_long(fd_deriv) names(df_deriv)[names(df_deriv) == \"value\"] <- \"velocity\"  # Merge with original values df_phase <- df_long %>%   select(curve_id, t, value, group) %>%   left_join(select(df_deriv, curve_id, t, velocity),             by = c(\"curve_id\", \"t\"))  ggplot(df_phase, aes(x = value, y = velocity, group = curve_id, color = group)) +   geom_path(alpha = 0.5, linewidth = 0.3) +   scale_color_brewer(palette = \"Set1\") +   labs(x = \"Signal Value\", y = \"Signal Velocity (derivative)\",        title = \"Phase Plane Plot\") +   theme_minimal() +   coord_equal()"},{"path":"https://sipemu.github.io/fdars-r/articles/custom-plotting.html","id":"functional-boxplot-components","dir":"Articles","previous_headings":"Advanced Visualizations","what":"Functional Boxplot Components","title":"Custom Plotting with ggplot2","text":"","code":"# Get functional boxplot data fbp <- boxplot(fd)  # Extract components manually for custom plotting median_curve <- fd$data[fbp$median, ] central_curves <- fd$data[fbp$central, ] outlier_curves <- if (length(fbp$outliers) > 0) fd$data[fbp$outliers, , drop = FALSE] else NULL  # Compute envelopes env_lower <- apply(central_curves, 2, min) env_upper <- apply(central_curves, 2, max)  # Create custom plot df_envelope <- data.frame(   t = fd$argvals,   lower = env_lower,   upper = env_upper,   median = median_curve )  p <- ggplot() +   # Central envelope   geom_ribbon(data = df_envelope,               aes(x = t, ymin = lower, ymax = upper),               fill = \"steelblue\", alpha = 0.4) +   # Median curve   geom_line(data = df_envelope,             aes(x = t, y = median),             color = \"navy\", linewidth = 1.2) +   labs(x = \"Time (s)\", y = \"Signal\",        title = \"Custom Functional Boxplot\") +   theme_minimal()  # Add outliers if present if (!is.null(outlier_curves)) {   df_outliers <- data.frame(     curve_id = rep(fbp$outliers, each = m),     t = rep(fd$argvals, length(fbp$outliers)),     value = as.vector(t(outlier_curves))   )   p <- p + geom_line(data = df_outliers,                      aes(x = t, y = value, group = curve_id),                      color = \"red\", alpha = 0.7, linewidth = 0.5) }  p"},{"path":"https://sipemu.github.io/fdars-r/articles/custom-plotting.html","id":"heatmap-representation","dir":"Articles","previous_headings":"Advanced Visualizations","what":"Heatmap Representation","title":"Custom Plotting with ggplot2","text":"","code":"# Order curves by depth for better visualization depth_order <- order(depths, decreasing = TRUE) df_long$curve_rank <- match(df_long$curve_id, fd$id[depth_order])  ggplot(df_long, aes(x = t, y = curve_rank, fill = value)) +   geom_tile() +   scale_fill_viridis_c(option = \"magma\") +   scale_y_reverse() +   labs(x = \"Time (s)\", y = \"Curve (ordered by depth)\",        fill = \"Value\",        title = \"Heatmap of Functional Data\") +   theme_minimal()"},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/articles/custom-plotting.html","id":"adding-annotations","dir":"Articles","previous_headings":"Combining with Other ggplot2 Extensions","what":"Adding Annotations","title":"Custom Plotting with ggplot2","text":"","code":"# Find peaks for each curve df_peaks <- df_long %>%   group_by(curve_id) %>%   slice_max(value, n = 1) %>%   ungroup()  ggplot(df_long, aes(x = t, y = value, group = curve_id)) +   geom_line(alpha = 0.3, linewidth = 0.3, color = \"gray50\") +   geom_point(data = df_peaks, aes(color = group), size = 1.5, alpha = 0.7) +   scale_color_brewer(palette = \"Set1\") +   labs(x = \"Time (s)\", y = \"Signal\",        title = \"Peak Locations by Group\",        color = \"Group\") +   theme_minimal()"},{"path":"https://sipemu.github.io/fdars-r/articles/custom-plotting.html","id":"using-ggforce-for-hulls","dir":"Articles","previous_headings":"Combining with Other ggplot2 Extensions","what":"Using ggforce for Hulls","title":"Custom Plotting with ggplot2","text":"","code":"# If ggforce is available if (requireNamespace(\"ggforce\", quietly = TRUE)) {   # Compute FPCA scores for 2D representation   pc <- fdata2pc(fd, ncomp = 2)   df_scores <- data.frame(     PC1 = pc$x[, 1],     PC2 = pc$x[, 2],     group = fd$metadata$group   )    ggplot(df_scores, aes(x = PC1, y = PC2, color = group, fill = group)) +     ggforce::geom_mark_ellipse(alpha = 0.1) +     geom_point(size = 2) +     scale_color_brewer(palette = \"Set1\") +     scale_fill_brewer(palette = \"Set1\") +     labs(title = \"FPCA Scores with Group Ellipses\") +     theme_minimal() }"},{"path":"https://sipemu.github.io/fdars-r/articles/custom-plotting.html","id":"theming-for-publication","dir":"Articles","previous_headings":"","what":"Theming for Publication","title":"Custom Plotting with ggplot2","text":"","code":"# Define a publication-ready theme theme_publication <- function(base_size = 11) {   theme_minimal(base_size = base_size) %+replace%     theme(       panel.grid.minor = element_blank(),       panel.grid.major = element_line(color = \"gray90\", linewidth = 0.3),       axis.line = element_line(color = \"black\", linewidth = 0.4),       axis.ticks = element_line(color = \"black\", linewidth = 0.3),       legend.position = \"bottom\",       legend.key.size = unit(0.8, \"lines\"),       plot.title = element_text(face = \"bold\", hjust = 0),       strip.background = element_rect(fill = \"gray95\", color = NA)     ) }  # Publication-quality plot ggplot(df_summary, aes(x = t, color = group, fill = group)) +   geom_ribbon(aes(ymin = ci_lower, ymax = ci_upper), alpha = 0.2, color = NA) +   geom_line(aes(y = mean), linewidth = 0.8) +   scale_color_manual(values = c(\"Treatment\" = \"#D55E00\", \"Control\" = \"#0072B2\"),                      labels = c(\"Treatment\", \"Control\")) +   scale_fill_manual(values = c(\"Treatment\" = \"#D55E00\", \"Control\" = \"#0072B2\"),                     labels = c(\"Treatment\", \"Control\")) +   labs(x = \"Time (s)\", y = \"Signal (a.u.)\",        color = NULL, fill = NULL) +   theme_publication() +   guides(color = guide_legend(override.aes = list(linewidth = 2)))"},{"path":"https://sipemu.github.io/fdars-r/articles/custom-plotting.html","id":"saving-plots","dir":"Articles","previous_headings":"","what":"Saving Plots","title":"Custom Plotting with ggplot2","text":"","code":"# Create your plot p <- ggplot(df_summary, aes(x = t, y = mean, color = group)) +   geom_line(linewidth = 1) +   theme_minimal()  # Save as PNG (for web/presentations) ggsave(\"functional_plot.png\", p, width = 7, height = 5, dpi = 300)  # Save as PDF (for publications) ggsave(\"functional_plot.pdf\", p, width = 7, height = 5)  # Save as SVG (for editing in Illustrator/Inkscape) ggsave(\"functional_plot.svg\", p, width = 7, height = 5)"},{"path":"https://sipemu.github.io/fdars-r/articles/custom-plotting.html","id":"summary-fdata-to-ggplot2-workflow","dir":"Articles","previous_headings":"","what":"Summary: fdata to ggplot2 Workflow","title":"Custom Plotting with ggplot2","text":"Convert long format: Use fdata_to_long() function shown Add metadata: Include covariates coloring/faceting Compute summaries: Use dplyr means, CIs, quantiles Build layers: Start individual curves, add summaries top Customize appearance: Apply themes, colors, labels Export: Use ggsave() appropriate format resolution","code":"# Complete workflow example fd %>%   fdata_to_long() %>%   ggplot(aes(x = t, y = value, group = curve_id, color = group)) +   geom_line(alpha = 0.5) +   stat_summary(aes(group = group), fun = mean, geom = \"line\", linewidth = 1.5) +   scale_color_brewer(palette = \"Set1\") +   labs(x = \"Time\", y = \"Value\") +   theme_minimal()"},{"path":"https://sipemu.github.io/fdars-r/articles/depth-functions.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Functional Depth Functions","text":"Functional depth measure “central” “typical” curve within sample curves. Curves high depth considered representative sample, curves low depth outliers extreme observations. Depth functions extend concept statistical depth (like data depth multivariate data) infinite-dimensional setting functional data.","code":"library(fdars) #>  #> Attaching package: 'fdars' #> The following objects are masked from 'package:stats': #>  #>     cov, decompose, deriv, median, sd, var #> The following object is masked from 'package:base': #>  #>     norm library(ggplot2) theme_set(theme_minimal())  # Create example data set.seed(42) n <- 30 m <- 100 t_grid <- seq(0, 1, length.out = m)  # Main sample: sine curves with noise X <- matrix(0, n, m) for (i in 1:n) {   X[i, ] <- sin(2 * pi * t_grid) + rnorm(m, sd = 0.15) }  # Add some outliers X[1, ] <- sin(2 * pi * t_grid) + 2  # Magnitude outlier X[2, ] <- cos(2 * pi * t_grid)       # Shape outlier  fd <- fdata(X, argvals = t_grid) plot(fd)"},{"path":"https://sipemu.github.io/fdars-r/articles/depth-functions.html","id":"available-depth-functions","dir":"Articles","previous_headings":"","what":"Available Depth Functions","title":"Functional Depth Functions","text":"depth functions accessed unified depth() function method parameter.","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/depth-functions.html","id":"fraiman-muniz-depth-method-fm","dir":"Articles","previous_headings":"Available Depth Functions","what":"Fraiman-Muniz Depth (method = “FM”)","title":"Functional Depth Functions","text":"Fraiman-Muniz depth integrates univariate depths across domain. time point, computes proportion curves given curve, averages across time. Intuition: time point, FM depth asks: “proportion curves lie curve?” curve consistently middle data cloud every time point high FM depth. FM depth can scaled [0, 1] using scale parameter:","code":"depths_fm <- depth(fd, method = \"FM\")  # Show depths (outliers should have lower depth) data.frame(   curve = 1:5,   depth = round(depths_fm[1:5], 4),   note = c(\"magnitude outlier\", \"shape outlier\", rep(\"normal\", 3)) ) #>   curve  depth              note #> 1     1 0.0000 magnitude outlier #> 2     2 0.1113     shape outlier #> 3     3 0.5233            normal #> 4     4 0.5707            normal #> 5     5 0.5407            normal depths_fm_scaled <- depth(fd, method = \"FM\", scale = TRUE) range(depths_fm_scaled) #> [1] 0.0000000 0.5813333"},{"path":"https://sipemu.github.io/fdars-r/articles/depth-functions.html","id":"modal-depth-method-mode","dir":"Articles","previous_headings":"Available Depth Functions","what":"Modal Depth (method = “mode”)","title":"Functional Depth Functions","text":"Modal depth uses kernel density estimation function space. Curves high-density regions high depth. Intuition: Modal depth estimates local density function space. Curves “crowded” regions (many similar curves exist) high depth. Think like finding mode distribution, curves.","code":"depths_mode <- depth(fd, method = \"mode\") head(depths_mode) #> [1] 0.03335153 0.09401245 0.83156568 0.84229565 0.83229521 0.82640249"},{"path":"https://sipemu.github.io/fdars-r/articles/depth-functions.html","id":"random-projection-depth-method-rp","dir":"Articles","previous_headings":"Available Depth Functions","what":"Random Projection Depth (method = “RP”)","title":"Functional Depth Functions","text":"Projects curves onto random directions computes univariate depths projections. robust local variations. Intuition: RP depth projects curves onto random 1D directions computes depth . ’s robust outliers can’t hide projection angles - curve unusual, projection reveal .","code":"depths_rp <- depth(fd, method = \"RP\", nproj = 50) head(depths_rp) #> [1] 0.04903226 0.07677419 0.24774194 0.29032258 0.27935484 0.25419355"},{"path":"https://sipemu.github.io/fdars-r/articles/depth-functions.html","id":"random-tukey-depth-method-rt","dir":"Articles","previous_headings":"Available Depth Functions","what":"Random Tukey Depth (method = “RT”)","title":"Functional Depth Functions","text":"Takes minimum depth across random projections, similar Tukey’s halfspace depth. robust outliers. Intuition: RT depth takes minimum depth across projections. conservative - curve considered central looks central every angle. makes RT extremely robust outliers.","code":"depths_rt <- depth(fd, method = \"RT\", nproj = 50) head(depths_rt) #> [1] 0.03225806 0.03225806 0.03225806 0.03225806 0.06451613 0.03225806"},{"path":"https://sipemu.github.io/fdars-r/articles/depth-functions.html","id":"functional-spatial-depth-method-fsd","dir":"Articles","previous_headings":"Available Depth Functions","what":"Functional Spatial Depth (method = “FSD”)","title":"Functional Depth Functions","text":"Based unit vectors pointing curve others. Measures centrality geometric sense. Intuition: FSD computes unit vectors curve others. central curve vectors pointing directions (cancel ), resulting high depth. outlier vectors pointing one direction (away data cloud).","code":"depths_fsd <- depth(fd, method = \"FSD\") head(depths_fsd) #> [1] 0.03927198 0.06164440 0.34346531 0.39240477 0.33894657 0.32391302"},{"path":"https://sipemu.github.io/fdars-r/articles/depth-functions.html","id":"kernel-functional-spatial-depth-method-kfsd","dir":"Articles","previous_headings":"Available Depth Functions","what":"Kernel Functional Spatial Depth (method = “KFSD”)","title":"Functional Depth Functions","text":"Smoothed version FSD using Gaussian kernel. bandwidth h controls smoothing.","code":"depths_kfsd <- depth(fd, method = \"KFSD\", h = 0.15) head(depths_kfsd) #> [1] 0.2646598 0.2646598 0.3086986 0.3194105 0.3089607 0.3032314"},{"path":"https://sipemu.github.io/fdars-r/articles/depth-functions.html","id":"random-projection-depth-with-derivatives-method-rpd","dir":"Articles","previous_headings":"Available Depth Functions","what":"Random Projection Depth with Derivatives (method = “RPD”)","title":"Functional Depth Functions","text":"Incorporates derivative information, making sensitive shape changes addition magnitude. Intuition: RPD like RP, projections based curve derivatives. makes sensitive shape differences - curves unusual wiggliness local behavior low depth even overall level typical.","code":"depths_rpd <- depth(fd, method = \"RPD\", nproj = 50) head(depths_rpd) #> [1] 0.08533333 0.09600000 0.22666667 0.22600000 0.17866667 0.18466667"},{"path":"https://sipemu.github.io/fdars-r/articles/depth-functions.html","id":"comparing-depth-functions","dir":"Articles","previous_headings":"","what":"Comparing Depth Functions","title":"Functional Depth Functions","text":"Different depth functions different properties may rank curves differently: depth functions correctly identify curves 1 2 low depth.","code":"# Compute all depths using unified depth() function all_depths <- data.frame(   FM = depth(fd, method = \"FM\"),   mode = depth(fd, method = \"mode\"),   RP = depth(fd, method = \"RP\", nproj = 50),   RT = depth(fd, method = \"RT\", nproj = 50),   FSD = depth(fd, method = \"FSD\") )  # Correlation between depth functions round(cor(all_depths), 2) #>        FM mode   RP   RT  FSD #> FM   1.00 0.98 0.94 0.26 0.98 #> mode 0.98 1.00 0.94 0.16 0.97 #> RP   0.94 0.94 1.00 0.19 0.93 #> RT   0.26 0.16 0.19 1.00 0.28 #> FSD  0.98 0.97 0.93 0.28 1.00 # Which curves are identified as outliers (lowest depth)? outlier_ranks <- apply(all_depths, 2, function(d) order(d)[1:3]) outlier_ranks #>      FM mode RP RT FSD #> [1,]  1    1  1  1   1 #> [2,]  2    2  2  2   2 #> [3,] 10   10 20  3  10"},{"path":"https://sipemu.github.io/fdars-r/articles/depth-functions.html","id":"visualizing-depth","dir":"Articles","previous_headings":"Comparing Depth Functions","what":"Visualizing Depth","title":"Functional Depth Functions","text":"powerful way understand depth color curves depth values:  visualization immediately reveals curves outliers (dark colors) central (bright colors). magnitude outlier (shifted ) shape outlier (cosine instead sine) appear low depth values.","code":"# Visualize curves colored by their FM depth df_depth_viz <- data.frame(   t = rep(t_grid, n),   value = as.vector(t(X)),   curve = rep(1:n, each = m),   depth = rep(depths_fm, each = m) )  ggplot(df_depth_viz, aes(x = t, y = value, group = curve, color = depth)) +   geom_line(alpha = 0.8) +   scale_color_viridis_c(option = \"plasma\", name = \"FM Depth\") +   labs(title = \"Curves Colored by Depth\",        subtitle = \"Dark = low depth (outlier), Bright = high depth (central)\",        x = \"t\", y = \"X(t)\")"},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/articles/depth-functions.html","id":"functional-median","dir":"Articles","previous_headings":"Depth-Based Statistics","what":"Functional Median","title":"Functional Depth Functions","text":"median curve maximum depth:","code":"# Using different depth functions via method parameter med_fm <- median(fd, method = \"FM\") med_mode <- median(fd, method = \"mode\") med_rp <- median(fd, method = \"RP\", nproj = 50)  # The median is one of the original curves which.max(depth(fd, method = \"FM\")) #> [1] 13"},{"path":"https://sipemu.github.io/fdars-r/articles/depth-functions.html","id":"trimmed-mean","dir":"Articles","previous_headings":"Depth-Based Statistics","what":"Trimmed Mean","title":"Functional Depth Functions","text":"Remove proportion curves lowest depth, compute mean:","code":"# 10% trimmed mean using different depth methods trim_fm <- trimmed(fd, trim = 0.1, method = \"FM\") trim_mode <- trimmed(fd, trim = 0.1, method = \"mode\")  # Compare trimmed mean to regular mean mean_curve <- mean(fd) # Visualize: trimmed mean is more robust to outliers df_compare <- data.frame(   t = rep(t_grid, 2),   value = c(mean_curve$data[1, ], trim_fm$data[1, ]),   type = rep(c(\"Mean\", \"Trimmed Mean (FM)\"), each = m) )  library(ggplot2) ggplot(df_compare, aes(x = t, y = value, color = type)) +   geom_line(linewidth = 1.2) +   labs(title = \"Mean vs Trimmed Mean\",        x = \"t\", y = \"X(t)\", color = \"\") +   theme_minimal()"},{"path":"https://sipemu.github.io/fdars-r/articles/depth-functions.html","id":"functional-variance-and-trimmed-variance","dir":"Articles","previous_headings":"Depth-Based Statistics","what":"Functional Variance and Trimmed Variance","title":"Functional Depth Functions","text":"","code":"# Regular variance var_fd <- var(fd)  # Trimmed variance (more robust) trimvar_fd <- trimvar(fd, trim = 0.1, method = \"FM\")"},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/articles/depth-functions.html","id":"performance","dir":"Articles","previous_headings":"","what":"Performance","title":"Functional Depth Functions","text":"depth computations use parallel Rust backend:","code":"# Large dataset benchmark X_large <- matrix(rnorm(500 * 200), 500, 200) fd_large <- fdata(X_large)  system.time(depth(fd_large, method = \"FM\")) #>    user  system elapsed #>   0.032   0.000   0.032  system.time(depth(fd_large, method = \"RP\", nproj = 100)) #>    user  system elapsed #>   0.089   0.000   0.089"},{"path":"https://sipemu.github.io/fdars-r/articles/depth-functions.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Functional Depth Functions","text":"Fraiman, R. Muniz, G. (2001). Trimmed means functional data. Test, 10(2), 419-440. Cuevas, ., Febrero, M., Fraiman, R. (2007). Robust estimation classification functional data via projection-based depth notions. Computational Statistics, 22(3), 481-496. López-Pintado, S. Romo, J. (2009). concept depth functional data. Journal American Statistical Association, 104(486), 718-734.","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/distance-metrics.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Distance Metrics and Semimetrics","text":"Distance measures fundamental many FDA methods including clustering, k-nearest neighbors regression, outlier detection. fdars provides true metrics (satisfying triangle inequality) semimetrics (may ). metric dd space 𝒳\\mathcal{X} satisfies: d(f,g)≥0d(f, g) \\geq 0 (non-negativity) d(f,g)=0⇔f=gd(f, g) = 0 \\Leftrightarrow f = g (identity indiscernibles) d(f,g)=d(g,f)d(f, g) = d(g, f) (symmetry) d(f,h)≤d(f,g)+d(g,h)d(f, h) \\leq d(f, g) + d(g, h) (triangle inequality) semimetric satisfies conditions 1-3.","code":"library(fdars) #>  #> Attaching package: 'fdars' #> The following objects are masked from 'package:stats': #>  #>     cov, decompose, deriv, median, sd, var #> The following object is masked from 'package:base': #>  #>     norm library(ggplot2) theme_set(theme_minimal())  # Create example data with different curve types set.seed(42) m <- 100 t_grid <- seq(0, 1, length.out = m)  # Four types of curves curve1 <- sin(2 * pi * t_grid)                    # Sine curve2 <- sin(2 * pi * t_grid + 0.5)              # Phase-shifted sine curve3 <- cos(2 * pi * t_grid)                    # Cosine curve4 <- sin(4 * pi * t_grid)                    # Higher frequency  X <- rbind(curve1, curve2, curve3, curve4) fd <- fdata(X, argvals = t_grid,             names = list(main = \"Four Curve Types\")) plot(fd)"},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/articles/distance-metrics.html","id":"lp-distance-metric-lp","dir":"Articles","previous_headings":"True Metrics","what":"Lp Distance (metric.lp)","title":"Distance Metrics and Semimetrics","text":"LpL^p distance common choice functional data. computes integrated LpL^p norm difference two functions: dp(f,g)=(∫𝒯|f(t)−g(t)|pdt)1/pd_p(f, g) = \\left( \\int_{\\mathcal{T}} |f(t) - g(t)|^p \\, dt \\right)^{1/p} discrete observations, approximated using numerical integration (Simpson’s rule): dp(f,g)≈(∑j=1mwj|f(tj)−g(tj)|p)1/pd_p(f, g) \\approx \\left( \\sum_{j=1}^{m} w_j |f(t_j) - g(t_j)|^p \\right)^{1/p} wjw_j quadrature weights. Special cases: p=2p = 2 (L2/Euclidean): common, corresponds standard functional norm. Sensitive vertical differences. p=1p = 1 (L1/Manhattan): robust outliers L2. p=∞p = \\infty (L-infinity/Chebyshev): Maximum absolute difference, d∞(f,g)=maxt|f(t)−g(t)|d_\\infty(f, g) = \\max_t |f(t) - g(t)|.","code":"# L2 (Euclidean) distance - default dist_l2 <- metric.lp(fd) print(round(as.matrix(dist_l2), 3)) #>        curve1 curve2 curve3 curve4 #> curve1   0.00  0.350  1.000      1 #> curve2   0.35  0.000  0.722      1 #> curve3   1.00  0.722  0.000      1 #> curve4   1.00  1.000  1.000      0  # L1 (Manhattan) distance dist_l1 <- metric.lp(fd, lp = 1)  # L-infinity (maximum) distance dist_linf <- metric.lp(fd, lp = Inf)"},{"path":"https://sipemu.github.io/fdars-r/articles/distance-metrics.html","id":"weighted-lp-distance","dir":"Articles","previous_headings":"True Metrics","what":"Weighted Lp Distance","title":"Distance Metrics and Semimetrics","text":"Apply different weights different parts domain: dp,w(f,g)=(∫𝒯w(t)|f(t)−g(t)|pdt)1/pd_{p,w}(f, g) = \\left( \\int_{\\mathcal{T}} w(t) |f(t) - g(t)|^p \\, dt \\right)^{1/p} useful certain parts domain important others.","code":"# Weight emphasizing the middle of the domain w <- dnorm(t_grid, mean = 0.5, sd = 0.2) w <- w / sum(w) * length(w)  # Normalize  dist_weighted <- metric.lp(fd, lp = 2, w = w)"},{"path":"https://sipemu.github.io/fdars-r/articles/distance-metrics.html","id":"hausdorff-distance-metric-hausdorff","dir":"Articles","previous_headings":"True Metrics","what":"Hausdorff Distance (metric.hausdorff)","title":"Distance Metrics and Semimetrics","text":"Hausdorff distance treats curves sets points (t,f(t))(t, f(t)) 2D space computes maximum minimum distances: dH(f,g)=max{supt∈𝒯infs∈𝒯∥Pf(t)−Pg(s)∥,sups∈𝒯inft∈𝒯∥Pf(t)−Pg(s)∥}d_H(f, g) = \\max\\left\\{ \\sup_{t \\\\mathcal{T}} \\inf_{s \\\\mathcal{T}} \\|P_f(t) - P_g(s)\\|, \\sup_{s \\\\mathcal{T}} \\inf_{t \\\\mathcal{T}} \\|P_f(t) - P_g(s)\\| \\right\\} Pf(t)=(t,f(t))P_f(t) = (t, f(t)) point graph ff time tt. Hausdorff distance useful : Curves may cross timing features less important shape Comparing curves different supports","code":"dist_haus <- metric.hausdorff(fd) print(round(as.matrix(dist_haus), 3)) #>        curve1 curve2 curve3 curve4 #> curve1  0.000  0.479  0.678  0.328 #> curve2  0.479  0.000  0.521  0.416 #> curve3  0.678  0.521  0.000  0.352 #> curve4  0.328  0.416  0.352  0.000"},{"path":"https://sipemu.github.io/fdars-r/articles/distance-metrics.html","id":"dynamic-time-warping-metric-dtw","dir":"Articles","previous_headings":"True Metrics","what":"Dynamic Time Warping (metric.DTW)","title":"Distance Metrics and Semimetrics","text":"DTW allows non-linear alignment curves computing distance. finds optimal warping path π\\pi minimizes: dDTW(f,g)=minπ∑(,j)∈π|f(ti)−g(tj)|2d_{DTW}(f, g) = \\min_{\\pi} \\sqrt{\\sum_{(,j) \\\\pi} |f(t_i) - g(t_j)|^2} subject boundary conditions, monotonicity, continuity constraints. Sakoe-Chiba band constraint limits warping |−j|≤w|- j| \\leq w, preventing excessive distortion: dDTWSC(f,g)=minπ:|−j|≤w∑(,j)∈π|f(ti)−g(tj)|2d_{DTW}^{SC}(f, g) = \\min_{\\pi: |-j| \\leq w} \\sqrt{\\sum_{(,j) \\\\pi} |f(t_i) - g(t_j)|^2} DTW particularly effective : Phase-shifted signals Time series varying speed Comparing signals local time distortions Notice DTW gives smaller distance original sine phase-shifted sine compared L2, can align : DTW band constraint:","code":"dist_dtw <- metric.DTW(fd) print(round(as.matrix(dist_dtw), 3)) #>        curve1 curve2 curve3 curve4 #> curve1  0.000  1.452 18.185 24.844 #> curve2  1.452  0.000  3.488 25.980 #> curve3 18.185  3.488  0.000 40.825 #> curve4 24.844 25.980 40.825  0.000 # Compare L2 vs DTW for phase-shifted curves cat(\"L2 distance (sine vs phase-shifted):\", round(as.matrix(dist_l2)[1, 2], 3), \"\\n\") #> L2 distance (sine vs phase-shifted): 0.35 cat(\"DTW distance (sine vs phase-shifted):\", round(as.matrix(dist_dtw)[1, 2], 3), \"\\n\") #> DTW distance (sine vs phase-shifted): 1.452 # Restrict warping to 10% of the series length dist_dtw_band <- metric.DTW(fd, w = round(m * 0.1))"},{"path":"https://sipemu.github.io/fdars-r/articles/distance-metrics.html","id":"kullback-leibler-divergence-metric-kl","dir":"Articles","previous_headings":"True Metrics","what":"Kullback-Leibler Divergence (metric.kl)","title":"Distance Metrics and Semimetrics","text":"symmetric Kullback-Leibler divergence treats normalized curves probability density functions: dKL(f,g)=12[∫f(t)logf(t)g(t)dt+∫g(t)logg(t)f(t)dt]d_{KL}(f, g) = \\frac{1}{2}\\left[ \\int f(t) \\log\\frac{f(t)}{g(t)} \\, dt + \\int g(t) \\log\\frac{g(t)}{f(t)} \\, dt \\right] computing, curves shifted non-negative normalized integrate 1: f̃(t)=f(t)−minsf(s)+ϵ∫[f(s)−minsf(s)+ϵ]ds\\tilde{f}(t) = \\frac{f(t) - \\min_s f(s) + \\epsilon}{\\int [f(s) - \\min_s f(s) + \\epsilon] \\, ds} metric useful : Comparing density-like functions Distribution comparison Information-theoretic analysis","code":"# Shift curves to be positive for KL X_pos <- X - min(X) + 0.1 fd_pos <- fdata(X_pos, argvals = t_grid)  dist_kl <- metric.kl(fd_pos) print(round(as.matrix(dist_kl), 3)) #>        curve1 curve2 curve3 curve4 #> curve1  0.000  0.139  1.208  1.187 #> curve2  0.139  0.000  0.630  1.426 #> curve3  1.208  0.630  0.000  1.156 #> curve4  1.187  1.426  1.156  0.000"},{"path":"https://sipemu.github.io/fdars-r/articles/distance-metrics.html","id":"semimetrics","dir":"Articles","previous_headings":"","what":"Semimetrics","title":"Distance Metrics and Semimetrics","text":"Semimetrics may satisfy triangle inequality can appropriate certain applications provide computational advantages.","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/distance-metrics.html","id":"pca-based-semimetric-semimetric-pca","dir":"Articles","previous_headings":"Semimetrics","what":"PCA-Based Semimetric (semimetric.pca)","title":"Distance Metrics and Semimetrics","text":"Projects curves onto first qq principal components computes Euclidean distance reduced space: dPCA(f,g)=∑k=1q(ξkf−ξkg)2d_{PCA}(f, g) = \\sqrt{\\sum_{k=1}^{q} (\\xi_k^f - \\xi_k^g)^2} ξkf=⟨f−f‾,ϕk⟩\\xi_k^f = \\langle f - \\bar{f}, \\phi_k \\rangle kk-th principal component score ff, ϕk\\phi_k eigenfunctions functional PCA. semimetric useful : Dimension reduction distance computation Noise reduction (low-rank approximation) Computational efficiency many evaluation points","code":"# Distance using first 3 PCs dist_pca <- semimetric.pca(fd, ncomp = 3) print(round(as.matrix(dist_pca), 3)) #>        [,1]  [,2]   [,3]   [,4] #> [1,]  0.000 3.514 10.000  9.950 #> [2,]  3.514 0.000  7.198  9.961 #> [3,] 10.000 7.198  0.000 10.000 #> [4,]  9.950 9.961 10.000  0.000"},{"path":"https://sipemu.github.io/fdars-r/articles/distance-metrics.html","id":"derivative-based-semimetric-semimetric-deriv","dir":"Articles","previous_headings":"Semimetrics","what":"Derivative-Based Semimetric (semimetric.deriv)","title":"Distance Metrics and Semimetrics","text":"Computes LpL^p distance based rr-th derivative curves: dderiv(r)(f,g)=(∫𝒯|f(r)(t)−g(r)(t)|pdt)1/pd_{deriv}^{(r)}(f, g) = \\left( \\int_{\\mathcal{T}} |f^{(r)}(t) - g^{(r)}(t)|^p \\, dt \\right)^{1/p} f(r)f^{(r)} denotes rr-th derivative ff. semimetric focuses shape dynamics curves rather absolute values. particularly useful : Comparing rate change (first derivative) Analyzing curvature (second derivative) Functions measured different baselines","code":"# First derivative (velocity) dist_deriv1 <- semimetric.deriv(fd, nderiv = 1)  # Second derivative (acceleration/curvature) dist_deriv2 <- semimetric.deriv(fd, nderiv = 2)  cat(\"First derivative distances:\\n\") #> First derivative distances: print(round(as.matrix(dist_deriv1), 3)) #>       [,1]  [,2]  [,3]  [,4] #> [1,] 0.000 2.197 6.279 9.912 #> [2,] 2.197 0.000 4.530 9.912 #> [3,] 6.279 4.530 0.000 9.912 #> [4,] 9.912 9.912 9.912 0.000"},{"path":"https://sipemu.github.io/fdars-r/articles/distance-metrics.html","id":"basis-semimetric-semimetric-basis","dir":"Articles","previous_headings":"Semimetrics","what":"Basis Semimetric (semimetric.basis)","title":"Distance Metrics and Semimetrics","text":"Projects curves onto basis (B-spline Fourier) computes Euclidean distance coefficient vectors: dbasis(f,g)=∥cf−cg∥2=∑k=1K(ckf−ckg)2d_{basis}(f, g) = \\|c^f - c^g\\|_2 = \\sqrt{\\sum_{k=1}^{K} (c_k^f - c_k^g)^2} cf=(c1f,…,cKf)c^f = (c_1^f, \\ldots, c_K^f) basis coefficients f(t)≈∑k=1KckfBk(t)f(t) \\approx \\sum_{k=1}^{K} c_k^f B_k(t). B-splines: Local support provides good approximation local features. Fourier basis: Global support captures periodic patterns efficiently.","code":"# B-spline basis (local features) dist_bspline <- semimetric.basis(fd, nbasis = 15, basis = \"bspline\")  # Fourier basis (periodic patterns) dist_fourier <- semimetric.basis(fd, nbasis = 11, basis = \"fourier\")  cat(\"B-spline basis distances:\\n\") #> B-spline basis distances: print(round(as.matrix(dist_bspline), 3)) #>       [,1]  [,2]  [,3]  [,4] #> [1,] 0.000 1.509 4.015 3.913 #> [2,] 1.509 0.000 2.771 3.999 #> [3,] 4.015 2.771 0.000 4.289 #> [4,] 3.913 3.999 4.289 0.000"},{"path":"https://sipemu.github.io/fdars-r/articles/distance-metrics.html","id":"fourier-semimetric-semimetric-fourier","dir":"Articles","previous_headings":"Semimetrics","what":"Fourier Semimetric (semimetric.fourier)","title":"Distance Metrics and Semimetrics","text":"Uses Fast Fourier Transform (FFT) compute Fourier coefficients measures distance based first KK frequency components: dFFT(f,g)=∑k=0K|f̂k−ĝk|2d_{FFT}(f, g) = \\sqrt{\\sum_{k=0}^{K} |\\hat{f}_k - \\hat{g}_k|^2} f̂k\\hat{f}_k kk-th Fourier coefficient computed via FFT. computationally efficient large datasets particularly useful periodic frequency-domain analysis.","code":"dist_fft <- semimetric.fourier(fd, nfreq = 5) cat(\"Fourier (FFT) distances:\\n\") #> Fourier (FFT) distances: print(round(as.matrix(dist_fft), 3)) #>        curve1 curve2 curve3 curve4 #> curve1  0.000  0.005  0.012  0.694 #> curve2  0.005  0.000  0.008  0.695 #> curve3  0.012  0.008  0.000  0.700 #> curve4  0.694  0.695  0.700  0.000"},{"path":"https://sipemu.github.io/fdars-r/articles/distance-metrics.html","id":"horizontal-shift-semimetric-semimetric-hshift","dir":"Articles","previous_headings":"Semimetrics","what":"Horizontal Shift Semimetric (semimetric.hshift)","title":"Distance Metrics and Semimetrics","text":"Finds optimal horizontal shift computing L2L^2 distance: dhshift(f,g)=min|h|≤hmax(∫𝒯|f(t)−g(t+h)|2dt)1/2d_{hshift}(f, g) = \\min_{|h| \\leq h_{max}} \\left( \\int_{\\mathcal{T}} |f(t) - g(t+h)|^2 \\, dt \\right)^{1/2} hh shift discrete time units hmaxh_{max} maximum allowed shift. semimetric simpler DTW (horizontal shifts, warping) can effective : Phase-shifted periodic signals ECG physiological signals timing variations Comparing curves horizontal alignment meaningful","code":"dist_hshift <- semimetric.hshift(fd) cat(\"Horizontal shift distances:\\n\") #> Horizontal shift distances: print(round(as.matrix(dist_hshift), 3)) #>        curve1 curve2 curve3 curve4 #> curve1  0.000  0.005  0.010  0.733 #> curve2  0.005  0.000  0.005  0.629 #> curve3  0.010  0.005  0.000  0.718 #> curve4  0.733  0.629  0.718  0.000"},{"path":"https://sipemu.github.io/fdars-r/articles/distance-metrics.html","id":"unified-interface","dir":"Articles","previous_headings":"","what":"Unified Interface","title":"Distance Metrics and Semimetrics","text":"Use metric() unified interface distance functions:","code":"# Different methods via single function d1 <- metric(fd, method = \"lp\", lp = 2) d2 <- metric(fd, method = \"dtw\") d3 <- metric(fd, method = \"hausdorff\") d4 <- metric(fd, method = \"pca\", ncomp = 2)"},{"path":"https://sipemu.github.io/fdars-r/articles/distance-metrics.html","id":"comparing-distance-measures","dir":"Articles","previous_headings":"","what":"Comparing Distance Measures","title":"Distance Metrics and Semimetrics","text":"Different distance measures capture different aspects curve similarity:","code":"# Create comparison data dists <- list(   L2 = as.vector(as.matrix(dist_l2)),   L1 = as.vector(as.matrix(dist_l1)),   DTW = as.vector(as.matrix(dist_dtw)),   Hausdorff = as.vector(as.matrix(dist_haus)) )  # Correlation between distance measures dist_mat <- do.call(cbind, dists) cat(\"Correlation between distance measures:\\n\") #> Correlation between distance measures: print(round(cor(dist_mat), 2)) #>             L2   L1  DTW Hausdorff #> L2        1.00 1.00 0.82      0.74 #> L1        1.00 1.00 0.82      0.74 #> DTW       0.82 0.82 1.00      0.32 #> Hausdorff 0.74 0.74 0.32      1.00"},{"path":"https://sipemu.github.io/fdars-r/articles/distance-metrics.html","id":"distance-matrices-for-larger-samples","dir":"Articles","previous_headings":"","what":"Distance Matrices for Larger Samples","title":"Distance Metrics and Semimetrics","text":"","code":"# Generate larger sample set.seed(123) n <- 50 X_large <- matrix(0, n, m) for (i in 1:n) {   phase <- runif(1, 0, 2*pi)   freq <- sample(1:3, 1)   X_large[i, ] <- sin(freq * pi * t_grid + phase) + rnorm(m, sd = 0.1) } fd_large <- fdata(X_large, argvals = t_grid)  # Compute distance matrix dist_matrix <- metric.lp(fd_large)  # Visualize as heatmap using ggplot2 dist_df <- expand.grid(Curve1 = 1:n, Curve2 = 1:n) dist_df$Distance <- as.vector(as.matrix(dist_matrix))  ggplot(dist_df, aes(x = Curve1, y = Curve2, fill = Distance)) +   geom_tile() +   scale_fill_viridis_c(option = \"magma\") +   coord_equal() +   labs(x = \"Curve\", y = \"Curve\", title = \"L2 Distance Matrix\") +   theme_minimal()"},{"path":"https://sipemu.github.io/fdars-r/articles/distance-metrics.html","id":"metric-properties-summary","dir":"Articles","previous_headings":"","what":"Metric Properties Summary","title":"Distance Metrics and Semimetrics","text":"* DTW satisfies triangle inequality using warping path ** satisfy triangle inequality reduced/transformed space","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/articles/distance-metrics.html","id":"performance","dir":"Articles","previous_headings":"","what":"Performance","title":"Distance Metrics and Semimetrics","text":"Distance computations parallelized Rust:","code":"# Benchmark for 500 curves X_bench <- matrix(rnorm(500 * 200), 500, 200) fd_bench <- fdata(X_bench)  system.time(metric.lp(fd_bench)) #>    user  system elapsed #>   0.089   0.000   0.045  system.time(metric.DTW(fd_bench)) #>    user  system elapsed #>   1.234   0.000   0.312"},{"path":"https://sipemu.github.io/fdars-r/articles/distance-metrics.html","id":"using-distances-in-other-methods","dir":"Articles","previous_headings":"","what":"Using Distances in Other Methods","title":"Distance Metrics and Semimetrics","text":"Distance functions can passed clustering regression:","code":"# K-means with L1 distance km_l1 <- cluster.kmeans(fd_large, ncl = 3, metric = \"L1\", seed = 42)  # K-means with custom metric function km_dtw <- cluster.kmeans(fd_large, ncl = 3, metric = metric.DTW, seed = 42)  # Nonparametric regression uses distances internally y <- rnorm(n) fit_np <- fregre.np(fd_large, y, metric = metric.lp)"},{"path":"https://sipemu.github.io/fdars-r/articles/distance-metrics.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Distance Metrics and Semimetrics","text":"Berndt, D.J. Clifford, J. (1994). Using Dynamic Time Warping Find Patterns Time Series. KDD Workshop, 359-370. Ferraty, F. Vieu, P. (2006). Nonparametric Functional Data Analysis. Springer. Ramsay, J.O. Silverman, B.W. (2005). Functional Data Analysis. Springer, 2nd edition. Sakoe, H. Chiba, S. (1978). Dynamic programming algorithm optimization spoken word recognition. IEEE Transactions Acoustics, Speech, Signal Processing, 26(1), 43-49.","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/fpca.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Functional Principal Component Analysis (FPCA)","text":"Functional Principal Component Analysis (FPCA) cornerstone technique functional data analysis. extends classical PCA infinite-dimensional function spaces, providing powerful tool dimension reduction, visualization, feature extraction functional data.","code":"library(fdars) #>  #> Attaching package: 'fdars' #> The following objects are masked from 'package:stats': #>  #>     cov, decompose, deriv, median, sd, var #> The following object is masked from 'package:base': #>  #>     norm library(ggplot2) theme_set(theme_minimal()) set.seed(42)"},{"path":"https://sipemu.github.io/fdars-r/articles/fpca.html","id":"why-fpca","dir":"Articles","previous_headings":"","what":"Why FPCA?","title":"Functional Principal Component Analysis (FPCA)","text":"working functional data, face several challenges: High dimensionality: curve observed many points Infinite-dimensional nature: Curves live function spaces Correlation structure: Points curve highly correlated Noise: Observations contain measurement error FPCA addresses challenges finding principal modes variation data—orthogonal functions capture curves differ .","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/articles/fpca.html","id":"the-karhunen-loève-expansion","dir":"Articles","previous_headings":"Mathematical Background","what":"The Karhunen-Loève Expansion","title":"Functional Principal Component Analysis (FPCA)","text":"square-integrable random function X(t)X(t) can represented : X(t)=μ(t)+∑k=1∞ξkϕk(t)X(t) = \\mu(t) + \\sum_{k=1}^{\\infty} \\xi_k \\phi_k(t) : μ(t)\\mu(t) mean function ϕk(t)\\phi_k(t) eigenfunctions (functional principal components) ξk\\xi_k scores (random coefficients) eigenfunctions satisfy: ∫C(s,t)ϕk(s)ds=λkϕk(t)\\int C(s, t) \\phi_k(s) \\, ds = \\lambda_k \\phi_k(t) C(s,t)=Cov(X(s),X(t))C(s, t) = \\text{Cov}(X(s), X(t)) covariance function λk\\lambda_k eigenvalues (variances explained component).","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/fpca.html","id":"key-properties","dir":"Articles","previous_headings":"Mathematical Background","what":"Key Properties","title":"Functional Principal Component Analysis (FPCA)","text":"Orthonormality: ∫ϕj(t)ϕk(t)dt=δjk\\int \\phi_j(t) \\phi_k(t) \\, dt = \\delta_{jk} Uncorrelated scores: Cov(ξj,ξk)=λjδjk\\text{Cov}(\\xi_j, \\xi_k) = \\lambda_j \\delta_{jk} Optimal reconstruction: FPCA minimizes integrated squared error fixed number components Variance ordering: λ1≥λ2≥⋯≥0\\lambda_1 \\geq \\lambda_2 \\geq \\cdots \\geq 0","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/fpca.html","id":"example-growth-curves","dir":"Articles","previous_headings":"","what":"Example: Growth Curves","title":"Functional Principal Component Analysis (FPCA)","text":"Let’s demonstrate FPCA simulated growth data showing different growth patterns.","code":"# Simulate growth curves with two main modes of variation n <- 50 m <- 100 t <- seq(0, 18, length.out = m)  # Age 0-18 years  # Base growth pattern (logistic-like) base_growth <- function(t) 50 + 130 / (1 + exp(-0.5 * (t - 10)))  # Generate curves with: # - Overall height variation (PC1: taller/shorter) # - Growth timing variation (PC2: earlier/later maturation) X <- matrix(0, n, m) height_effect <- rnorm(n, sd = 10)      # Individual height differences timing_effect <- rnorm(n, sd = 1.5)     # Individual timing differences  for (i in 1:n) {   shifted_t <- t - timing_effect[i]   X[i, ] <- base_growth(shifted_t) + height_effect[i] + rnorm(m, sd = 2) }  fd <- fdata(X, argvals = t) plot(fd) +   labs(x = \"Age (years)\", y = \"Height (cm)\", title = \"Simulated Growth Curves\")"},{"path":"https://sipemu.github.io/fdars-r/articles/fpca.html","id":"performing-fpca","dir":"Articles","previous_headings":"","what":"Performing FPCA","title":"Functional Principal Component Analysis (FPCA)","text":"fdata2pc() function computes functional principal components: output shows: Singular values: Related importance component Variance explained: Percentage total variance captured PC Cumulative variance: Running total—often aim 90-95%","code":"# Extract first 4 principal components fpca <- fdata2pc(fd, ncomp = 4) print(fpca) #> Functional Principal Component Analysis #> ======================================== #> Number of observations: 50  #> Number of components: 4  #>  #> Variance explained: #>   PC1: 92.4% (cumulative: 92.4%) #>   PC2: 5.9% (cumulative: 98.3%) #>   PC3: 1.6% (cumulative: 99.9%) #>   PC4: 0.1% (cumulative: 100.0%)"},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/articles/fpca.html","id":"principal-component-functions","dir":"Articles","previous_headings":"Visualizing FPCA Results","what":"Principal Component Functions","title":"Functional Principal Component Analysis (FPCA)","text":"plot() method type = \"components\" shows PC affects mean curve. component displayed facet clear comparison:  facet shows one principal component solid lines differentiated color: Black: Mean function μ(t)\\mu(t) Blue: Mean + perturbation (μ+c⋅ϕk\\mu + c \\cdot \\phi_k) Coral: Mean - perturbation (μ−c⋅ϕk\\mu - c \\cdot \\phi_k) c=2×λkc = 2 \\times \\sqrt{\\lambda_k} scales perturbation component’s importance. can show positive perturbation setting show_both_directions = FALSE:  Interpretation: PC1: Overall height differences (taller vs shorter individuals) PC2: Growth timing (earlier vs later maturation) PC3: subtle shape variations","code":"plot(fpca, type = \"components\", ncomp = 3, multiple = 2) plot(fpca, type = \"components\", ncomp = 2, show_both_directions = FALSE)"},{"path":"https://sipemu.github.io/fdars-r/articles/fpca.html","id":"eigenfunctions","dir":"Articles","previous_headings":"Visualizing FPCA Results","what":"Eigenfunctions","title":"Functional Principal Component Analysis (FPCA)","text":"eigenfunctions show shape mode variation:","code":"# Plot the first 3 eigenfunctions df_eigen <- data.frame(   t = rep(t, 3),   loading = c(fpca$rotation$data[1, ], fpca$rotation$data[2, ], fpca$rotation$data[3, ]),   PC = factor(rep(paste0(\"PC\", 1:3), each = m)) )  ggplot(df_eigen, aes(x = t, y = loading, color = PC)) +   geom_line(linewidth = 1) +   geom_hline(yintercept = 0, linetype = \"dashed\", alpha = 0.5) +   scale_color_brewer(palette = \"Set1\") +   labs(x = \"Age (years)\", y = \"Loading\",        title = \"Principal Component Eigenfunctions\")"},{"path":"https://sipemu.github.io/fdars-r/articles/fpca.html","id":"scree-plot","dir":"Articles","previous_headings":"Visualizing FPCA Results","what":"Scree Plot","title":"Functional Principal Component Analysis (FPCA)","text":"variance plot shows much component contributes:  scree plot helps decide many components retain. Common criteria: Retain components explaining 90-95% cumulative variance Look “elbow” explained variance drops sharply Use cross-validation prediction tasks","code":"plot(fpca, type = \"variance\")"},{"path":"https://sipemu.github.io/fdars-r/articles/fpca.html","id":"score-plot","dir":"Articles","previous_headings":"Visualizing FPCA Results","what":"Score Plot","title":"Functional Principal Component Analysis (FPCA)","text":"scores show observation falls PC space. point labeled observation ID, allowing identify specific curves interest:  Curves similar scores similar shapes. Outliers appear far center.","code":"plot(fpca, type = \"scores\")"},{"path":"https://sipemu.github.io/fdars-r/articles/fpca.html","id":"plotting-individual-curves-by-id","dir":"Articles","previous_headings":"Visualizing FPCA Results","what":"Plotting Individual Curves by ID","title":"Functional Principal Component Analysis (FPCA)","text":"identifying interesting observations score plot (e.g., outliers extreme cases), can plot separately understand makes unusual:  workflow allows : 1. Identify interesting observations score plot IDs 2. Extract visualize specific curves 3. Understand certain observations outliers extreme scores","code":"# Identify extreme observations from the score plot # High PC1 = taller individuals, Low PC1 = shorter individuals # High PC2 = later maturation, Low PC2 = earlier maturation  # Find observations at extremes extreme_tall <- which.max(fpca$x[, 1]) extreme_short <- which.min(fpca$x[, 1]) extreme_late <- which.max(fpca$x[, 2]) extreme_early <- which.min(fpca$x[, 2])  # Plot these specific curves ids_of_interest <- c(extreme_tall, extreme_short, extreme_late, extreme_early) labels <- c(\"Tallest (high PC1)\", \"Shortest (low PC1)\",             \"Late maturer (high PC2)\", \"Early maturer (low PC2)\")  df_selected <- data.frame(   t = rep(t, length(ids_of_interest)),   height = as.vector(t(fd$data[ids_of_interest, ])),   curve = factor(rep(labels, each = m), levels = labels),   id = rep(ids_of_interest, each = m) )  ggplot(df_selected, aes(x = t, y = height, color = curve)) +   geom_line(linewidth = 1) +   scale_color_brewer(palette = \"Set1\") +   labs(title = \"Curves at Score Plot Extremes\",        subtitle = paste(\"IDs:\", paste(ids_of_interest, collapse = \", \")),        x = \"Age (years)\", y = \"Height (cm)\", color = \"\") +   theme(legend.position = \"bottom\")"},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/articles/fpca.html","id":"dimension-reduction","dir":"Articles","previous_headings":"Benefits of FPCA","what":"1. Dimension Reduction","title":"Functional Principal Component Analysis (FPCA)","text":"FPCA reduces infinite-dimensional curves scores:","code":"# Original data: 50 curves x 100 points = 5000 values cat(\"Original dimensions:\", nrow(fd$data), \"x\", ncol(fd$data), \"\\n\") #> Original dimensions: 50 x 100  # After FPCA: 50 curves x 4 scores = 200 values cat(\"Reduced dimensions:\", nrow(fpca$x), \"x\", ncol(fpca$x), \"\\n\") #> Reduced dimensions: 50 x 4  # Compression ratio cat(\"Compression:\", round(100 * (1 - prod(dim(fpca$x)) / prod(dim(fd$data))), 1), \"%\\n\") #> Compression: 96 %"},{"path":"https://sipemu.github.io/fdars-r/articles/fpca.html","id":"denoising","dir":"Articles","previous_headings":"Benefits of FPCA","what":"2. Denoising","title":"Functional Principal Component Analysis (FPCA)","text":"Reconstructing curves PCs removes noise:","code":"# Reconstruct using only first 2 PCs scores_2pc <- fpca$x[, 1:2] loadings_2pc <- fpca$rotation$data[1:2, ]  # Reconstruction: X_reconstructed = mean + scores %*% loadings X_reconstructed <- matrix(fpca$mean, n, m, byrow = TRUE) + scores_2pc %*% loadings_2pc  # Compare original noisy curve with reconstruction i <- 1  # First curve df_denoise <- data.frame(   t = rep(t, 2),   height = c(fd$data[i, ], X_reconstructed[i, ]),   type = rep(c(\"Original (noisy)\", \"Reconstructed (2 PCs)\"), each = m) )  ggplot(df_denoise, aes(x = t, y = height, color = type)) +   geom_line(linewidth = 1) +   scale_color_manual(values = c(\"Original (noisy)\" = \"gray50\",                                  \"Reconstructed (2 PCs)\" = \"steelblue\")) +   labs(x = \"Age (years)\", y = \"Height (cm)\",        title = \"Denoising via FPCA Reconstruction\") +   theme(legend.position = \"bottom\", legend.title = element_blank())"},{"path":"https://sipemu.github.io/fdars-r/articles/fpca.html","id":"interpretable-features","dir":"Articles","previous_headings":"Benefits of FPCA","what":"3. Interpretable Features","title":"Functional Principal Component Analysis (FPCA)","text":"PC scores serve meaningful features analysis:","code":"# Scores as features scores_df <- data.frame(   curve_id = 1:n,   PC1 = fpca$x[, 1],   PC2 = fpca$x[, 2],   true_height = height_effect,   true_timing = timing_effect )  # PC1 correlates with height variation cat(\"Correlation(PC1, height effect):\",     round(cor(scores_df$PC1, scores_df$true_height), 3), \"\\n\") #> Correlation(PC1, height effect): 0.784  # PC2 correlates with timing variation cat(\"Correlation(PC2, timing effect):\",     round(cor(scores_df$PC2, scores_df$true_timing), 3), \"\\n\") #> Correlation(PC2, timing effect): 0.596"},{"path":"https://sipemu.github.io/fdars-r/articles/fpca.html","id":"outlier-detection","dir":"Articles","previous_headings":"Benefits of FPCA","what":"4. Outlier Detection","title":"Functional Principal Component Analysis (FPCA)","text":"Extreme scores indicate unusual curves:","code":"# Mahalanobis-like distance using PC scores pc_vars <- fpca$d^2 / (n - 1)  # Variance of each PC standardized_scores <- sweep(fpca$x, 2, sqrt(pc_vars[1:ncol(fpca$x)]), \"/\") distances <- rowSums(standardized_scores^2)  # Flag potential outliers (chi-squared threshold) threshold <- qchisq(0.975, df = ncol(fpca$x)) outlier_idx <- which(distances > threshold) cat(\"Potential outliers:\", length(outlier_idx), \"curves\\n\") #> Potential outliers: 1 curves"},{"path":"https://sipemu.github.io/fdars-r/articles/fpca.html","id":"efficient-storage-and-computation","dir":"Articles","previous_headings":"Benefits of FPCA","what":"5. Efficient Storage and Computation","title":"Functional Principal Component Analysis (FPCA)","text":"large datasets, storing scores instead full curves saves memory:","code":"# Storage comparison original_size <- object.size(fd$data) compressed_size <- object.size(fpca$x) + object.size(fpca$rotation$data) + object.size(fpca$mean)  cat(\"Original size:\", format(original_size, units = \"Kb\"), \"\\n\") #> Original size: 39.3 Kb cat(\"FPCA representation:\", format(compressed_size, units = \"Kb\"), \"\\n\") #> FPCA representation: 5.9 Kb"},{"path":"https://sipemu.github.io/fdars-r/articles/fpca.html","id":"fpca-for-regression","dir":"Articles","previous_headings":"","what":"FPCA for Regression","title":"Functional Principal Component Analysis (FPCA)","text":"PC scores commonly used predictors regression:","code":"# Create a response related to growth # Final height depends on both baseline and timing y <- 0.5 * height_effect + 2 * timing_effect + rnorm(n, sd = 1)  # Principal Component Regression fit <- fregre.pc(fd, y, ncomp = 3)  # Cross-validation to select optimal number of components cv_result <- fregre.pc.cv(fd, y, kfold = 5, ncomp.range = 1:6, seed = 42) cat(\"Optimal number of components:\", cv_result$optimal.ncomp, \"\\n\") #> Optimal number of components: 6  # Visualize CV results df_cv <- data.frame(   ncomp = 1:6,   MSE = cv_result$cv.errors,   se = cv_result$cv.se )  ggplot(df_cv, aes(x = ncomp, y = MSE)) +   geom_line(color = \"steelblue\", linewidth = 1) +   geom_point(color = \"steelblue\", size = 3) +   geom_errorbar(aes(ymin = MSE - se, ymax = MSE + se), width = 0.2, color = \"steelblue\") +   geom_vline(xintercept = cv_result$optimal.ncomp, linetype = \"dashed\", color = \"red\") +   labs(x = \"Number of Components\", y = \"Cross-Validation MSE\",        title = \"Selecting Number of PC Components\") +   scale_x_continuous(breaks = 1:6)"},{"path":"https://sipemu.github.io/fdars-r/articles/fpca.html","id":"choosing-the-number-of-components","dir":"Articles","previous_headings":"","what":"Choosing the Number of Components","title":"Functional Principal Component Analysis (FPCA)","text":"Several approaches exist selecting number components:","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/fpca.html","id":"variance-threshold","dir":"Articles","previous_headings":"Choosing the Number of Components","what":"1. Variance Threshold","title":"Functional Principal Component Analysis (FPCA)","text":"","code":"# Calculate cumulative variance var_explained <- fpca$d^2 / sum(fpca$d^2) cum_var <- cumsum(var_explained)  # Find number of components for 95% variance ncomp_95 <- which(cum_var >= 0.95)[1] cat(\"Components for 95% variance:\", ncomp_95, \"\\n\") #> Components for 95% variance: 2"},{"path":"https://sipemu.github.io/fdars-r/articles/fpca.html","id":"scree-plot-elbow","dir":"Articles","previous_headings":"Choosing the Number of Components","what":"2. Scree Plot Elbow","title":"Functional Principal Component Analysis (FPCA)","text":"Visual inspection scree plot often reveals natural cutoff.","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/fpca.html","id":"cross-validation","dir":"Articles","previous_headings":"Choosing the Number of Components","what":"3. Cross-Validation","title":"Functional Principal Component Analysis (FPCA)","text":"prediction tasks, cross-validation directly optimizes predictive performance.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/articles/fpca.html","id":"clustering-in-pc-space","dir":"Articles","previous_headings":"Advanced: Working with Scores","what":"Clustering in PC Space","title":"Functional Principal Component Analysis (FPCA)","text":"","code":"# K-means clustering on PC scores km <- kmeans(fpca$x[, 1:2], centers = 3, nstart = 10)  # Visualize clusters df_scores <- data.frame(   PC1 = fpca$x[, 1],   PC2 = fpca$x[, 2],   cluster = factor(km$cluster) )  ggplot(df_scores, aes(x = PC1, y = PC2, color = cluster)) +   geom_point(size = 3) +   labs(title = \"Clustering in PC Score Space\") +   scale_color_brewer(palette = \"Set1\")"},{"path":"https://sipemu.github.io/fdars-r/articles/fpca.html","id":"functional-boxplot-via-fpca","dir":"Articles","previous_headings":"Advanced: Working with Scores","what":"Functional Boxplot via FPCA","title":"Functional Principal Component Analysis (FPCA)","text":"functional boxplot uses depth measures, PC scores provide alternative view centrality:","code":"# Distance from center in PC space indicates \"outlyingness\" center <- colMeans(fpca$x) pc_distances <- sqrt(rowSums(sweep(fpca$x, 2, center)^2))  # Color curves by distance from center df_curves <- data.frame(   t = rep(t, n),   height = as.vector(t(fd$data)),   curve_id = rep(1:n, each = m),   distance = rep(pc_distances, each = m) )  ggplot(df_curves, aes(x = t, y = height, group = curve_id, color = distance)) +   geom_line(alpha = 0.7) +   scale_color_viridis_c(option = \"plasma\", name = \"PC Distance\") +   labs(x = \"Age (years)\", y = \"Height (cm)\",        title = \"Curves Colored by Distance from PC Center\")"},{"path":"https://sipemu.github.io/fdars-r/articles/fpca.html","id":"comparison-with-classical-pca","dir":"Articles","previous_headings":"","what":"Comparison with Classical PCA","title":"Functional Principal Component Analysis (FPCA)","text":"FPCA discretized curves mathematically equivalent classical PCA data matrix, functional interpretation adds value:","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/fpca.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Functional Principal Component Analysis (FPCA)","text":"Ramsay, J.O. Silverman, B.W. (2005). Functional Data Analysis, 2nd Edition. Springer. Ramsay, J.O. Silverman, B.W. (2002). Applied Functional Data Analysis. Springer. Yao, F., Müller, H.G., Wang, J.L. (2005). Functional Data Analysis Sparse Longitudinal Data. Journal American Statistical Association, 100(470), 577-590.","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/intro-to-smoothing.html","id":"why-smooth-functional-data","dir":"Articles","previous_headings":"","what":"Why Smooth Functional Data?","title":"Introduction to Smoothing Functional Data","text":"Real-world functional data almost always contains measurement noise. Raw observations discrete samples underlying smooth process, contaminated : Measurement error: Instrument precision limits Sampling noise: Random variation time point Digitization artifacts: Finite resolution recording devices Smoothing transforms noisy discrete observations smooth functional objects, revealing true underlying signal. essential : Computing derivatives (noise amplifies dramatically) Meaningful curve comparisons Interpretable visualizations Reliable statistical inference","code":"library(fdars) #>  #> Attaching package: 'fdars' #> The following objects are masked from 'package:stats': #>  #>     cov, decompose, deriv, median, sd, var #> The following object is masked from 'package:base': #>  #>     norm library(ggplot2) theme_set(theme_minimal()) set.seed(42)"},{"path":"https://sipemu.github.io/fdars-r/articles/intro-to-smoothing.html","id":"loading-real-data-the-berkeley-growth-study","dir":"Articles","previous_headings":"","what":"Loading Real Data: The Berkeley Growth Study","title":"Introduction to Smoothing Functional Data","text":"Berkeley Growth Study tracked heights 54 girls 39 boys ages 1 18. classic dataset available fda package.","code":"# Check if fda package is available if (!requireNamespace(\"fda\", quietly = TRUE)) {   message(\"Install 'fda' package for real data examples: install.packages('fda')\")   # Create synthetic growth-like data as fallback   age <- seq(1, 18, length.out = 31)   n_girls <- 20   heights <- matrix(0, n_girls, length(age))   for (i in 1:n_girls) {     # Gompertz growth curve with individual variation     A <- rnorm(1, 170, 5)  # asymptotic height     b <- rnorm(1, 2.5, 0.2)     c <- rnorm(1, 0.15, 0.02)     heights[i, ] <- A * exp(-b * exp(-c * age)) + rnorm(length(age), sd = 1.5)   } } else {   data(growth, package = \"fda\")   age <- growth$age   heights <- t(growth$hgtf)  # Girls' heights (rows = curves, cols = time)   n_girls <- nrow(heights) }  # Create fdata object fd_raw <- fdata(heights, argvals = age) cat(\"Dataset:\", n_girls, \"growth curves measured at\", length(age), \"ages\\n\") #> Dataset: 54 growth curves measured at 31 ages"},{"path":"https://sipemu.github.io/fdars-r/articles/intro-to-smoothing.html","id":"visualizing-the-raw-data","dir":"Articles","previous_headings":"Loading Real Data: The Berkeley Growth Study","what":"Visualizing the Raw Data","title":"Introduction to Smoothing Functional Data","text":"data appears relatively smooth height carefully measured. Let’s add realistic measurement noise demonstrate smoothing techniques:","code":"plot(fd_raw, main = \"Berkeley Growth Study: Girls' Heights\",      xlab = \"Age (years)\", ylab = \"Height (cm)\") # Add measurement noise to simulate less precise instruments noise_sd <- 2.0  # cm of measurement error heights_noisy <- heights + matrix(rnorm(length(heights), sd = noise_sd),                                    nrow = nrow(heights)) fd_noisy <- fdata(heights_noisy, argvals = age)  # Compare original and noisy using faceted ggplot df_compare <- rbind(   data.frame(     age = rep(age, 5),     height = as.vector(t(fd_raw$data[1:5, ])),     curve = rep(1:5, each = length(age)),     type = \"Original\"   ),   data.frame(     age = rep(age, 5),     height = as.vector(t(fd_noisy$data[1:5, ])),     curve = rep(1:5, each = length(age)),     type = \"With Noise\"   ) ) df_compare$curve <- factor(df_compare$curve)  ggplot(df_compare, aes(x = age, y = height, color = curve)) +   geom_line() +   facet_wrap(~ type) +   labs(x = \"Age (years)\", y = \"Height (cm)\", color = \"Curve\") +   theme_minimal() +   theme(legend.position = \"bottom\")"},{"path":"https://sipemu.github.io/fdars-r/articles/intro-to-smoothing.html","id":"method-1-p-spline-smoothing","dir":"Articles","previous_headings":"","what":"Method 1: P-spline Smoothing","title":"Introduction to Smoothing Functional Data","text":"Penalized splines (P-splines) powerful flexible smoothing method. balance two objectives: Fit data closely (minimize residuals) Keep curve smooth (penalize roughness) smoothing parameter λ\\lambda controls trade-: - Small λ\\lambda: Follows data closely, may wiggly - Large λ\\lambda: smooth, may miss real features","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/intro-to-smoothing.html","id":"automatic-smoothing-with-p-splines","dir":"Articles","previous_headings":"Method 1: P-spline Smoothing","what":"Automatic Smoothing with P-splines","title":"Introduction to Smoothing Functional Data","text":"","code":"# pspline() automatically selects optimal lambda via GCV fd_pspline <- pspline(fd_noisy) print(fd_pspline) #> P-spline Smoothing Results #> ========================== #> Number of curves: 54  #> Number of basis functions: 20  #> Penalty order: 2  #> Lambda: 1e+00  #> Effective df: 6.81  #> GCV: 5.701e+00"},{"path":"https://sipemu.github.io/fdars-r/articles/intro-to-smoothing.html","id":"visualizing-the-result","dir":"Articles","previous_headings":"Method 1: P-spline Smoothing","what":"Visualizing the Result","title":"Introduction to Smoothing Functional Data","text":"","code":"# Compare noisy vs smoothed for first curve idx <- 1 df_pspline <- data.frame(   age = rep(age, 3),   height = c(fd_noisy$data[idx, ], fd_pspline$fdata$data[idx, ], fd_raw$data[idx, ]),   type = factor(rep(c(\"Noisy data\", \"P-spline smooth\", \"Original\"), each = length(age)),                 levels = c(\"Noisy data\", \"P-spline smooth\", \"Original\")) )  ggplot(df_pspline, aes(x = age, y = height, color = type, linetype = type)) +   geom_point(data = subset(df_pspline, type == \"Noisy data\"),              color = \"gray60\", size = 1) +   geom_line(data = subset(df_pspline, type != \"Noisy data\"), linewidth = 1) +   scale_color_manual(values = c(\"Noisy data\" = \"gray60\", \"P-spline smooth\" = \"blue\",                                  \"Original\" = \"red\")) +   scale_linetype_manual(values = c(\"Noisy data\" = \"blank\", \"P-spline smooth\" = \"solid\",                                     \"Original\" = \"dashed\")) +   labs(x = \"Age (years)\", y = \"Height (cm)\", title = \"P-spline Smoothing\",        color = NULL, linetype = NULL) +   theme_minimal() +   theme(legend.position = \"bottom\")"},{"path":"https://sipemu.github.io/fdars-r/articles/intro-to-smoothing.html","id":"effect-of-smoothing-parameter","dir":"Articles","previous_headings":"Method 1: P-spline Smoothing","what":"Effect of Smoothing Parameter","title":"Introduction to Smoothing Functional Data","text":"","code":"# Different smoothing levels fd_less <- pspline(fd_noisy, lambda = 0.001)   # Less smoothing fd_more <- pspline(fd_noisy, lambda = 100)     # More smoothing  idx <- 1 df_lambda <- rbind(   data.frame(age = age, height = fd_noisy$data[idx, ], type = \"data\",              lambda = \"lambda = 0.001\"),   data.frame(age = age, height = fd_less$fdata$data[idx, ], type = \"smooth\",              lambda = \"lambda = 0.001\"),   data.frame(age = age, height = fd_noisy$data[idx, ], type = \"data\",              lambda = \"Optimal (GCV)\"),   data.frame(age = age, height = fd_pspline$fdata$data[idx, ], type = \"smooth\",              lambda = \"Optimal (GCV)\"),   data.frame(age = age, height = fd_noisy$data[idx, ], type = \"data\",              lambda = \"lambda = 100\"),   data.frame(age = age, height = fd_more$fdata$data[idx, ], type = \"smooth\",              lambda = \"lambda = 100\") ) df_lambda$lambda <- factor(df_lambda$lambda,                             levels = c(\"lambda = 0.001\", \"Optimal (GCV)\", \"lambda = 100\"))  ggplot(df_lambda, aes(x = age, y = height)) +   geom_point(data = subset(df_lambda, type == \"data\"), color = \"gray60\", size = 1) +   geom_line(data = subset(df_lambda, type == \"smooth\"), color = \"blue\", linewidth = 1) +   facet_wrap(~ lambda) +   labs(x = \"Age (years)\", y = \"Height (cm)\",        title = \"Effect of Smoothing Parameter\") +   theme_minimal()"},{"path":"https://sipemu.github.io/fdars-r/articles/intro-to-smoothing.html","id":"method-2-kernel-smoothers","dir":"Articles","previous_headings":"","what":"Method 2: Kernel Smoothers","title":"Introduction to Smoothing Functional Data","text":"Kernel smoothers estimate value point using weighted average nearby observations. bandwidth hh controls neighborhood size.","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/intro-to-smoothing.html","id":"nadaraya-watson-smoother","dir":"Articles","previous_headings":"Method 2: Kernel Smoothers","what":"Nadaraya-Watson Smoother","title":"Introduction to Smoothing Functional Data","text":"","code":"# Compute smoother matrix with Nadaraya-Watson # S.NW takes evaluation points (tt) as first argument h <- h.default(fd_noisy)  # Default bandwidth based on data  S_nw <- S.NW(tt = age, h = h)  # Apply smoother to each curve fd_kernel <- fd_noisy for (i in 1:nrow(fd_kernel$data)) {   fd_kernel$data[i, ] <- as.vector(S_nw %*% fd_noisy$data[i, ]) }"},{"path":"https://sipemu.github.io/fdars-r/articles/intro-to-smoothing.html","id":"local-linear-regression","dir":"Articles","previous_headings":"Method 2: Kernel Smoothers","what":"Local Linear Regression","title":"Introduction to Smoothing Functional Data","text":"Local linear regression often performs better boundaries:","code":"S_llr <- S.LLR(tt = age, h = h) fd_llr <- fd_noisy for (i in 1:nrow(fd_llr$data)) {   fd_llr$data[i, ] <- as.vector(S_llr %*% fd_noisy$data[i, ]) }"},{"path":"https://sipemu.github.io/fdars-r/articles/intro-to-smoothing.html","id":"comparing-kernel-methods","dir":"Articles","previous_headings":"Method 2: Kernel Smoothers","what":"Comparing Kernel Methods","title":"Introduction to Smoothing Functional Data","text":"","code":"idx <- 1 df_kernels <- data.frame(   age = rep(age, 4),   height = c(fd_noisy$data[idx, ], fd_kernel$data[idx, ],              fd_llr$data[idx, ], fd_raw$data[idx, ]),   type = factor(rep(c(\"Data\", \"Nadaraya-Watson\", \"Local Linear\", \"Original\"),                     each = length(age)),                 levels = c(\"Data\", \"Nadaraya-Watson\", \"Local Linear\", \"Original\")) )  ggplot(df_kernels, aes(x = age, y = height, color = type, linetype = type)) +   geom_point(data = subset(df_kernels, type == \"Data\"), size = 1) +   geom_line(data = subset(df_kernels, type != \"Data\"), linewidth = 1) +   scale_color_manual(values = c(\"Data\" = \"gray60\", \"Nadaraya-Watson\" = \"blue\",                                  \"Local Linear\" = \"darkgreen\", \"Original\" = \"red\")) +   scale_linetype_manual(values = c(\"Data\" = \"blank\", \"Nadaraya-Watson\" = \"solid\",                                     \"Local Linear\" = \"solid\", \"Original\" = \"dashed\")) +   labs(x = \"Age (years)\", y = \"Height (cm)\",        title = \"Kernel Smoother Comparison\", color = NULL, linetype = NULL) +   theme_minimal() +   theme(legend.position = \"bottom\")"},{"path":"https://sipemu.github.io/fdars-r/articles/intro-to-smoothing.html","id":"bandwidth-selection","dir":"Articles","previous_headings":"Method 2: Kernel Smoothers","what":"Bandwidth Selection","title":"Introduction to Smoothing Functional Data","text":"default bandwidth h.default() based data:","code":"cat(\"Default bandwidth:\", h, \"\\n\") #> Default bandwidth: 1.5 cat(\"This is computed as the 15th percentile of pairwise distances.\\n\") #> This is computed as the 15th percentile of pairwise distances."},{"path":"https://sipemu.github.io/fdars-r/articles/intro-to-smoothing.html","id":"method-3-basis-expansion","dir":"Articles","previous_headings":"","what":"Method 3: Basis Expansion","title":"Introduction to Smoothing Functional Data","text":"Represent curves linear combinations basis functions. provides dimensionality reduction along smoothing.","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/intro-to-smoothing.html","id":"b-spline-basis","dir":"Articles","previous_headings":"Method 3: Basis Expansion","what":"B-spline Basis","title":"Introduction to Smoothing Functional Data","text":"","code":"# Project to B-spline basis coefs <- fdata2basis(fd_noisy, nbasis = 12, type = \"bspline\") fd_basis <- basis2fdata(coefs, argvals = age, type = \"bspline\")  # Compare idx <- 1 df_bspline <- data.frame(   age = rep(age, 3),   height = c(fd_noisy$data[idx, ], fd_basis$data[idx, ], fd_raw$data[idx, ]),   type = factor(rep(c(\"Data\", \"B-spline\", \"Original\"), each = length(age)),                 levels = c(\"Data\", \"B-spline\", \"Original\")) )  ggplot(df_bspline, aes(x = age, y = height, color = type, linetype = type)) +   geom_point(data = subset(df_bspline, type == \"Data\"), size = 1) +   geom_line(data = subset(df_bspline, type != \"Data\"), linewidth = 1) +   scale_color_manual(values = c(\"Data\" = \"gray60\", \"B-spline\" = \"purple\",                                  \"Original\" = \"red\")) +   scale_linetype_manual(values = c(\"Data\" = \"blank\", \"B-spline\" = \"solid\",                                     \"Original\" = \"dashed\")) +   labs(x = \"Age (years)\", y = \"Height (cm)\", title = \"B-spline Basis (K=12)\",        color = NULL, linetype = NULL) +   theme_minimal() +   theme(legend.position = \"bottom\")"},{"path":"https://sipemu.github.io/fdars-r/articles/intro-to-smoothing.html","id":"automatic-basis-selection","dir":"Articles","previous_headings":"Method 3: Basis Expansion","what":"Automatic Basis Selection","title":"Introduction to Smoothing Functional Data","text":"many basis functions? Cross-validation finds optimal number:","code":"# Cross-validation for optimal number of basis functions cv_basis <- fdata2basis_cv(fd_noisy, type = \"bspline\",                            nbasis.range = 5:20) print(cv_basis) #> Basis Cross-Validation Results #> ============================== #> Criterion: GCV  #> Optimal nbasis: 11  #> Score at optimal: 5.906161  #> Range tested: 5 - 20 plot(cv_basis)"},{"path":"https://sipemu.github.io/fdars-r/articles/intro-to-smoothing.html","id":"information-criteria","dir":"Articles","previous_headings":"Method 3: Basis Expansion","what":"Information Criteria","title":"Introduction to Smoothing Functional Data","text":"fdata2basis_cv function supports different criteria: - GCV (default): Generalized Cross-Validation - CV: Leave-one-Cross-Validation - AIC: Akaike Information Criterion - BIC: Bayesian Information Criterion","code":"# Get optimal basis from our CV result optimal_nbasis <- cv_basis$optimal.nbasis cat(\"Optimal number of basis functions (GCV):\", optimal_nbasis, \"\\n\") #> Optimal number of basis functions (GCV): 11"},{"path":"https://sipemu.github.io/fdars-r/articles/intro-to-smoothing.html","id":"comparing-all-methods","dir":"Articles","previous_headings":"","what":"Comparing All Methods","title":"Introduction to Smoothing Functional Data","text":"","code":"idx <- 3  # Pick a different curve  # Get smoothed versions smooth_pspline <- fd_pspline$fdata$data[idx, ] smooth_kernel <- fd_llr$data[idx, ]  # Use optimal basis from CV coefs_opt <- fdata2basis(fd_noisy, nbasis = optimal_nbasis, type = \"bspline\") smooth_basis <- basis2fdata(coefs_opt, argvals = age, type = \"bspline\")$data[idx, ]  # Create data frame for plotting df_all <- data.frame(   age = rep(age, 5),   height = c(fd_noisy$data[idx, ], smooth_pspline, smooth_kernel,              smooth_basis, fd_raw$data[idx, ]),   method = factor(rep(c(\"Noisy data\", \"P-spline\", \"Local Linear\",                         \"B-spline basis\", \"Original\"), each = length(age)),                   levels = c(\"Noisy data\", \"P-spline\", \"Local Linear\",                              \"B-spline basis\", \"Original\")) )  ggplot(df_all, aes(x = age, y = height, color = method, linetype = method)) +   geom_point(data = subset(df_all, method == \"Noisy data\"), size = 1) +   geom_line(data = subset(df_all, method != \"Noisy data\"), linewidth = 1) +   scale_color_manual(values = c(\"Noisy data\" = \"gray60\", \"P-spline\" = \"blue\",                                  \"Local Linear\" = \"darkgreen\", \"B-spline basis\" = \"purple\",                                  \"Original\" = \"red\")) +   scale_linetype_manual(values = c(\"Noisy data\" = \"blank\", \"P-spline\" = \"solid\",                                     \"Local Linear\" = \"solid\", \"B-spline basis\" = \"solid\",                                     \"Original\" = \"dashed\")) +   labs(x = \"Age (years)\", y = \"Height (cm)\",        title = \"Smoothing Method Comparison\", color = NULL, linetype = NULL) +   theme_minimal() +   theme(legend.position = \"bottom\")"},{"path":"https://sipemu.github.io/fdars-r/articles/intro-to-smoothing.html","id":"mean-and-variability","dir":"Articles","previous_headings":"","what":"Mean and Variability","title":"Introduction to Smoothing Functional Data","text":"smoothing, compute summary statistics:","code":"# Use P-spline smoothed data fd_smooth <- fd_pspline$fdata  # Mean curve mean_curve <- mean(fd_smooth)  # Standard deviation at each point sd_curve <- sd(fd_smooth)  # Create data frame for plotting df_mean <- data.frame(   age = age,   mean = mean_curve$data[1, ],   lower = mean_curve$data[1, ] - 2 * sd_curve$data[1, ],   upper = mean_curve$data[1, ] + 2 * sd_curve$data[1, ] )  ggplot(df_mean, aes(x = age)) +   geom_ribbon(aes(ymin = lower, ymax = upper), fill = \"blue\", alpha = 0.2) +   geom_line(aes(y = mean), color = \"blue\", linewidth = 1.2) +   labs(x = \"Age (years)\", y = \"Height (cm)\",        title = \"Mean Growth Curve with Variability Band\",        subtitle = \"Shaded region: Mean +/- 2 SD\") +   theme_minimal()"},{"path":"https://sipemu.github.io/fdars-r/articles/intro-to-smoothing.html","id":"summary-when-to-use-each-method","dir":"Articles","previous_headings":"","what":"Summary: When to Use Each Method","title":"Introduction to Smoothing Functional Data","text":"Recommendations: Start P-splines - automatic λ\\lambda selection works well cases Use basis expansion need derivatives (smoother derivatives) Use kernel smoothers highly irregular sampling adaptive smoothing","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/intro-to-smoothing.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Introduction to Smoothing Functional Data","text":"Ramsay, J.O. Silverman, B.W. (2005). Functional Data Analysis. Springer. Eilers, P.H.C. Marx, B.D. (1996). Flexible Smoothing B-splines Penalties. Statistical Science, 11(2), 89-121. Fan, J. Gijbels, . (1996). Local Polynomial Modelling Applications. Chapman Hall.","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/introduction.html","id":"what-is-functional-data-analysis","dir":"Articles","previous_headings":"","what":"What is Functional Data Analysis?","title":"Introduction to fdars","text":"Functional Data Analysis (FDA) branch statistics deals data observation function, curve, surface rather single number vector. Examples include: - Temperature curves recorded day - Growth curves children time - Spectrometric measurements across wavelengths - Stock prices throughout trading hours FDA, treat curve single observation develop methods analyze collections curves.","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/introduction.html","id":"the-fdars-package","dir":"Articles","previous_headings":"","what":"The fdars Package","title":"Introduction to fdars","text":"fdars (Functional Data Analysis Rust) provides comprehensive toolkit FDA high-performance Rust backend. Key features include: Fast computation: 10-200x speedups pure R implementations Comprehensive methods: Depth functions, regression, clustering, outlier detection Flexible metrics: Multiple distance measures including DTW 2D support: Analysis surfaces addition curves","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/introduction.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"Introduction to fdars","text":"","code":"# Install from GitHub remotes::install_github(\"sipemu/fdars\")"},{"path":"https://sipemu.github.io/fdars-r/articles/introduction.html","id":"getting-started","dir":"Articles","previous_headings":"","what":"Getting Started","title":"Introduction to fdars","text":"","code":"library(fdars) #>  #> Attaching package: 'fdars' #> The following objects are masked from 'package:stats': #>  #>     cov, decompose, deriv, median, sd, var #> The following object is masked from 'package:base': #>  #>     norm library(ggplot2) theme_set(theme_minimal())"},{"path":"https://sipemu.github.io/fdars-r/articles/introduction.html","id":"creating-functional-data","dir":"Articles","previous_headings":"Getting Started","what":"Creating Functional Data","title":"Introduction to fdars","text":"core data structure fdata class. Create functional data matrix rows observations (curves) columns evaluation points:","code":"# Generate example data: 20 curves evaluated at 100 points set.seed(42) n <- 20 m <- 100 t_grid <- seq(0, 1, length.out = m)  # Create curves: sine waves with random phase and noise X <- matrix(0, n, m) for (i in 1:n) {   phase <- runif(1, 0, pi)   X[i, ] <- sin(2 * pi * t_grid + phase) + rnorm(m, sd = 0.1) }  # Create fdata object fd <- fdata(X, argvals = t_grid) fd #> Functional data object #>   Type: 1D (curve)  #>   Number of observations: 20  #>   Number of points: 100  #>   Range: 0 - 1"},{"path":"https://sipemu.github.io/fdars-r/articles/introduction.html","id":"adding-identifiers-and-metadata","dir":"Articles","previous_headings":"Getting Started","what":"Adding Identifiers and Metadata","title":"Introduction to fdars","text":"can attach identifiers metadata (covariates) functional data: Metadata preserved subsetting:","code":"# Create metadata with covariates meta <- data.frame(   group = factor(rep(c(\"control\", \"treatment\"), each = 10)),   age = sample(20:60, n, replace = TRUE),   response = rnorm(n) )  # Create fdata with IDs and metadata fd_meta <- fdata(X, argvals = t_grid,                  id = paste0(\"patient_\", 1:n),                  metadata = meta) fd_meta #> Functional data object #>   Type: 1D (curve)  #>   Number of observations: 20  #>   Number of points: 100  #>   Range: 0 - 1  #>   Metadata columns: group, age, response  # Access metadata fd_meta$id[1:5] #> [1] \"patient_1\" \"patient_2\" \"patient_3\" \"patient_4\" \"patient_5\" head(fd_meta$metadata) #>     group age   response #> 1 control  54  0.3533851 #> 2 control  43 -0.2975149 #> 3 control  55  0.5553262 #> 4 control  56 -0.3193581 #> 5 control  28 -0.7752047 #> 6 control  38  0.4711363 fd_sub <- fd_meta[1:5, ] fd_sub$id #> [1] \"patient_1\" \"patient_2\" \"patient_3\" \"patient_4\" \"patient_5\" fd_sub$metadata #>     group age   response #> 1 control  54  0.3533851 #> 2 control  43 -0.2975149 #> 3 control  55  0.5553262 #> 4 control  56 -0.3193581 #> 5 control  28 -0.7752047"},{"path":"https://sipemu.github.io/fdars-r/articles/introduction.html","id":"visualizing-functional-data","dir":"Articles","previous_headings":"Getting Started","what":"Visualizing Functional Data","title":"Introduction to fdars","text":"","code":"plot(fd)"},{"path":"https://sipemu.github.io/fdars-r/articles/introduction.html","id":"basic-operations","dir":"Articles","previous_headings":"Getting Started","what":"Basic Operations","title":"Introduction to fdars","text":"","code":"# Compute mean function mean_curve <- mean(fd)  # Center the data fd_centered <- fdata.cen(fd)  # Compute functional variance variance <- var(fd)"},{"path":"https://sipemu.github.io/fdars-r/articles/introduction.html","id":"subsetting","dir":"Articles","previous_headings":"Getting Started","what":"Subsetting","title":"Introduction to fdars","text":"Select specific curves evaluation points:","code":"# First 5 curves fd_subset <- fd[1:5, ]  # Specific range of t values fd_range <- fd[, t_grid >= 0.25 & t_grid <= 0.75]"},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/articles/introduction.html","id":"depth-functions","dir":"Articles","previous_headings":"Key Functionality Overview","what":"Depth Functions","title":"Introduction to fdars","text":"Depth measures “central” curve within sample. Higher depth indicates typical curve:","code":"# Fraiman-Muniz depth depths <- depth(fd, method = \"FM\") head(depths) #> [1] 0.411 0.703 0.604 0.558 0.725 0.309  # Find the median curve (deepest) median_curve <- median(fd, method = \"FM\")"},{"path":"https://sipemu.github.io/fdars-r/articles/introduction.html","id":"distance-metrics","dir":"Articles","previous_headings":"Key Functionality Overview","what":"Distance Metrics","title":"Introduction to fdars","text":"Compute distances curves using various metrics:","code":"# L2 (Euclidean) distance dist_l2 <- metric.lp(fd)  # Dynamic Time Warping dist_dtw <- metric.DTW(fd)"},{"path":"https://sipemu.github.io/fdars-r/articles/introduction.html","id":"regression","dir":"Articles","previous_headings":"Key Functionality Overview","what":"Regression","title":"Introduction to fdars","text":"Predict scalar response functional predictors:","code":"# Generate response y <- rowMeans(X) + rnorm(n, sd = 0.1)  # Principal component regression fit_pc <- fregre.pc(fd, y, ncomp = 3) print(fit_pc) #> Functional regression model #>   Number of observations: 20  #>   R-squared: 0.1146712"},{"path":"https://sipemu.github.io/fdars-r/articles/introduction.html","id":"clustering","dir":"Articles","previous_headings":"Key Functionality Overview","what":"Clustering","title":"Introduction to fdars","text":"Group curves clusters:","code":"# K-means clustering km <- cluster.kmeans(fd, ncl = 2, seed = 123) plot(km)"},{"path":"https://sipemu.github.io/fdars-r/articles/introduction.html","id":"outlier-detection","dir":"Articles","previous_headings":"Key Functionality Overview","what":"Outlier Detection","title":"Introduction to fdars","text":"Identify atypical curves:","code":"# Add an outlier X_out <- rbind(X, X[1, ] + 3) fd_out <- fdata(X_out, argvals = t_grid)  # Detect outliers out <- outliers.depth.pond(fd_out) plot(out)"},{"path":"https://sipemu.github.io/fdars-r/articles/introduction.html","id":"next-steps","dir":"Articles","previous_headings":"","what":"Next Steps","title":"Introduction to fdars","text":"Explore vignettes detailed coverage specific topics: Covariance Functions: Generate Gaussian process samples various kernels Depth Functions: Comprehensive guide functional depth measures Distance Metrics: Distance semimetric functions Regression: Functional regression methods Clustering: Functional k-means optimal k selection Outlier Detection: Methods identifying atypical curves","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/introduction.html","id":"performance","dir":"Articles","previous_headings":"","what":"Performance","title":"Introduction to fdars","text":"Rust backend provides significant speedups computationally intensive operations. example, computing depth 1000 curves:","code":"# Generate large dataset X_large <- matrix(rnorm(1000 * 200), 1000, 200) fd_large <- fdata(X_large)  # Depth computation is fast even for large datasets system.time(depth(fd_large, method = \"FM\")) #>    user  system elapsed #>   0.045   0.000   0.045"},{"path":"https://sipemu.github.io/fdars-r/articles/introduction.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Introduction to fdars","text":"Ramsay, J.O. Silverman, B.W. (2005). Functional Data Analysis. Springer. Ferraty, F. Vieu, P. (2006). Nonparametric Functional Data Analysis. Springer. Febrero-Bande, M. Oviedo de la Fuente, M. (2012). Statistical Computing Functional Data Analysis: R Package fda.usc. Journal Statistical Software, 51(4), 1-28.","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/irregular-sampling.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Working with Irregular Functional Data","text":"Many real-world functional data irregularly sampled, meaning: Different curves observed different time points Observations may sparse (points per curve) Sampling density may vary within across curves fdars package provides irregFdata class handle data naturally, avoiding need imputation interpolation analysis.","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/irregular-sampling.html","id":"common-applications","dir":"Articles","previous_headings":"Introduction","what":"Common Applications","title":"Working with Irregular Functional Data","text":"Longitudinal studies: Patients visited different times Sensor data: Measurements gaps varying frequency Environmental monitoring: Non-uniform temporal sampling Financial data: Trades occurring irregular intervals","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/articles/irregular-sampling.html","id":"creating-irregfdata-objects","dir":"Articles","previous_headings":"The irregFdata Class","what":"Creating irregFdata Objects","title":"Working with Irregular Functional Data","text":"irregFdata object stores observation times values lists:","code":"# Three curves with different observation points argvals <- list(   c(0.0, 0.3, 0.7, 1.0),       # 4 points   c(0.0, 0.2, 0.4, 0.6, 0.8, 1.0),  # 6 points   c(0.1, 0.5, 0.9)              # 3 points )  X <- list(   c(0.1, 0.5, 0.3, 0.2),   c(0.0, 0.4, 0.8, 0.6, 0.4, 0.1),   c(0.3, 0.7, 0.2) )  ifd <- irregFdata(argvals, X) print(ifd) #> Irregular Functional Data Object #> ================================= #>   Number of observations: 3  #>   Points per curve: #>     Min: 3  #>     Median: 4  #>     Max: 6  #>     Total: 13  #>   Domain: [ 0 , 1 ]"},{"path":"https://sipemu.github.io/fdars-r/articles/irregular-sampling.html","id":"structure","dir":"Articles","previous_headings":"The irregFdata Class","what":"Structure","title":"Working with Irregular Functional Data","text":"","code":"# Number of observations ifd$n #> [1] 3  # Observation counts per curve sapply(ifd$X, length) #> [1] 4 6 3  # Domain range ifd$rangeval #> [1] 0 1"},{"path":"https://sipemu.github.io/fdars-r/articles/irregular-sampling.html","id":"checking-data-type","dir":"Articles","previous_headings":"The irregFdata Class","what":"Checking Data Type","title":"Working with Irregular Functional Data","text":"","code":"# Regular fdata fd_regular <- fdata(matrix(rnorm(100), 10, 10)) is.irregular(fd_regular) #> [1] FALSE  # Irregular fdata is.irregular(ifd) #> [1] TRUE"},{"path":"https://sipemu.github.io/fdars-r/articles/irregular-sampling.html","id":"sparsifying-regular-data","dir":"Articles","previous_headings":"","what":"Sparsifying Regular Data","title":"Working with Irregular Functional Data","text":"Use sparsify() convert regular fdata irregFdata:","code":"# Start with regular data t <- seq(0, 1, length.out = 100) fd <- simFunData(n = 10, argvals = t, M = 5, seed = 42)  # Create sparse version with 15-30 observations per curve ifd <- sparsify(fd, minObs = 15, maxObs = 30, seed = 123) print(ifd) #> Irregular Functional Data Object #> ================================= #>   Number of observations: 10  #>   Points per curve: #>     Min: 16  #>     Median: 26.5  #>     Max: 30  #>     Total: 243  #>   Domain: [ 0 , 1 ]"},{"path":"https://sipemu.github.io/fdars-r/articles/irregular-sampling.html","id":"visualizing-sparse-data","dir":"Articles","previous_headings":"Sparsifying Regular Data","what":"Visualizing Sparse Data","title":"Working with Irregular Functional Data","text":"","code":"autoplot(ifd) +   labs(title = \"Sparsified Functional Data\")"},{"path":"https://sipemu.github.io/fdars-r/articles/irregular-sampling.html","id":"non-uniform-sparsification","dir":"Articles","previous_headings":"Sparsifying Regular Data","what":"Non-Uniform Sparsification","title":"Working with Irregular Functional Data","text":"Control sampling density probability function:","code":"# More observations in the middle prob_middle <- function(t) dnorm(t, mean = 0.5, sd = 0.2)  # More observations at the edges (U-shaped probability) prob_edges <- function(t) 0.1 + 4 * (t - 0.5)^2  fd <- simFunData(n = 20, argvals = t, M = 5, seed = 42)  ifd_uniform <- sparsify(fd, minObs = 15, maxObs = 25, seed = 123) ifd_middle <- sparsify(fd, minObs = 15, maxObs = 25, prob = prob_middle, seed = 123) ifd_edges <- sparsify(fd, minObs = 15, maxObs = 25, prob = prob_edges, seed = 123)  p1 <- autoplot(ifd_uniform) + labs(title = \"Uniform Sampling\") p2 <- autoplot(ifd_middle) + labs(title = \"Dense in Middle\") p3 <- autoplot(ifd_edges) + labs(title = \"Dense at Edges\") gridExtra::grid.arrange(p1, p2, p3, ncol = 1)"},{"path":"https://sipemu.github.io/fdars-r/articles/irregular-sampling.html","id":"converting-to-regular-grid","dir":"Articles","previous_headings":"","what":"Converting to Regular Grid","title":"Working with Irregular Functional Data","text":"Use .fdata() convert back regular fdata:","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/irregular-sampling.html","id":"method-na-fill","dir":"Articles","previous_headings":"Converting to Regular Grid","what":"Method: NA Fill","title":"Working with Irregular Functional Data","text":"exact matches filled; points get NA:","code":"ifd <- sparsify(fd[1:3], minObs = 10, maxObs = 20, seed = 123)  fd_na <- as.fdata(ifd, method = \"na\")  # Show some data with NAs fd_na$data[1, 1:20] #>  [1]         NA  1.7304109         NA  2.0573334         NA         NA #>  [7]  1.2834072         NA         NA         NA         NA         NA #> [13]         NA -1.1737028 -1.2287149 -1.2131357         NA -0.7393675 #> [19]         NA         NA"},{"path":"https://sipemu.github.io/fdars-r/articles/irregular-sampling.html","id":"method-linear-interpolation","dir":"Articles","previous_headings":"Converting to Regular Grid","what":"Method: Linear Interpolation","title":"Working with Irregular Functional Data","text":"Interpolate observed points:","code":"# Specify target grid target_grid <- seq(0, 1, length.out = 50) fd_interp <- as.fdata(ifd, argvals = target_grid, method = \"linear\")  # No NAs within observed range sum(is.na(fd_interp$data)) #> [1] 19 p1 <- autoplot(ifd[1]) + labs(title = \"Original Sparse Data (1 curve)\") p2 <- autoplot(fd_interp[1]) + labs(title = \"After Linear Interpolation\") gridExtra::grid.arrange(p1, p2, ncol = 2) #> Warning: Removed 4 rows containing missing values or values outside the scale range #> (`geom_line()`)."},{"path":"https://sipemu.github.io/fdars-r/articles/irregular-sampling.html","id":"basis-representation-for-sparse-data","dir":"Articles","previous_headings":"","what":"Basis Representation for Sparse Data","title":"Working with Irregular Functional Data","text":"Basis representation powerful approach handling irregular/sparse functional data: Smooth noisy observations Reduce dimensionality (many observation points coefficients) Regularize curves downstream analysis (FPCA, regression, clustering) Convert irregular data regular representation comprehensive coverage basis functions, see vignette(\"basis-representation\").","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/irregular-sampling.html","id":"direct-basis-fitting-recommended","dir":"Articles","previous_headings":"Basis Representation for Sparse Data","what":"Direct Basis Fitting (Recommended)","title":"Working with Irregular Functional Data","text":"preferred approach irregular data fit basis functions directly curve’s observation points using least squares. avoids interpolation artifacts handles varying observation densities naturally.  approach works B-spline Fourier bases:","code":"# Create sparse/irregular data t <- seq(0, 1, length.out = 100) fd_sim <- simFunData(n = 10, argvals = t, M = 5, seed = 42) ifd <- sparsify(fd_sim, minObs = 15, maxObs = 30, seed = 123)  # Fit basis directly to irregular data (no interpolation needed!) coefs <- fdata2basis(ifd, nbasis = 10, type = \"bspline\")  # Reconstruct on any target grid fd_smooth <- basis2fdata(coefs, argvals = t, type = \"bspline\")  # Compare sparse observations vs smooth reconstruction p1 <- autoplot(ifd[1:3], alpha = 0.8) +   labs(title = \"Sparse Observations (3 curves)\") p2 <- autoplot(fd_smooth[1:3], alpha = 0.8) +   labs(title = \"Basis Reconstruction\") gridExtra::grid.arrange(p1, p2, ncol = 2) # Fourier basis for periodic patterns coefs_fourier <- fdata2basis(ifd, nbasis = 9, type = \"fourier\") fd_fourier <- basis2fdata(coefs_fourier, argvals = t, type = \"fourier\")  autoplot(fd_fourier[1:5], alpha = 0.8) +   labs(title = \"Fourier Basis Reconstruction (9 basis)\")"},{"path":"https://sipemu.github.io/fdars-r/articles/irregular-sampling.html","id":"comparing-approaches-direct-vs-interpolate-then-fit","dir":"Articles","previous_headings":"Basis Representation for Sparse Data","what":"Comparing Approaches: Direct vs Interpolate-Then-Fit","title":"Working with Irregular Functional Data","text":"Let’s compare two approaches. key advantage direct fitting works even observations don’t cover full domain:  Key observations: Direct fitting fits basis functions directly sparse observations using least squares, can extrapolate beyond observed range Interpolate--fit requires observations domain boundaries; gaps produce NAs data good coverage domain, approaches give similar results Direct fitting safer choice truly sparse irregularly sampled data","code":"# Create sparse data with known ground truth t <- seq(0, 1, length.out = 100) fd_true <- simFunData(n = 5, argvals = t, M = 5, seed = 42) ifd <- sparsify(fd_true, minObs = 15, maxObs = 25, seed = 456)  # Show observation coverage cat(\"Observation ranges per curve:\\n\") #> Observation ranges per curve: for (i in 1:5) {   r <- range(ifd$argvals[[i]])   cat(sprintf(\"  Curve %d: [%.2f, %.2f] (%d observations)\\n\",               i, r[1], r[2], length(ifd$argvals[[i]]))) } #>   Curve 1: [0.07, 0.90] (19 observations) #>   Curve 2: [0.03, 1.00] (23 observations) #>   Curve 3: [0.03, 0.99] (21 observations) #>   Curve 4: [0.04, 0.90] (25 observations) #>   Curve 5: [0.00, 1.00] (22 observations)  # APPROACH 1: Direct basis fitting - works on full domain coefs_direct <- fdata2basis(ifd, nbasis = 12, type = \"bspline\") fd_direct <- basis2fdata(coefs_direct, argvals = t, type = \"bspline\")  # APPROACH 2: Interpolate first - only works within observed range fd_interp <- as.fdata(ifd, argvals = t, method = \"linear\") cat(\"\\nNAs in interpolated data:\", sum(is.na(fd_interp$data)),     \"(outside observation range)\\n\") #>  #> NAs in interpolated data: 38 (outside observation range) # Visualize for one curve - showing the extrapolation advantage curve_idx <- 1 obs_t <- ifd$argvals[[curve_idx]] obs_y <- ifd$X[[curve_idx]]  compare_df <- rbind(   data.frame(t = t, y = fd_true$data[curve_idx, ], method = \"Ground Truth\"),   data.frame(t = t, y = fd_direct$data[curve_idx, ], method = \"Direct Fitting\") )  ggplot() +   geom_line(data = compare_df, aes(x = t, y = y, color = method, linetype = method),             linewidth = 0.8, inherit.aes = FALSE) +   geom_point(data = data.frame(t = obs_t, y = obs_y),              aes(x = t, y = y), size = 2, alpha = 0.8, inherit.aes = FALSE) +   geom_vline(xintercept = range(obs_t), linetype = \"dashed\", alpha = 0.3) +   scale_color_manual(values = c(\"Ground Truth\" = \"black\", \"Direct Fitting\" = \"blue\")) +   scale_linetype_manual(values = c(\"Ground Truth\" = \"solid\", \"Direct Fitting\" = \"dashed\")) +   labs(title = \"Direct Basis Fitting Works Across Full Domain\",        subtitle = \"Vertical lines show observation range; direct fitting extrapolates naturally\",        x = \"t\", y = \"Value\", color = NULL, linetype = NULL) +   theme_minimal()"},{"path":"https://sipemu.github.io/fdars-r/articles/irregular-sampling.html","id":"alternative-interpolate-then-fit","dir":"Articles","previous_headings":"Basis Representation for Sparse Data","what":"Alternative: Interpolate Then Fit","title":"Working with Irregular Functional Data","text":"regular data (converting irregular regular), can use basis projection:","code":"# Simulate regular functional data set.seed(123) fd_sim <- simFunData(n = 15, argvals = seq(0, 1, length.out = 100), M = 5, seed = 42)  # Add noise to simulate measurement error fd_noisy <- fd_sim fd_noisy$data <- fd_noisy$data + matrix(rnorm(length(fd_noisy$data), sd = 0.3),                                          nrow = nrow(fd_noisy$data))  # Project onto B-spline basis (smooths the curves) coefs <- fdata2basis(fd_noisy, nbasis = 12, type = \"bspline\") fd_basis <- basis2fdata(coefs, argvals = fd_noisy$argvals)  # Compare using ggplot2 p1 <- autoplot(fd_noisy, alpha = 0.7) + labs(title = \"Noisy Data\") p2 <- autoplot(fd_basis, alpha = 0.7) + labs(title = \"B-spline Smoothed (12 basis)\") gridExtra::grid.arrange(p1, p2, ncol = 2)"},{"path":"https://sipemu.github.io/fdars-r/articles/irregular-sampling.html","id":"p-spline-smoothing","dir":"Articles","previous_headings":"Basis Representation for Sparse Data","what":"P-spline Smoothing","title":"Working with Irregular Functional Data","text":"P-splines automatic smoothing parameter selection provide robust results noisy data:","code":"# Create noisy data for P-spline demo set.seed(456) fd_for_pspline <- simFunData(n = 15, argvals = seq(0, 1, length.out = 100), M = 5, seed = 42) fd_for_pspline$data <- fd_for_pspline$data + matrix(rnorm(length(fd_for_pspline$data), sd = 0.3),                                                       nrow = nrow(fd_for_pspline$data))  # P-spline with fixed lambda (automatic selection can be unstable for some data) pspline_result <- pspline(fd_for_pspline, nbasis = 20, lambda = 0.01)  # Compare (pspline returns a list; extract $fdata for the smoothed curves) p1 <- autoplot(fd_for_pspline, alpha = 0.7) + labs(title = \"Noisy Data\") p2 <- autoplot(pspline_result$fdata, alpha = 0.7) + labs(title = \"P-spline Smoothed\") gridExtra::grid.arrange(p1, p2, ncol = 2)"},{"path":"https://sipemu.github.io/fdars-r/articles/irregular-sampling.html","id":"choosing-the-right-approach","dir":"Articles","previous_headings":"Basis Representation for Sparse Data","what":"Choosing the Right Approach","title":"Working with Irregular Functional Data","text":"Tip: Use fdata2basis_cv() automatically select optimal number basis functions via cross-validation.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/articles/irregular-sampling.html","id":"integration","dir":"Articles","previous_headings":"Operations on Irregular Data","what":"Integration","title":"Working with Irregular Functional Data","text":"Compute integrals using trapezoidal rule:","code":"# Create data with known integral argvals <- list(   seq(0, 1, length.out = 50),   seq(0, 1, length.out = 30) ) # Constant function = 1 should integrate to 1 X <- list(rep(1, 50), rep(2, 30)) ifd <- irregFdata(argvals, X)  integrals <- int.simpson(ifd) print(integrals)  # Should be approximately 1 and 2 #> [1] 1 2"},{"path":"https://sipemu.github.io/fdars-r/articles/irregular-sampling.html","id":"lp-norms","dir":"Articles","previous_headings":"Operations on Irregular Data","what":"Lp Norms","title":"Working with Irregular Functional Data","text":"","code":"# L2 norm of constant function c is c norms <- norm(ifd, p = 2) print(norms) #> [1] 1 2"},{"path":"https://sipemu.github.io/fdars-r/articles/irregular-sampling.html","id":"mean-function-estimation","dir":"Articles","previous_headings":"Operations on Irregular Data","what":"Mean Function Estimation","title":"Working with Irregular Functional Data","text":"mean() function estimates mean irregular data. default method uses basis reconstruction, preserves functional structure:","code":"# Simulate many curves fd <- simFunData(n = 50, argvals = t, M = 5, seed = 42) ifd <- sparsify(fd, minObs = 15, maxObs = 30, seed = 123)  # Estimate mean (default: basis method) mean_fd <- mean(ifd) autoplot(mean_fd) + labs(title = \"Estimated Mean Function\") # Compare to true sample mean (from original data) true_mean <- colMeans(fd$data)  # Also try kernel method for comparison mean_kernel <- mean(ifd, method = \"kernel\", bandwidth = 0.1)  # Create comparison data frame compare_df <- rbind(   data.frame(t = t, value = true_mean, type = \"True Sample Mean\"),   data.frame(t = mean_fd$argvals, value = mean_fd$data[1,], type = \"Basis Method\"),   data.frame(t = mean_kernel$argvals, value = mean_kernel$data[1,], type = \"Kernel Method\") )  ggplot(compare_df, aes(x = t, y = value, color = type)) +   geom_line(linewidth = 1) +   scale_color_manual(values = c(\"True Sample Mean\" = \"black\",                                  \"Basis Method\" = \"blue\",                                  \"Kernel Method\" = \"red\")) +   labs(title = \"Mean Estimation: Basis vs Kernel\",        subtitle = \"Basis method (default) is more accurate\",        x = \"t\", y = \"Mean\", color = NULL) +   theme_minimal() # Compare accuracy rmse_basis <- sqrt(mean((mean_fd$data[1,] - true_mean)^2)) rmse_kernel <- sqrt(mean((mean_kernel$data[1,] - true_mean)^2)) cat(\"RMSE (Basis method):\", round(rmse_basis, 4), \"\\n\") #> RMSE (Basis method): 0.0263 cat(\"RMSE (Kernel method):\", round(rmse_kernel, 4), \"\\n\") #> RMSE (Kernel method): 0.1033"},{"path":"https://sipemu.github.io/fdars-r/articles/irregular-sampling.html","id":"distance-matrix","dir":"Articles","previous_headings":"Operations on Irregular Data","what":"Distance Matrix","title":"Working with Irregular Functional Data","text":"Compute pairwise Lp distances:","code":"ifd <- sparsify(fd[1:5], minObs = 20, maxObs = 40, seed = 123) D <- metric.lp(ifd, p = 2) round(D, 2) #>      [,1] [,2] [,3] [,4] [,5] #> [1,] 0.00 0.69 1.04 1.53 1.32 #> [2,] 0.69 0.00 1.42 1.76 1.57 #> [3,] 1.04 1.42 0.00 1.10 1.47 #> [4,] 1.53 1.76 1.10 0.00 1.04 #> [5,] 1.32 1.57 1.47 1.04 0.00"},{"path":"https://sipemu.github.io/fdars-r/articles/irregular-sampling.html","id":"subsetting","dir":"Articles","previous_headings":"","what":"Subsetting","title":"Working with Irregular Functional Data","text":"Extract specific observations:","code":"ifd <- sparsify(fd[1:10], minObs = 10, maxObs = 20, seed = 123)  # Single observation ifd_sub1 <- ifd[1] print(ifd_sub1) #> Irregular Functional Data Object #> ================================= #>   Number of observations: 1  #>   Points per curve: #>     Min: 12  #>     Median: 12  #>     Max: 12  #>     Total: 12  #>   Domain: [ 0 , 1 ]  # Multiple observations ifd_sub23 <- ifd[2:3] print(ifd_sub23) #> Irregular Functional Data Object #> ================================= #>   Number of observations: 2  #>   Points per curve: #>     Min: 12  #>     Median: 15.5  #>     Max: 19  #>     Total: 31  #>   Domain: [ 0 , 1 ]  # Negative indexing ifd_not1 <- ifd[-1] ifd_not1$n #> [1] 9"},{"path":"https://sipemu.github.io/fdars-r/articles/irregular-sampling.html","id":"metadata-support","dir":"Articles","previous_headings":"","what":"Metadata Support","title":"Working with Irregular Functional Data","text":"Store additional covariates data:","code":"argvals <- list(c(0, 0.5, 1), c(0, 1), c(0, 0.3, 0.7, 1)) X <- list(c(1, 2, 1), c(0, 2), c(1, 1.5, 1.5, 1)) meta <- data.frame(   group = c(\"treatment\", \"control\", \"treatment\"),   age = c(45, 52, 38) )  ifd <- irregFdata(argvals, X,                   id = c(\"patient_001\", \"patient_002\", \"patient_003\"),                   metadata = meta)  # Access metadata ifd$id #> [1] \"patient_001\" \"patient_002\" \"patient_003\" ifd$metadata #>       group age #> 1 treatment  45 #> 2   control  52 #> 3 treatment  38  # Subsetting preserves metadata ifd[1]$metadata #>       group age #> 1 treatment  45"},{"path":[]},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/articles/irregular-sampling.html","id":"memory-considerations","dir":"Articles","previous_headings":"Best Practices","what":"Memory Considerations","title":"Working with Irregular Functional Data","text":"irregFdata memory-efficient data sparse:","code":"# Regular: always stores n x m values n <- 100 m <- 1000 regular_size <- n * m * 8  # bytes (double)  # Irregular: stores only observed values avg_obs <- 50  # average observations per curve irreg_size <- n * avg_obs * 8 * 2  # values + argvals  cat(\"Regular (n=100, m=1000):\", regular_size / 1024, \"KB\\n\") #> Regular (n=100, m=1000): 781.25 KB cat(\"Irregular (n=100, ~50 obs each):\", irreg_size / 1024, \"KB\\n\") #> Irregular (n=100, ~50 obs each): 78.125 KB"},{"path":"https://sipemu.github.io/fdars-r/articles/irregular-sampling.html","id":"preprocessing-recommendations","dir":"Articles","previous_headings":"Best Practices","what":"Preprocessing Recommendations","title":"Working with Irregular Functional Data","text":"Quality control: Remove curves observations Domain alignment: Ensure curves span similar ranges Outlier removal: Check obviously erroneous values Bandwidth selection: Use cross-validation kernel smoothing","code":"# Remove curves with fewer than 5 observations min_obs <- 5 keep <- sapply(ifd$X, length) >= min_obs  if (any(!keep)) {   ifd_clean <- ifd[keep]   cat(\"Removed\", sum(!keep), \"curves with <\", min_obs, \"observations\\n\") } #> Removed 3 curves with < 5 observations"},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/articles/outlier-detection.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Outlier Detection","text":"Outlier detection functional data identifies curves atypical anomalous compared rest sample. fdars provides several methods based functional depth likelihood ratio tests.","code":"library(fdars) #>  #> Attaching package: 'fdars' #> The following objects are masked from 'package:stats': #>  #>     cov, decompose, deriv, median, sd, var #> The following object is masked from 'package:base': #>  #>     norm library(ggplot2) theme_set(theme_minimal())  # Generate normal data with low noise for clear signal set.seed(42) n <- 30 m <- 100 t_grid <- seq(0, 1, length.out = m)  X <- matrix(0, n, m) for (i in 1:n) {   X[i, ] <- sin(2 * pi * t_grid) + rnorm(m, sd = 0.1) }  # Add three distinct types of outliers X[1, ] <- sin(2 * pi * t_grid) + 3           # MAGNITUDE outlier (shifted up) X[2, ] <- -sin(2 * pi * t_grid)              # SHAPE outlier (inverted pattern) X[3, ] <- 3 * sin(2 * pi * t_grid)           # AMPLITUDE outlier (larger scale)  fd <- fdata(X, argvals = t_grid)  # Visualize with outliers highlighted df_curves <- data.frame(   t = rep(t_grid, n),   value = as.vector(t(X)),   curve = rep(1:n, each = m),   type = rep(c(\"Magnitude\", \"Shape\", \"Amplitude\", rep(\"Normal\", n - 3)), each = m) ) df_curves$type <- factor(df_curves$type, levels = c(\"Normal\", \"Magnitude\", \"Shape\", \"Amplitude\"))  ggplot(df_curves, aes(x = t, y = value, group = curve, color = type)) +   geom_line(alpha = 0.7) +   scale_color_manual(values = c(\"Normal\" = \"gray50\", \"Magnitude\" = \"red\",                                  \"Shape\" = \"blue\", \"Amplitude\" = \"green3\")) +   labs(title = \"Functional Data with Three Types of Outliers\",        x = \"t\", y = \"X(t)\", color = \"Type\") +   theme(legend.position = \"bottom\")"},{"path":"https://sipemu.github.io/fdars-r/articles/outlier-detection.html","id":"depth-based-methods","dir":"Articles","previous_headings":"","what":"Depth-Based Methods","title":"Outlier Detection","text":"Depth-based outlier detection identifies curves unusually low depth (far center data).","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/outlier-detection.html","id":"weighted-depth-method-outliers-depth-pond","dir":"Articles","previous_headings":"Depth-Based Methods","what":"Weighted Depth Method (outliers.depth.pond)","title":"Outlier Detection","text":"Uses bootstrap resampling estimate distribution depths identifies curves depth data-driven cutoff. function supports three different methods computing threshold.","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/outlier-detection.html","id":"threshold-methods","dir":"Articles","previous_headings":"Depth-Based Methods > Weighted Depth Method (outliers.depth.pond)","what":"Threshold Methods","title":"Outlier Detection","text":"Default: 95th percentile threshold (quan = 0.05), flags curves bottom 5% depths outliers.","code":"# Default: quantile method with quan = 0.05 (95th percentile, flags bottom 5%) out_pond <- outliers.depth.pond(fd, nb = 1000) print(out_pond) #> Functional data outlier detection #>   Number of observations: 30  #>   Number of outliers: 3  #>   Outlier indices: 1 2 3 #>   Threshold method: quantile  #>   Depth cutoff: 0.0591"},{"path":"https://sipemu.github.io/fdars-r/articles/outlier-detection.html","id":"comparing-threshold-methods","dir":"Articles","previous_headings":"Depth-Based Methods > Weighted Depth Method (outliers.depth.pond)","what":"Comparing Threshold Methods","title":"Outlier Detection","text":"Choosing right method: Quantile (default): Uses fixed proportion cutoff. default quan = 0.05 (95th percentile) flags bottom 5% curves. Increase quan = 0.1 permissive detection. MAD: robust existing outliers data. default k = 2.5 corresponds roughly 1-2% false positive rate. Increase k stricter detection (fewer outliers). IQR: Similar boxplot fences. default k = 1.5 standard boxplot rule. Use k = 3.0 “far outliers” .","code":"# Quantile method: flags curves with depth in the bottom 5% (default) out_quantile <- outliers.depth.pond(fd, nb = 1000,                                      threshold_method = \"quantile\", quan = 0.05) cat(\"Quantile (5%): \", out_quantile$outliers, \"\\n\") #> Quantile (5%):  1 2 3  # More permissive: bottom 10% out_quantile10 <- outliers.depth.pond(fd, nb = 1000,                                        threshold_method = \"quantile\", quan = 0.1) cat(\"Quantile (10%):\", out_quantile10$outliers, \"\\n\") #> Quantile (10%): 1 2 3  # MAD method: more robust, uses median - 2.5*MAD out_mad <- outliers.depth.pond(fd, nb = 1000,                                 threshold_method = \"mad\", k = 2.5) cat(\"MAD (k=2.5):   \", out_mad$outliers, \"\\n\") #> MAD (k=2.5):    1 2 3  # IQR method: boxplot-like, uses Q1 - 1.5*IQR out_iqr <- outliers.depth.pond(fd, nb = 1000,                                 threshold_method = \"iqr\", k = 1.5) cat(\"IQR (k=1.5):   \", out_iqr$outliers, \"\\n\") #> IQR (k=1.5):    1 2 3"},{"path":"https://sipemu.github.io/fdars-r/articles/outlier-detection.html","id":"visualizing-outliers","dir":"Articles","previous_headings":"Depth-Based Methods","what":"Visualizing Outliers","title":"Outlier Detection","text":"","code":"plot(out_pond)"},{"path":"https://sipemu.github.io/fdars-r/articles/outlier-detection.html","id":"examining-results","dir":"Articles","previous_headings":"Depth-Based Methods","what":"Examining Results","title":"Outlier Detection","text":"","code":"# Which curves are outliers? out_pond$outliers #> [1] 1 2 3  # Depth values for all curves head(out_pond$depths) #> [1] 0.03333337 0.05506193 0.05477837 0.87274161 0.86959674 0.86759472  # Cutoff used cat(\"Cutoff:\", out_pond$cutoff, \"\\n\") #> Cutoff: 0.05905061 cat(\"Threshold method:\", out_pond$threshold_method, \"\\n\") #> Threshold method: quantile"},{"path":"https://sipemu.github.io/fdars-r/articles/outlier-detection.html","id":"understanding-depth-pond-results","dir":"Articles","previous_headings":"Depth-Based Methods","what":"Understanding depth.pond Results","title":"Outlier Detection","text":"outliers.depth.pond method uses bootstrap resampling estimate depth values “normal” dataset. Key behaviors: Edge curves: Curves near boundary data cloud naturally lower depth, even ’re true outliers Bootstrap variability: Small samples give unstable cutoffs - use least nb = 200 stable results Threshold choice matters: quantile method fixed proportion always flag proportion outliers. Use mad iqr data-driven thresholds adapt actual depth distribution. Recommendation: Start threshold_method = \"mad\" robust, data-driven approach. Adjust k based conservative want detection . Compare outliers.depth.trim uses fixed trim proportion - predictable requires choose proportion.","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/outlier-detection.html","id":"trimming-based-method-outliers-depth-trim","dir":"Articles","previous_headings":"Depth-Based Methods","what":"Trimming-Based Method (outliers.depth.trim)","title":"Outlier Detection","text":"Iteratively removes curves lowest depth:","code":"out_trim <- outliers.depth.trim(fd, trim = 0.1, seed = 123) print(out_trim) #> Functional data outlier detection #>   Number of observations: 30  #>   Number of outliers: 3  #>   Outlier indices: 1 2 3 #>   Depth cutoff: 0.7817 plot(out_trim)"},{"path":"https://sipemu.github.io/fdars-r/articles/outlier-detection.html","id":"using-different-depth-functions","dir":"Articles","previous_headings":"Depth-Based Methods","what":"Using Different Depth Functions","title":"Outlier Detection","text":"methods accept depth parameter specify depth function:","code":"# Using Random Projection depth out_rp <- outliers.depth.pond(fd, nb = 1000, seed = 123)  # Using modal depth (default is FM) out_mode <- outliers.depth.trim(fd, trim = 0.1, seed = 123)"},{"path":"https://sipemu.github.io/fdars-r/articles/outlier-detection.html","id":"likelihood-ratio-test-lrt-method","dir":"Articles","previous_headings":"","what":"Likelihood Ratio Test (LRT) Method","title":"Outlier Detection","text":"LRT method uses likelihood ratio test sequentially identify outliers. ’s particularly effective detecting magnitude outliers.","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/outlier-detection.html","id":"automatic-threshold-computation","dir":"Articles","previous_headings":"Likelihood Ratio Test (LRT) Method","what":"Automatic Threshold Computation","title":"Outlier Detection","text":"LRT method automatically computes bootstrap threshold based percentile maximum distance distribution null hypothesis (outliers). default, 99th percentile used, meaning approximately 1% observations flagged outliers true outliers.","code":"# The outliers.lrt function automatically computes the threshold out_lrt <- outliers.lrt(fd, nb = 1000, seed = 123) print(out_lrt) #> Functional data outlier detection #>   Number of observations: 30  #>   Number of outliers: 0  #>   LRT threshold: 32.913  (99th percentile) plot(out_lrt)"},{"path":"https://sipemu.github.io/fdars-r/articles/outlier-detection.html","id":"configuring-the-percentile","dir":"Articles","previous_headings":"Likelihood Ratio Test (LRT) Method","what":"Configuring the Percentile","title":"Outlier Detection","text":"percentile parameter controls sensitivity LRT method: Higher percentile (e.g., 0.99): conservative, fewer false positives Lower percentile (e.g., 0.95): sensitive, may catch subtle outliers","code":"# Default: 99th percentile (conservative) out_lrt_99 <- outliers.lrt(fd, nb = 1000, seed = 123, percentile = 0.99) cat(\"99th percentile outliers:\", out_lrt_99$outliers, \"\\n\") #> 99th percentile outliers:  # More sensitive: 95th percentile out_lrt_95 <- outliers.lrt(fd, nb = 1000, seed = 123, percentile = 0.95) cat(\"95th percentile outliers:\", out_lrt_95$outliers, \"\\n\") #> 95th percentile outliers:"},{"path":"https://sipemu.github.io/fdars-r/articles/outlier-detection.html","id":"manual-threshold-computation","dir":"Articles","previous_headings":"Likelihood Ratio Test (LRT) Method","what":"Manual Threshold Computation","title":"Outlier Detection","text":"can also compute threshold separately want examine apply custom threshold:","code":"# Compute threshold separately (99th percentile by default) threshold_99 <- outliers.thres.lrt(fd, nb = 1000, seed = 123) cat(\"LRT threshold (99th percentile):\", threshold_99, \"\\n\") #> LRT threshold (99th percentile): 32.91297  # Or with a different percentile threshold_95 <- outliers.thres.lrt(fd, nb = 1000, seed = 123, percentile = 0.95) cat(\"LRT threshold (95th percentile):\", threshold_95, \"\\n\") #> LRT threshold (95th percentile): 32.36814"},{"path":"https://sipemu.github.io/fdars-r/articles/outlier-detection.html","id":"lrt-results","dir":"Articles","previous_headings":"Likelihood Ratio Test (LRT) Method","what":"LRT Results","title":"Outlier Detection","text":"","code":"# Outlier indices out_lrt$outliers #> integer(0)  # Distance from center for each curve head(out_lrt$distances) #> [1] 31.2933479 14.5221905 14.5627739  0.8885643  0.9423256  1.0432319  # Threshold used out_lrt$threshold #> [1] 32.91297"},{"path":"https://sipemu.github.io/fdars-r/articles/outlier-detection.html","id":"when-lrt-works-best","dir":"Articles","previous_headings":"Likelihood Ratio Test (LRT) Method","what":"When LRT Works Best","title":"Outlier Detection","text":"LRT method specifically optimized magnitude outliers - curves shifted relative main data cloud. computes far curve center (mean) data. LRT detects well: - Curves shifted (magnitude outliers) - Curves unusual overall level LRT may miss: - Shape outliers (different pattern similar overall level) - Amplitude outliers (scaled versions centered level) Using threshold (outliers.thres.lrt()): threshold represents critical value LRT statistic. Use : Apply custom significance level Compare test statistics across different datasets Combine domain knowledge decision-making LRT detects outliers expect : 1. outliers may shape-based rather magnitude-based 2. Try depth-based methods (outliers.depth.pond outliers.depth.trim) instead 3. Use outliergram MS-plot visual detection","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/outlier-detection.html","id":"comparing-methods","dir":"Articles","previous_headings":"","what":"Comparing Methods","title":"Outlier Detection","text":"Different methods may detect different types outliers:","code":"# Run all methods out1 <- outliers.depth.pond(fd, nb = 1000, seed = 123) out2 <- outliers.depth.trim(fd, trim = 0.1, seed = 123) out3 <- outliers.lrt(fd, nb = 1000, seed = 123)  # Compare detected outliers cat(\"Depth-pond outliers:\", out1$outliers, \"\\n\") #> Depth-pond outliers: 1 2 3 cat(\"Depth-trim outliers:\", out2$outliers, \"\\n\") #> Depth-trim outliers: 1 2 3 cat(\"LRT outliers:\", out3$outliers, \"\\n\") #> LRT outliers:  # True outliers are curves 1, 2, 3 cat(\"True outliers: 1, 2, 3\\n\") #> True outliers: 1, 2, 3"},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/articles/outlier-detection.html","id":"magnitude-outliers","dir":"Articles","previous_headings":"Types of Outliers","what":"Magnitude Outliers","title":"Outlier Detection","text":"Curves shifted main group:","code":"# Create clean data with just a magnitude outlier X_mag <- matrix(0, n, m) for (i in 1:n) {   X_mag[i, ] <- sin(2 * pi * t_grid) + rnorm(m, sd = 0.1) } X_mag[1, ] <- sin(2 * pi * t_grid) + 3  # Large vertical shift  fd_mag <- fdata(X_mag, argvals = t_grid)  # Visualize the magnitude outlier plot(fd_mag) +   labs(title = \"Magnitude Outlier: Curve 1 Shifted Up\",        subtitle = \"Same shape as others, but at a different level\") out_mag <- outliers.depth.pond(fd_mag, nb = 1000, seed = 123) cat(\"Detected magnitude outlier:\", out_mag$outliers, \"\\n\") #> Detected magnitude outlier: 1"},{"path":"https://sipemu.github.io/fdars-r/articles/outlier-detection.html","id":"shape-outliers","dir":"Articles","previous_headings":"Types of Outliers","what":"Shape Outliers","title":"Outlier Detection","text":"Curves different patterns similar overall level:","code":"# Create clean data with just a shape outlier X_shape <- matrix(0, n, m) for (i in 1:n) {   X_shape[i, ] <- sin(2 * pi * t_grid) + rnorm(m, sd = 0.1) } X_shape[1, ] <- -sin(2 * pi * t_grid)  # Inverted (phase-shifted by pi)  fd_shape <- fdata(X_shape, argvals = t_grid)  # Visualize the shape outlier plot(fd_shape) +   labs(title = \"Shape Outlier: Curve 1 Has Inverted Pattern\",        subtitle = \"Same amplitude and level, but opposite phase\") out_shape <- outliers.depth.pond(fd_shape, nb = 1000, seed = 123) cat(\"Detected shape outlier:\", out_shape$outliers, \"\\n\") #> Detected shape outlier: 1"},{"path":"https://sipemu.github.io/fdars-r/articles/outlier-detection.html","id":"amplitude-outliers","dir":"Articles","previous_headings":"Types of Outliers","what":"Amplitude Outliers","title":"Outlier Detection","text":"Curves unusual amplitude (larger smaller scale):","code":"# Create clean data with just an amplitude outlier X_amp <- matrix(0, n, m) for (i in 1:n) {   X_amp[i, ] <- sin(2 * pi * t_grid) + rnorm(m, sd = 0.1) } X_amp[1, ] <- 3 * sin(2 * pi * t_grid)  # 3x larger amplitude  fd_amp <- fdata(X_amp, argvals = t_grid)  # Visualize the amplitude outlier plot(fd_amp) +   labs(title = \"Amplitude Outlier: Curve 1 Has 3x Larger Scale\",        subtitle = \"Same shape and center, but much larger oscillations\") out_amp <- outliers.depth.pond(fd_amp, nb = 1000, seed = 123) cat(\"Detected amplitude outlier:\", out_amp$outliers, \"\\n\") #> Detected amplitude outlier: 1"},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/articles/outlier-detection.html","id":"number-of-bootstrap-samples","dir":"Articles","previous_headings":"Tuning Parameters","what":"Number of Bootstrap Samples","title":"Outlier Detection","text":"bootstrap samples give stable results take longer:","code":"# Compare with different nb values out_nb50 <- outliers.depth.pond(fd, nb = 50, seed = 123) out_nb200 <- outliers.depth.pond(fd, nb = 200, seed = 123)  cat(\"nb=50 outliers:\", out_nb50$outliers, \"\\n\") #> nb=50 outliers: 1 2 3 cat(\"nb=200 outliers:\", out_nb200$outliers, \"\\n\") #> nb=200 outliers: 1 2 3"},{"path":"https://sipemu.github.io/fdars-r/articles/outlier-detection.html","id":"trim-proportion","dir":"Articles","previous_headings":"Tuning Parameters","what":"Trim Proportion","title":"Outlier Detection","text":"outliers.depth.trim, trim proportion controls sensitivity:","code":"# More aggressive trimming out_trim05 <- outliers.depth.trim(fd, trim = 0.05, seed = 123) out_trim20 <- outliers.depth.trim(fd, trim = 0.2, seed = 123)  cat(\"trim=0.05 outliers:\", out_trim05$outliers, \"\\n\") #> trim=0.05 outliers: 1 3 cat(\"trim=0.20 outliers:\", out_trim20$outliers, \"\\n\") #> trim=0.20 outliers: 1 2 3 10 29 30"},{"path":"https://sipemu.github.io/fdars-r/articles/outlier-detection.html","id":"handling-high-contamination","dir":"Articles","previous_headings":"","what":"Handling High Contamination","title":"Outlier Detection","text":"outlier contamination high, use robust methods:","code":"# Create data with 20% outliers X_contam <- X n_outliers <- 6 for (i in 1:n_outliers) {   X_contam[i, ] <- sin(2 * pi * t_grid) + rnorm(1, 0, 2) }  fd_contam <- fdata(X_contam, argvals = t_grid)  # Depth-trim with higher trim proportion out_contam <- outliers.depth.trim(fd_contam, trim = 0.2, seed = 123) cat(\"Detected outliers:\", out_contam$outliers, \"\\n\") #> Detected outliers: 1 2 3 4 5 6 cat(\"True outliers: 1-6\\n\") #> True outliers: 1-6"},{"path":"https://sipemu.github.io/fdars-r/articles/outlier-detection.html","id":"visualizing-depth-distribution","dir":"Articles","previous_headings":"","what":"Visualizing Depth Distribution","title":"Outlier Detection","text":"","code":"# Compute depths depths <- depth.FM(fd)  # Create histogram library(ggplot2) df_depths <- data.frame(   curve = 1:n,   depth = depths,   type = ifelse(1:n %in% c(1, 2, 3), \"Outlier\", \"Normal\") )  ggplot(df_depths, aes(x = depth, fill = type)) +   geom_histogram(bins = 10, alpha = 0.7, position = \"identity\") +   labs(title = \"Distribution of Functional Depths\",        x = \"Depth\", y = \"Count\", fill = \"\") +   theme_minimal()"},{"path":"https://sipemu.github.io/fdars-r/articles/outlier-detection.html","id":"performance","dir":"Articles","previous_headings":"","what":"Performance","title":"Outlier Detection","text":"LRT method uses parallel Rust backend speed:","code":"# Benchmark with larger dataset X_large <- matrix(rnorm(200 * 100), 200, 100) fd_large <- fdata(X_large)  system.time(outliers.lrt(fd_large, nb = 200, seed = 123)) #>    user  system elapsed #>   0.456   0.000   0.123"},{"path":"https://sipemu.github.io/fdars-r/articles/outlier-detection.html","id":"outliergram-and-ms-plot","dir":"Articles","previous_headings":"","what":"Outliergram and MS-Plot","title":"Outlier Detection","text":"visual outlier detection, fdars provides two powerful diagnostic plots.","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/outlier-detection.html","id":"the-outliergram","dir":"Articles","previous_headings":"Outliergram and MS-Plot","what":"The Outliergram","title":"Outlier Detection","text":"outliergram plots Modified Epigraph Index (MEI) Modified Band Depth (MBD):  read outliergram: parabolic boundary marks theoretical limit non-outlying curves. Points boundary flagged outliers.","code":"og <- outliergram(fd) plot(og)"},{"path":"https://sipemu.github.io/fdars-r/articles/outlier-detection.html","id":"the-magnitude-shape-plot-ms-plot","dir":"Articles","previous_headings":"Outliergram and MS-Plot","what":"The Magnitude-Shape Plot (MS-Plot)","title":"Outlier Detection","text":"MS-plot separates magnitude outlyingness shape outlyingness:  read MS-plot: MS-plot particularly useful want understand curve outlier - level (magnitude) pattern (shape)?","code":"ms <- magnitudeshape(fd) plot(ms)"},{"path":"https://sipemu.github.io/fdars-r/articles/outlier-detection.html","id":"labeling-outliers-by-id-or-metadata","dir":"Articles","previous_headings":"Outliergram and MS-Plot","what":"Labeling Outliers by ID or Metadata","title":"Outlier Detection","text":"fdata IDs metadata, can label outliers plots:","code":"# Create fdata with IDs and metadata meta <- data.frame(   subject = paste0(\"S\", sprintf(\"%02d\", 1:n)),   group = rep(c(\"A\", \"B\"), length.out = n) ) fd_labeled <- fdata(X, argvals = t_grid,                     id = paste0(\"patient_\", 1:n),                     metadata = meta)  # Outliergram with patient IDs og_labeled <- outliergram(fd_labeled) plot(og_labeled, label = \"id\") # Or with metadata column plot(og_labeled, label = \"subject\") # Label ALL points, not just outliers plot(og_labeled, label = \"id\", label_all = TRUE) # magnitudeshape with custom labels magnitudeshape(fd_labeled, label = \"subject\")"},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/articles/outlier-detection.html","id":"best-practices","dir":"Articles","previous_headings":"","what":"Best Practices","title":"Outlier Detection","text":"Start visualization: Plot data understand outlier types Try multiple methods: Different methods catch different outliers Use sufficient bootstrap samples: least 100 stable results Consider domain knowledge: “outliers” may valid observations Validate findings: Check detected outliers make sense contextually","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/outlier-detection.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Outlier Detection","text":"Febrero, M., Galeano, P., González-Manteiga, W. (2008). Outlier detection functional data depth measures, application identify abnormal NOx levels. Environmetrics, 19(4), 331-345. Hyndman, R.J. Shang, H.L. (2010). Rainbow plots, bagplots, boxplots functional data. Journal Computational Graphical Statistics, 19(1), 29-45.","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/regression.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Functional Regression","text":"Functional regression extends classical regression handle functional predictors responses. common setting scalar--function regression, scalar response YY predicted functional predictor X(t)X(t).","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/regression.html","id":"the-functional-linear-model","dir":"Articles","previous_headings":"Introduction","what":"The Functional Linear Model","title":"Functional Regression","text":"foundational model functional regression functional linear model: Yi=α+∫𝒯β(t)Xi(t)dt+ϵiY_i = \\alpha + \\int_{\\mathcal{T}} \\beta(t) X_i(t) \\, dt + \\epsilon_i : YiY_i scalar response observation ii Xi(t)X_i(t) functional predictor observed domain 𝒯\\mathcal{T} α\\alpha intercept β(t)\\beta(t) coefficient function (unknown, estimated) ϵi∼N(0,σ2)\\epsilon_i \\sim N(0, \\sigma^2) ..d. errors integral ∫β(t)Xi(t)dt\\int \\beta(t) X_i(t) \\, dt can interpreted weighted average functional predictor, β(t)\\beta(t) determines importance time point tt predicting YY.","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/regression.html","id":"the-estimation-challenge","dir":"Articles","previous_headings":"Introduction","what":"The Estimation Challenge","title":"Functional Regression","text":"Unlike classical regression estimate finite number parameters, must estimate entire function β(t)\\beta(t). ill-posed inverse problem: infinitely many solutions may exist, small changes data can lead large changes estimate. fdars provides three main approaches regularize problem: Principal Component Regression (fregre.pc) — dimension reduction via FPCA Basis Expansion Regression (fregre.basis) — represent β(t)\\beta(t) finite basis Nonparametric Regression (fregre.np) — make parametric assumptions","code":"library(fdars) #>  #> Attaching package: 'fdars' #> The following objects are masked from 'package:stats': #>  #>     cov, decompose, deriv, median, sd, var #> The following object is masked from 'package:base': #>  #>     norm library(ggplot2) theme_set(theme_minimal())  # Generate example data set.seed(42) n <- 100 m <- 50 t_grid <- seq(0, 1, length.out = m)  # Functional predictors X <- matrix(0, n, m) for (i in 1:n) {   X[i, ] <- sin(2 * pi * t_grid) * rnorm(1, 1, 0.3) +             cos(4 * pi * t_grid) * rnorm(1, 0, 0.2) +             rnorm(m, sd = 0.1) }  fd <- fdata(X, argvals = t_grid)  # True coefficient function beta_true <- sin(2 * pi * t_grid)  # Generate response: Y = integral(beta * X) + noise y <- numeric(n) for (i in 1:n) {   y[i] <- sum(beta_true * X[i, ]) / m + rnorm(1, sd = 0.5) }  plot(fd)"},{"path":"https://sipemu.github.io/fdars-r/articles/regression.html","id":"principal-component-regression","dir":"Articles","previous_headings":"","what":"Principal Component Regression","title":"Functional Regression","text":"Principal component regression (PCR) reduces infinite-dimensional problem finite-dimensional one projecting functional data onto principal components.","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/regression.html","id":"mathematical-formulation","dir":"Articles","previous_headings":"Principal Component Regression","what":"Mathematical Formulation","title":"Functional Regression","text":"Using functional principal component analysis (FPCA), curve can represented : Xi(t)=X‾(t)+∑k=1∞ξikϕk(t)X_i(t) = \\bar{X}(t) + \\sum_{k=1}^{\\infty} \\xi_{ik} \\phi_k(t) ϕk(t)\\phi_k(t) eigenfunctions (principal components) ξik=∫(Xi(t)−X‾(t))ϕk(t)dt\\xi_{ik} = \\int (X_i(t) - \\bar{X}(t)) \\phi_k(t) \\, dt PC scores. Truncating KK components substituting functional linear model gives: Yi=α+∑k=1Kγkξik+ϵiY_i = \\alpha + \\sum_{k=1}^{K} \\gamma_k \\xi_{ik} + \\epsilon_i γk=∫β(t)ϕk(t)dt\\gamma_k = \\int \\beta(t) \\phi_k(t) \\, dt. now standard multiple linear regression predictors ξi1,…,ξiK\\xi_{i1}, \\ldots, \\xi_{iK}. coefficient function reconstructed : β̂(t)=∑k=1Kγ̂kϕk(t)\\hat{\\beta}(t) = \\sum_{k=1}^{K} \\hat{\\gamma}_k \\phi_k(t)","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/regression.html","id":"choosing-the-number-of-components","dir":"Articles","previous_headings":"Principal Component Regression","what":"Choosing the Number of Components","title":"Functional Regression","text":"key tuning parameter KK, number principal components: : underfitting, missing important variation X(t)X(t) many: overfitting, including noise components Cross-validation information criteria (AIC, BIC) can guide choice.","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/regression.html","id":"basic-usage","dir":"Articles","previous_headings":"Principal Component Regression","what":"Basic Usage","title":"Functional Regression","text":"","code":"# Fit PC regression with 3 components fit_pc <- fregre.pc(fd, y, ncomp = 3) print(fit_pc) #> Functional regression model #>   Number of observations: 100  #>   R-squared: 0.1682634"},{"path":"https://sipemu.github.io/fdars-r/articles/regression.html","id":"examining-the-fit","dir":"Articles","previous_headings":"Principal Component Regression","what":"Examining the Fit","title":"Functional Regression","text":"","code":"# Fitted values fitted_pc <- fit_pc$fitted.values  # Residuals residuals_pc <- y - fitted_pc  # R-squared r2_pc <- 1 - sum(residuals_pc^2) / sum((y - mean(y))^2) cat(\"R-squared:\", round(r2_pc, 3), \"\\n\") #> R-squared: 0.168"},{"path":"https://sipemu.github.io/fdars-r/articles/regression.html","id":"cross-validation-for-component-selection","dir":"Articles","previous_headings":"Principal Component Regression","what":"Cross-Validation for Component Selection","title":"Functional Regression","text":"","code":"# Find optimal number of components cv_pc <- fregre.pc.cv(fd, y, kmax = 10)  cat(\"Optimal number of components:\", cv_pc$ncomp.opt, \"\\n\") #> Optimal number of components: cat(\"CV error by component:\\n\") #> CV error by component: print(round(cv_pc$cv.error, 4)) #>      1      2      3      4      5      6      7      8      9     10     11  #> 0.2674 0.2700 0.2720 0.2735 0.2785 0.2735 0.2691 0.2718 0.2728 0.2744 0.2735  #>     12     13     14     15  #> 0.2746 0.2714 0.2703 0.2746"},{"path":"https://sipemu.github.io/fdars-r/articles/regression.html","id":"prediction","dir":"Articles","previous_headings":"Principal Component Regression","what":"Prediction","title":"Functional Regression","text":"","code":"# Split data train_idx <- 1:80 test_idx <- 81:100  fd_train <- fd[train_idx, ] fd_test <- fd[test_idx, ] y_train <- y[train_idx] y_test <- y[test_idx]  # Fit on training data fit_train <- fregre.pc(fd_train, y_train, ncomp = 3)  # Predict on test data y_pred <- predict(fit_train, fd_test)  # Evaluate cat(\"Test RMSE:\", round(pred.RMSE(y_test, y_pred), 3), \"\\n\") #> Test RMSE: 0.457 cat(\"Test R2:\", round(pred.R2(y_test, y_pred), 3), \"\\n\") #> Test R2: 0.219"},{"path":"https://sipemu.github.io/fdars-r/articles/regression.html","id":"basis-expansion-regression","dir":"Articles","previous_headings":"","what":"Basis Expansion Regression","title":"Functional Regression","text":"Basis expansion regression represents functional predictor X(t)X(t) coefficient function β(t)\\beta(t) using finite set basis functions, reducing infinite-dimensional problem finite-dimensional one.","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/regression.html","id":"mathematical-formulation-1","dir":"Articles","previous_headings":"Basis Expansion Regression","what":"Mathematical Formulation","title":"Functional Regression","text":"Let {Bj(t)}j=1J\\{B_j(t)\\}_{j=1}^{J} set basis functions (e.g., B-splines Fourier). expand: Xi(t)=∑j=1JcijBj(t)andβ(t)=∑j=1JbjBj(t)X_i(t) = \\sum_{j=1}^{J} c_{ij} B_j(t) \\quad \\text{} \\quad \\beta(t) = \\sum_{j=1}^{J} b_j B_j(t) Substituting functional linear model: Yi=α+∫(∑j=1JbjBj(t))(∑k=1JcikBk(t))dt+ϵiY_i = \\alpha + \\int \\left(\\sum_{j=1}^{J} b_j B_j(t)\\right) \\left(\\sum_{k=1}^{J} c_{ik} B_k(t)\\right) dt + \\epsilon_i simplifies : Yi=α+𝐜i⊤𝐖𝐛+ϵiY_i = \\alpha + \\mathbf{c}_i^\\top \\mathbf{W} \\mathbf{b} + \\epsilon_i 𝐜i=(ci1,…,ciJ)⊤\\mathbf{c}_i = (c_{i1}, \\ldots, c_{iJ})^\\top basis coefficients Xi(t)X_i(t), 𝐛=(b1,…,bJ)⊤\\mathbf{b} = (b_1, \\ldots, b_J)^\\top unknown coefficients β(t)\\beta(t), 𝐖\\mathbf{W} inner product matrix entries Wjk=∫Bj(t)Bk(t)dtW_{jk} = \\int B_j(t) B_k(t) \\, dt.","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/regression.html","id":"ridge-regularization","dir":"Articles","previous_headings":"Basis Expansion Regression","what":"Ridge Regularization","title":"Functional Regression","text":"prevent overfitting (especially many basis functions), add roughness penalty. penalized least squares objective : minα,𝐛∑=1n(Yi−α−𝐜i⊤𝐖𝐛)2+λ∫[β″(t)]2dt\\min_{\\alpha, \\mathbf{b}} \\sum_{=1}^{n} \\left(Y_i - \\alpha - \\mathbf{c}_i^\\top \\mathbf{W} \\mathbf{b}\\right)^2 + \\lambda \\int \\left[\\beta''(t)\\right]^2 dt penalty ∫[β″(t)]2dt\\int [\\beta''(t)]^2 dt discourages rapid oscillations. matrix form: minα,𝐛∥𝐘−α𝟏−𝐂𝐖𝐛∥2+λ𝐛⊤𝐑𝐛\\min_{\\alpha, \\mathbf{b}} \\|\\mathbf{Y} - \\alpha \\mathbf{1} - \\mathbf{C}\\mathbf{W}\\mathbf{b}\\|^2 + \\lambda \\mathbf{b}^\\top \\mathbf{R} \\mathbf{b} 𝐑\\mathbf{R} roughness penalty matrix Rjk=∫Bj″(t)Bk″(t)dtR_{jk} = \\int B_j''(t) B_k''(t) \\, dt. solution : 𝐛̂=(𝐖⊤𝐂⊤𝐂𝐖+λ𝐑)−1𝐖⊤𝐂⊤(𝐘−Y‾)\\hat{\\mathbf{b}} = \\left(\\mathbf{W}^\\top \\mathbf{C}^\\top \\mathbf{C} \\mathbf{W} + \\lambda \\mathbf{R}\\right)^{-1} \\mathbf{W}^\\top \\mathbf{C}^\\top (\\mathbf{Y} - \\bar{Y})","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/regression.html","id":"basis-choice","dir":"Articles","previous_headings":"Basis Expansion Regression","what":"Basis Choice","title":"Functional Regression","text":"B-splines: Flexible, local support, good non-periodic data Fourier: Natural periodic data, global support","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/regression.html","id":"basic-usage-1","dir":"Articles","previous_headings":"Basis Expansion Regression","what":"Basic Usage","title":"Functional Regression","text":"","code":"# Fit basis regression with 15 B-spline basis functions fit_basis <- fregre.basis(fd, y, nbasis = 15, type = \"bspline\") print(fit_basis) #> Functional regression model #>   Number of observations: 100  #>   R-squared: 0.5805754"},{"path":"https://sipemu.github.io/fdars-r/articles/regression.html","id":"regularization","dir":"Articles","previous_headings":"Basis Expansion Regression","what":"Regularization","title":"Functional Regression","text":"lambda parameter controls regularization:","code":"# Higher lambda = more regularization fit_basis_reg <- fregre.basis(fd, y, nbasis = 15, type = \"bspline\", lambda = 1)"},{"path":"https://sipemu.github.io/fdars-r/articles/regression.html","id":"cross-validation-for-lambda","dir":"Articles","previous_headings":"Basis Expansion Regression","what":"Cross-Validation for Lambda","title":"Functional Regression","text":"","code":"# Find optimal lambda cv_basis <- fregre.basis.cv(fd, y, nbasis = 15, type = \"bspline\",                             lambda = c(0, 0.001, 0.01, 0.1, 1, 10))  cat(\"Optimal lambda:\", cv_basis$lambda.opt, \"\\n\") #> Optimal lambda: cat(\"CV error by lambda:\\n\") #> CV error by lambda: print(round(cv_basis$cv.error, 4)) #>      0  0.001   0.01    0.1      1     10  #> 0.5967 0.5926 0.5605 0.4299 0.3209 0.2977"},{"path":"https://sipemu.github.io/fdars-r/articles/regression.html","id":"fourier-basis","dir":"Articles","previous_headings":"Basis Expansion Regression","what":"Fourier Basis","title":"Functional Regression","text":"periodic data, use Fourier basis:","code":"fit_fourier <- fregre.basis(fd, y, nbasis = 11, type = \"fourier\")"},{"path":"https://sipemu.github.io/fdars-r/articles/regression.html","id":"nonparametric-regression","dir":"Articles","previous_headings":"","what":"Nonparametric Regression","title":"Functional Regression","text":"Nonparametric functional regression makes parametric assumptions relationship X(t)X(t) YY. Instead, estimates 𝔼[Y|X=x]\\mathbb{E}[Y | X = x] directly using local averaging techniques.","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/regression.html","id":"the-general-framework","dir":"Articles","previous_headings":"Nonparametric Regression","what":"The General Framework","title":"Functional Regression","text":"Given new functional observation X*X^*, predicted response : Ŷ*=m̂(X*)=∑=1nwi(X*)Yi\\hat{Y}^* = \\hat{m}(X^*) = \\sum_{=1}^{n} w_i(X^*) Y_i wi(X*)w_i(X^*) weights depend “distance” X*X^* training curves XiX_i. Different methods define weights differently.","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/regression.html","id":"functional-distance","dir":"Articles","previous_headings":"Nonparametric Regression","what":"Functional Distance","title":"Functional Regression","text":"key component semimetric d(Xi,Xj)d(X_i, X_j) measuring similarity curves. Common choices: L2L^2 metric: d(Xi,Xj)=∫[Xi(t)−Xj(t)]2dtd(X_i, X_j) = \\sqrt{\\int [X_i(t) - X_j(t)]^2 \\, dt} LpL^p metric: d(Xi,Xj)=(∫|Xi(t)−Xj(t)|pdt)1/pd(X_i, X_j) = \\left(\\int |X_i(t) - X_j(t)|^p \\, dt\\right)^{1/p} PCA-based semimetric: d(Xi,Xj)=∑k=1K(ξik−ξjk)2d(X_i, X_j) = \\sqrt{\\sum_{k=1}^{K} (\\xi_{ik} - \\xi_{jk})^2} using PC scores","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/regression.html","id":"nadaraya-watson-estimator","dir":"Articles","previous_headings":"Nonparametric Regression","what":"Nadaraya-Watson Estimator","title":"Functional Regression","text":"Nadaraya-Watson (kernel regression) estimator uses: m̂(X*)=∑=1nK(d(X*,Xi)h)Yi∑=1nK(d(X*,Xi)h)\\hat{m}(X^*) = \\frac{\\sum_{=1}^{n} K\\left(\\frac{d(X^*, X_i)}{h}\\right) Y_i}{\\sum_{=1}^{n} K\\left(\\frac{d(X^*, X_i)}{h}\\right)} K(⋅)K(\\cdot) kernel function h>0h > 0 bandwidth controlling smoothness: Small hh: weights concentrated nearest neighbors (low bias, high variance) Large hh: weights spread across many observations (high bias, low variance) Common kernels include:","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/regression.html","id":"k-nearest-neighbors","dir":"Articles","previous_headings":"Nonparametric Regression","what":"k-Nearest Neighbors","title":"Functional Regression","text":"k-NN estimator averages responses kk closest curves: m̂(X*)=1k∑∈𝒩k(X*)Yi\\hat{m}(X^*) = \\frac{1}{k} \\sum_{\\\\mathcal{N}_k(X^*)} Y_i 𝒩k(X*)\\mathcal{N}_k(X^*) set indices kk nearest neighbors X*X^*. Two variants available: Global k-NN (kNN.gCV): single kk selected leave-one-cross-validation Local k-NN (kNN.lCV): adaptive kk may vary per prediction point","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/regression.html","id":"nadaraya-watson-example","dir":"Articles","previous_headings":"Nonparametric Regression","what":"Nadaraya-Watson Example","title":"Functional Regression","text":"","code":"# Fit nonparametric regression with Nadaraya-Watson fit_np <- fregre.np(fd, y, type.S = \"S.NW\") print(fit_np) #> Nonparametric functional regression model #>   Number of observations: 100  #>   Smoother type: S.NW  #>   Bandwidth: 0.3302789  #>   R-squared: 0.0552"},{"path":"https://sipemu.github.io/fdars-r/articles/regression.html","id":"k-nearest-neighbors-1","dir":"Articles","previous_headings":"Nonparametric Regression","what":"k-Nearest Neighbors","title":"Functional Regression","text":"Two flavors k-NN available:","code":"# Global k-NN (single k for all observations) fit_knn_global <- fregre.np(fd, y, type.S = \"kNN.gCV\")  # Local k-NN (adaptive k per observation) fit_knn_local <- fregre.np(fd, y, type.S = \"kNN.lCV\")  cat(\"Global k-NN optimal k:\", fit_knn_global$knn, \"\\n\") #> Global k-NN optimal k: 20"},{"path":"https://sipemu.github.io/fdars-r/articles/regression.html","id":"bandwidth-selection","dir":"Articles","previous_headings":"Nonparametric Regression","what":"Bandwidth Selection","title":"Functional Regression","text":"","code":"# Cross-validation for bandwidth cv_np <- fregre.np.cv(fd, y, h.seq = seq(0.1, 1, by = 0.1))  cat(\"Optimal bandwidth:\", cv_np$h.opt, \"\\n\") #> Optimal bandwidth:"},{"path":"https://sipemu.github.io/fdars-r/articles/regression.html","id":"different-kernels","dir":"Articles","previous_headings":"Nonparametric Regression","what":"Different Kernels","title":"Functional Regression","text":"","code":"# Epanechnikov kernel fit_epa <- fregre.np(fd, y, Ker = \"epa\")  # Available kernels: \"norm\", \"epa\", \"tri\", \"quar\", \"cos\", \"unif\""},{"path":"https://sipemu.github.io/fdars-r/articles/regression.html","id":"different-metrics","dir":"Articles","previous_headings":"Nonparametric Regression","what":"Different Metrics","title":"Functional Regression","text":"","code":"# Use L1 metric instead of default L2 fit_np_l1 <- fregre.np(fd, y, metric = metric.lp, p = 1)  # Use semimetric based on PCA fit_np_pca <- fregre.np(fd, y, metric = semimetric.pca, ncomp = 5)"},{"path":"https://sipemu.github.io/fdars-r/articles/regression.html","id":"comparing-methods","dir":"Articles","previous_headings":"","what":"Comparing Methods","title":"Functional Regression","text":"","code":"# Fit all methods on training data fit1 <- fregre.pc(fd_train, y_train, ncomp = 3) fit2 <- fregre.basis(fd_train, y_train, nbasis = 15) fit3 <- fregre.np(fd_train, y_train, type.S = \"kNN.gCV\")  # Predict on test data pred1 <- predict(fit1, fd_test) pred2 <- predict(fit2, fd_test) pred3 <- predict(fit3, fd_test)  # Compare performance results <- data.frame(   Method = c(\"PC Regression\", \"Basis Regression\", \"k-NN\"),   RMSE = c(pred.RMSE(y_test, pred1),            pred.RMSE(y_test, pred2),            pred.RMSE(y_test, pred3)),   R2 = c(pred.R2(y_test, pred1),          pred.R2(y_test, pred2),          pred.R2(y_test, pred3)) ) print(results) #>             Method      RMSE          R2 #> 1    PC Regression 0.4570245  0.21884391 #> 2 Basis Regression 0.8989962 -2.02255778 #> 3             k-NN 0.4935318  0.08906132"},{"path":"https://sipemu.github.io/fdars-r/articles/regression.html","id":"visualizing-predictions","dir":"Articles","previous_headings":"","what":"Visualizing Predictions","title":"Functional Regression","text":"","code":"# Create comparison data frame df_pred <- data.frame(   Observed = y_test,   PC = pred1,   Basis = pred2,   kNN = pred3 )  # Observed vs predicted ggplot(df_pred, aes(x = Observed, y = PC)) +   geom_point() +   geom_abline(intercept = 0, slope = 1, linetype = \"dashed\", color = \"red\") +   labs(title = \"PC Regression: Observed vs Predicted\",        x = \"Observed\", y = \"Predicted\") +   theme_minimal()"},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/articles/regression.html","id":"when-to-use-each-method","dir":"Articles","previous_headings":"Method Selection Guide","what":"When to Use Each Method","title":"Functional Regression","text":"Principal Component Regression (fregre.pc): Best functional predictor clear dominant modes variation Computationally efficient large datasets Interpretable: PC represents pattern data Use nn small relative complexity X(t)X(t) Basis Expansion Regression (fregre.basis): Best believe β(t)\\beta(t) smooth Use B-splines local features, Fourier periodic patterns penalty parameter λ\\lambda provides automatic regularization Good want visualize interpret β̂(t)\\hat{\\beta}(t) Nonparametric Regression (fregre.np): Best relationship XX YY may nonlinear Makes minimal assumptions data-generating process Computationally expensive (requires distance calculations) May require larger sample sizes stable estimation","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/articles/regression.html","id":"prediction-metrics","dir":"Articles","previous_headings":"","what":"Prediction Metrics","title":"Functional Regression","text":"Model performance evaluated using standard regression metrics. Given observed values y1,…,yny_1, \\ldots, y_n predictions ŷ1,…,ŷn\\hat{y}_1, \\ldots, \\hat{y}_n:","code":"# Available metrics for model evaluation cat(\"MAE:\", pred.MAE(y_test, pred1), \"\\n\") #> MAE: 0.3819577 cat(\"MSE:\", pred.MSE(y_test, pred1), \"\\n\") #> MSE: 0.2088714 cat(\"RMSE:\", pred.RMSE(y_test, pred1), \"\\n\") #> RMSE: 0.4570245 cat(\"R2:\", pred.R2(y_test, pred1), \"\\n\") #> R2: 0.2188439"},{"path":"https://sipemu.github.io/fdars-r/articles/regression.html","id":"cross-validation","dir":"Articles","previous_headings":"Prediction Metrics","what":"Cross-Validation","title":"Functional Regression","text":"methods support leave-one-cross-validation (LOOCV) parameter selection: CV=1n∑=1n(Yi−Ŷ−)2\\text{CV} = \\frac{1}{n} \\sum_{=1}^{n} (Y_i - \\hat{Y}_{-})^2 Ŷ−\\hat{Y}_{-} prediction observation ii left training set. implemented efficiently using “hat matrix trick” linear methods.","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/regression.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Functional Regression","text":"Foundational texts: Ramsay, J.O. Silverman, B.W. (2005). Functional Data Analysis, 2nd ed. Springer. Ferraty, F. Vieu, P. (2006). Nonparametric Functional Data Analysis: Theory Practice. Springer. Horváth, L. Kokoszka, P. (2012). Inference Functional Data Applications. Springer. Key methodological papers: Cardot, H., Ferraty, F., Sarda, P. (1999). Functional Linear Model. Statistics & Probability Letters, 45(1), 11-22. Reiss, P.T. Ogden, R.T. (2007). Functional Principal Component Regression Functional Partial Least Squares. Journal American Statistical Association, 102(479), 984-996. Goldsmith, J., Bobb, J., Crainiceanu, C., Caffo, B., Reich, D. (2011). Penalized Functional Regression. Journal Computational Graphical Statistics, 20(4), 830-851. nonparametric functional regression: Ferraty, F., Laksaci, ., Vieu, P. (2006). Estimating Characteristics Conditional Distribution Nonparametric Functional Models. Statistical Inference Stochastic Processes, 9, 47-76.","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/seasonal-analysis.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Seasonal Analysis of Functional Data","text":"Seasonal patterns ubiquitous functional data: temperature cycles, biological rhythms, economic fluctuations, many . vignette demonstrates seasonal analysis capabilities fdars, organized basic period estimation advanced techniques complex signals. ’ll learn: estimate period seasonal signals detect multiple concurrent seasonalities tune peak detection parameters noisy data use instantaneous period estimation () analyze short series 3-5 cycles","code":"library(fdars) #>  #> Attaching package: 'fdars' #> The following objects are masked from 'package:stats': #>  #>     cov, decompose, deriv, median, sd, var #> The following object is masked from 'package:base': #>  #>     norm library(ggplot2) theme_set(theme_minimal()) set.seed(42)"},{"path":"https://sipemu.github.io/fdars-r/articles/seasonal-analysis.html","id":"estimating-seasonal-period","dir":"Articles","previous_headings":"","what":"Estimating Seasonal Period","title":"Seasonal Analysis of Functional Data","text":"first step seasonal analysis often determining period. fdars provides two methods: FFT (frequency domain) ACF (autocorrelation).","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/seasonal-analysis.html","id":"simple-periodic-signals","dir":"Articles","previous_headings":"Estimating Seasonal Period","what":"Simple Periodic Signals","title":"Seasonal Analysis of Functional Data","text":"Let’s start clean sinusoidal signal.  confidence value indicates pronounced dominant frequency relative frequencies. High confidence (close 1) means clear, dominant period.","code":"# Time grid: 10 complete cycles of period 2 t <- seq(0, 20, length.out = 400) period_true <- 2  # Pure sine wave X_pure <- sin(2 * pi * t / period_true) fd_pure <- fdata(matrix(X_pure, nrow = 1), argvals = t)  # Plot df <- data.frame(t = t, y = X_pure) ggplot(df, aes(x = t, y = y)) +   geom_line(color = \"steelblue\") +   labs(title = \"Pure Seasonal Signal (Period = 2)\", x = \"Time\", y = \"Value\") # FFT method est_fft <- estimate.period(fd_pure, method = \"fft\") cat(\"FFT estimate:\", est_fft$period, \"(true:\", period_true, \")\\n\") #> FFT estimate: 2.005013 (true: 2 ) cat(\"Confidence:\", round(est_fft$confidence, 3), \"\\n\") #> Confidence: 199.585"},{"path":"https://sipemu.github.io/fdars-r/articles/seasonal-analysis.html","id":"noisy-signals","dir":"Articles","previous_headings":"Estimating Seasonal Period","what":"Noisy Signals","title":"Seasonal Analysis of Functional Data","text":"Real data always contains noise. Let’s see methods handle .  methods typically agree clean periodic signals. ACF method can robust certain types noise, FFT faster handles multiple harmonics well.","code":"# Add noise X_noisy <- sin(2 * pi * t / period_true) + rnorm(length(t), sd = 0.3) fd_noisy <- fdata(matrix(X_noisy, nrow = 1), argvals = t)  df <- data.frame(t = t, y = X_noisy) ggplot(df, aes(x = t, y = y)) +   geom_line(color = \"steelblue\", alpha = 0.7) +   labs(title = \"Noisy Seasonal Signal (SD = 0.3)\", x = \"Time\", y = \"Value\") # Compare methods est_fft_noisy <- estimate.period(fd_noisy, method = \"fft\") est_acf <- estimate.period(fd_noisy, method = \"acf\")  cat(\"True period:\", period_true, \"\\n\") #> True period: 2 cat(\"FFT estimate:\", est_fft_noisy$period, \"(confidence:\", round(est_fft_noisy$confidence, 3), \")\\n\") #> FFT estimate: 2.005013 (confidence: 171.93 ) cat(\"ACF estimate:\", est_acf$period, \"(confidence:\", round(est_acf$confidence, 3), \")\\n\") #> ACF estimate: 2.005013 (confidence: 0.783 )"},{"path":"https://sipemu.github.io/fdars-r/articles/seasonal-analysis.html","id":"signals-with-multiple-harmonics","dir":"Articles","previous_headings":"Estimating Seasonal Period","what":"Signals with Multiple Harmonics","title":"Seasonal Analysis of Functional Data","text":"Real seasonal patterns often harmonics (e.g., yearly + half-yearly components share fundamental period).  FFT method correctly identifies fundamental period, even harmonics present. harmonics share fundamental frequency, reinforce estimate.","code":"# Signal with 2nd and 3rd harmonics X_multi <- sin(2 * pi * t / period_true) +            0.3 * sin(4 * pi * t / period_true) +  # 2nd harmonic            0.1 * sin(6 * pi * t / period_true) +  # 3rd harmonic            rnorm(length(t), sd = 0.1) fd_multi <- fdata(matrix(X_multi, nrow = 1), argvals = t)  df <- data.frame(t = t, y = X_multi) ggplot(df, aes(x = t, y = y)) +   geom_line(color = \"steelblue\") +   labs(title = \"Signal with Multiple Harmonics\", x = \"Time\", y = \"Value\") est_multi <- estimate.period(fd_multi, method = \"fft\") cat(\"Estimated period:\", est_multi$period, \"(true:\", period_true, \")\\n\") #> Estimated period: 2.005013 (true: 2 )"},{"path":"https://sipemu.github.io/fdars-r/articles/seasonal-analysis.html","id":"detecting-multiple-concurrent-seasonalities","dir":"Articles","previous_headings":"","what":"Detecting Multiple Concurrent Seasonalities","title":"Seasonal Analysis of Functional Data","text":"Sometimes signal contains multiple independent periodicities (e.g., daily yearly cycles). estimate.period() function returns dominant period. ’s detect multiple periods.","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/seasonal-analysis.html","id":"why-estimate-period-returns-only-one-period","dir":"Articles","previous_headings":"Detecting Multiple Concurrent Seasonalities","what":"Why estimate.period() Returns Only One Period","title":"Seasonal Analysis of Functional Data","text":"","code":"# Signal with two independent periods period1 <- 2   # Fast cycle period2 <- 7   # Slow cycle  X_dual <- sin(2 * pi * t / period1) + 0.6 * sin(2 * pi * t / period2) fd_dual <- fdata(matrix(X_dual, nrow = 1), argvals = t)  df <- data.frame(t = t, y = X_dual) ggplot(df, aes(x = t, y = y)) +   geom_line(color = \"steelblue\") +   labs(title = \"Signal with Two Periods (2 and 7)\",        x = \"Time\", y = \"Value\") est_single <- estimate.period(fd_dual, method = \"fft\") cat(\"Single estimate:\", est_single$period, \"\\n\") #> Single estimate: 2.005013 cat(\"(Only detects the dominant period)\\n\") #> (Only detects the dominant period)"},{"path":"https://sipemu.github.io/fdars-r/articles/seasonal-analysis.html","id":"using-detect-periods","dir":"Articles","previous_headings":"Detecting Multiple Concurrent Seasonalities","what":"Using detect.periods()","title":"Seasonal Analysis of Functional Data","text":"detect.periods() function uses iterative residual approach implemented Rust efficiency: Estimate dominant period using FFT Subtract fitted sinusoid period Repeat residual confidence strength drops low","code":"# Detect multiple periods using the package function # Higher thresholds prevent spurious detection detected <- detect.periods(fd_dual, max_periods = 3,                                      min_confidence = 0.5,                                      min_strength = 0.25) print(detected) #> Multiple Period Detection #> ------------------------- #> Periods detected: 3 #>  #> Period 1: 2.005 (confidence=148.091, strength=0.741, amplitude=0.956) #> Period 2: 6.683 (confidence=123.084, strength=0.628, amplitude=0.444) #> Period 3: 10.025 (confidence=128.631, strength=0.705, amplitude=0.282)"},{"path":"https://sipemu.github.io/fdars-r/articles/seasonal-analysis.html","id":"visualizing-the-decomposition","dir":"Articles","previous_headings":"Detecting Multiple Concurrent Seasonalities","what":"Visualizing the Decomposition","title":"Seasonal Analysis of Functional Data","text":"Practical guidance: harmonics fundamental: estimate.period() correctly finds fundamental period. iterative approach needed. truly different periods (e.g., daily + yearly): use iterative approach . confidence drops threshold: stop - remaining signal likely noise. Note detection order: Periods detected order amplitude, period length. component highest FFT power (roughly proportional amplitude squared) found first. example, signal weak yearly cycle strong weekly cycle, weekly cycle detected first regardless period longer. weak periodicities (< 20% dominant amplitude) may require lower thresholds risk false positives.","code":"# Reconstruct each component using detected periods components <- data.frame(t = t) residual <- X_dual  if (detected$n_periods > 0) {   for (i in seq_len(detected$n_periods)) {     omega <- 2 * pi / detected$periods[i]     cos_comp <- cos(omega * t)     sin_comp <- sin(omega * t)     a <- 2 * mean(residual * cos_comp)     b <- 2 * mean(residual * sin_comp)     component <- a * cos_comp + b * sin_comp     components[[paste0(\"Period_\", round(detected$periods[i], 1))]] <- component     residual <- residual - component   } } components$Residual <- residual components$Original <- X_dual  # Plot decomposition library(tidyr) df_long <- pivot_longer(components, -t, names_to = \"Component\", values_to = \"Value\") # Get period column names (exclude t, Residual, Original) period_cols <- setdiff(names(components), c(\"t\", \"Residual\", \"Original\")) df_long$Component <- factor(df_long$Component,                             levels = c(\"Original\", period_cols, \"Residual\"))  ggplot(df_long, aes(x = t, y = Value)) +   geom_line(color = \"steelblue\") +   facet_wrap(~Component, ncol = 1, scales = \"free_y\") +   labs(title = \"Decomposition into Periodic Components\",        x = \"Time\", y = \"Value\")"},{"path":"https://sipemu.github.io/fdars-r/articles/seasonal-analysis.html","id":"handling-non-stationary-data","dir":"Articles","previous_headings":"","what":"Handling Non-Stationary Data","title":"Seasonal Analysis of Functional Data","text":"Real-world time series often trends can mask distort seasonal patterns. fdars provides comprehensive detrending decomposition functions handle .","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/seasonal-analysis.html","id":"the-problem-trends-mask-seasonality","dir":"Articles","previous_headings":"Handling Non-Stationary Data","what":"The Problem: Trends Mask Seasonality","title":"Seasonal Analysis of Functional Data","text":"strong trend present, seasonal analysis functions may fail:  trend causes: - Period estimation return series length (20) instead true period (2.5) - Seasonal strength nearly zero, close 1","code":"# Signal with strong linear trend + seasonality + noise t <- seq(0, 20, length.out = 400) X_trend <- 5 + 2 * t + sin(2 * pi * t / 2.5) + rnorm(length(t), sd = 0.3) fd_trend <- fdata(matrix(X_trend, nrow = 1), argvals = t)  df <- data.frame(t = t, y = X_trend) ggplot(df, aes(x = t, y = y)) +   geom_line(color = \"steelblue\") +   labs(title = \"Seasonal Signal with Strong Linear Trend\",        subtitle = \"The trend dominates, masking the seasonality\",        x = \"Time\", y = \"Value\") # Without detrending - incorrect results! period_wrong <- estimate.period(fd_trend)$period strength_wrong <- seasonal.strength(fd_trend, period = 2.5)  cat(\"WITHOUT detrending:\\n\") #> WITHOUT detrending: cat(\"  Estimated period:\", round(period_wrong, 2), \"(true: 2.5)\\n\") #>   Estimated period: 20.05 (true: 2.5) cat(\"  Seasonal strength:\", round(strength_wrong, 3), \"(should be ~1)\\n\") #>   Seasonal strength: 0.005 (should be ~1)"},{"path":"https://sipemu.github.io/fdars-r/articles/seasonal-analysis.html","id":"using-detrend","dir":"Articles","previous_headings":"Handling Non-Stationary Data","what":"Using detrend()","title":"Seasonal Analysis of Functional Data","text":"detrend() function removes trends using various methods:","code":"# Linear detrending fd_linear <- detrend(fd_trend, method = \"linear\")  # Polynomial detrending (degree 2) fd_poly <- detrend(fd_trend, method = \"polynomial\", degree = 2)  # LOESS detrending (flexible, non-parametric) fd_loess <- detrend(fd_trend, method = \"loess\", bandwidth = 0.3)  # Automatic selection via AIC fd_auto <- detrend(fd_trend, method = \"auto\")  # Compare results cat(\"After detrending, estimated periods:\\n\") #> After detrending, estimated periods: cat(\"  Linear:     \", round(estimate.period(fd_linear)$period, 3), \"\\n\") #>   Linear:      2.506 cat(\"  Polynomial: \", round(estimate.period(fd_poly)$period, 3), \"\\n\") #>   Polynomial:  2.506 cat(\"  LOESS:      \", round(estimate.period(fd_loess)$period, 3), \"\\n\") #>   LOESS:       2.506 cat(\"  Auto:       \", round(estimate.period(fd_auto)$period, 3), \"(true: 2.5)\\n\") #>   Auto:        2.506 (true: 2.5)"},{"path":"https://sipemu.github.io/fdars-r/articles/seasonal-analysis.html","id":"getting-both-trend-and-detrended-data","dir":"Articles","previous_headings":"Handling Non-Stationary Data","what":"Getting Both Trend and Detrended Data","title":"Seasonal Analysis of Functional Data","text":"Use return_trend = TRUE get components:","code":"result <- detrend(fd_trend, method = \"linear\", return_trend = TRUE)  # Plot original, trend, and detrended df_decomp <- data.frame(   t = rep(t, 3),   y = c(fd_trend$data[1,], result$trend$data[1,], result$detrended$data[1,]),   Component = factor(rep(c(\"Original\", \"Trend\", \"Detrended\"), each = length(t)),                      levels = c(\"Original\", \"Trend\", \"Detrended\")) )  ggplot(df_decomp, aes(x = t, y = y)) +   geom_line(color = \"steelblue\") +   facet_wrap(~Component, ncol = 1, scales = \"free_y\") +   labs(title = \"Linear Detrending Result\",        x = \"Time\", y = \"Value\")"},{"path":"https://sipemu.github.io/fdars-r/articles/seasonal-analysis.html","id":"seasonal-trend-decomposition","dir":"Articles","previous_headings":"Handling Non-Stationary Data","what":"Seasonal-Trend Decomposition","title":"Seasonal Analysis of Functional Data","text":"full decomposition trend, seasonal, remainder components, use decompose():","code":"# Additive decomposition: data = trend + seasonal + remainder decomp <- decompose(fd_trend, period = 2.5, method = \"additive\")  # Plot all components df_stl <- data.frame(   t = rep(t, 4),   y = c(fd_trend$data[1,], decomp$trend$data[1,],         decomp$seasonal$data[1,], decomp$remainder$data[1,]),   Component = factor(rep(c(\"Original\", \"Trend\", \"Seasonal\", \"Remainder\"), each = length(t)),                      levels = c(\"Original\", \"Trend\", \"Seasonal\", \"Remainder\")) )  ggplot(df_stl, aes(x = t, y = y)) +   geom_line(color = \"steelblue\") +   facet_wrap(~Component, ncol = 1, scales = \"free_y\") +   labs(title = \"Additive Seasonal-Trend Decomposition\",        x = \"Time\", y = \"Value\")"},{"path":"https://sipemu.github.io/fdars-r/articles/seasonal-analysis.html","id":"multiplicative-seasonality","dir":"Articles","previous_headings":"Handling Non-Stationary Data","what":"Multiplicative Seasonality","title":"Seasonal Analysis of Functional Data","text":"seasonal amplitude grows trend level, use multiplicative decomposition:","code":"# Multiplicative pattern: amplitude grows with level + noise X_mult <- (2 + 0.3 * t) * (1 + 0.4 * sin(2 * pi * t / 2.5)) + rnorm(length(t), sd = 0.5) fd_mult <- fdata(matrix(X_mult, nrow = 1), argvals = t)  # Plot - note how peaks get taller over time df_mult <- data.frame(t = t, y = X_mult) ggplot(df_mult, aes(x = t, y = y)) +   geom_line(color = \"steelblue\") +   labs(title = \"Multiplicative Seasonality\",        subtitle = \"Seasonal amplitude grows with trend level\",        x = \"Time\", y = \"Value\") # Multiplicative decomposition decomp_mult <- decompose(fd_mult, period = 2.5, method = \"multiplicative\")  cat(\"Multiplicative decomposition:\\n\") #> Multiplicative decomposition: cat(\"  Seasonal range:\", round(range(decomp_mult$seasonal$data[1,]), 3), \"\\n\") #>   Seasonal range: 0.631 1.469 cat(\"  (Values near 1 indicate multiplicative factors)\\n\") #>   (Values near 1 indicate multiplicative factors)"},{"path":"https://sipemu.github.io/fdars-r/articles/seasonal-analysis.html","id":"integrated-detrending-in-other-functions","dir":"Articles","previous_headings":"Handling Non-Stationary Data","what":"Integrated Detrending in Other Functions","title":"Seasonal Analysis of Functional Data","text":"main seasonal functions support detrend_method parameter: detrend_method parameter available : - estimate.period() - accurate period estimation trending data - detect.peaks() - correct peak prominence calculation - seasonal.strength() - true seasonality measurement - detect.periods() - Uses “auto” default","code":"# These are equivalent: # 1. Explicit detrending fd_det <- detrend(fd_trend, method = \"linear\") p1 <- estimate.period(fd_det)$period  # 2. Integrated detrending parameter p2 <- estimate.period(fd_trend, detrend_method = \"linear\")$period  cat(\"Explicit detrend:\", round(p1, 3), \"\\n\") #> Explicit detrend: 2.506 cat(\"Integrated param:\", round(p2, 3), \"\\n\") #> Integrated param: 2.506 # Dramatic improvement with detrending cat(\"\\nSeasonal strength comparison:\\n\") #>  #> Seasonal strength comparison: cat(\"  Without detrend:\", round(seasonal.strength(fd_trend, period = 2.5), 3), \"\\n\") #>   Without detrend: 0.005 cat(\"  With detrend:   \", round(seasonal.strength(fd_trend, period = 2.5,                                                    detrend_method = \"linear\"), 3), \"\\n\") #>   With detrend:    0.834"},{"path":"https://sipemu.github.io/fdars-r/articles/seasonal-analysis.html","id":"peak-detection-with-detrending","dir":"Articles","previous_headings":"Handling Non-Stationary Data","what":"Peak Detection with Detrending","title":"Seasonal Analysis of Functional Data","text":"Trends also affect peak detection - upward slope can distort prominence calculations make later peaks appear prominent earlier ones.  Detrending especially important : - Peaks near start/end series different prominence due trend - need consistent peak--peak period estimates - trend slope comparable larger seasonal amplitude","code":"# Detect peaks without detrending peaks_no_detrend <- detect.peaks(fd_trend, min_distance = 2, smooth_first = TRUE)  # Detect peaks with detrending peaks_with_detrend <- detect.peaks(fd_trend, min_distance = 2, smooth_first = TRUE,                                     detrend_method = \"linear\")  cat(\"Peak detection on trending data:\\n\") #> Peak detection on trending data: cat(\"  Without detrend:\", nrow(peaks_no_detrend$peaks[[1]]), \"peaks,\",     \"mean period:\", round(peaks_no_detrend$mean_period, 3), \"\\n\") #>   Without detrend: 5 peaks, mean period: 4.398 cat(\"  With detrend:   \", nrow(peaks_with_detrend$peaks[[1]]), \"peaks,\",     \"mean period:\", round(peaks_with_detrend$mean_period, 3), \"(true: 2.5)\\n\") #>   With detrend:    8 peaks, mean period: 2.506 (true: 2.5) # Visualize the difference peaks_raw <- peaks_no_detrend$peaks[[1]] peaks_det <- peaks_with_detrend$peaks[[1]]  # Get detrended data for plotting fd_detrended <- detrend(fd_trend, method = \"linear\")  df_peaks <- data.frame(   t = rep(t, 2),   y = c(fd_trend$data[1,], fd_detrended$data[1,]),   Panel = factor(rep(c(\"Original (with trend)\", \"Detrended\"), each = length(t)),                  levels = c(\"Original (with trend)\", \"Detrended\")) )  # Combine peak data peaks_raw$Panel <- \"Original (with trend)\" peaks_det$Panel <- \"Detrended\" # Adjust detrended peak values to match detrended data peaks_det$value <- fd_detrended$data[1, sapply(peaks_det$time, function(x) which.min(abs(t - x)))] peaks_combined <- rbind(peaks_raw, peaks_det) peaks_combined$Panel <- factor(peaks_combined$Panel,                                 levels = c(\"Original (with trend)\", \"Detrended\"))  ggplot(df_peaks, aes(x = t, y = y)) +   geom_line(color = \"steelblue\", alpha = 0.7) +   geom_point(data = peaks_combined, aes(x = time, y = value),              color = \"red\", size = 2) +   facet_wrap(~Panel, ncol = 1, scales = \"free_y\") +   labs(title = \"Peak Detection: With vs Without Detrending\",        subtitle = \"Detrending ensures consistent peak detection across the series\",        x = \"Time\", y = \"Value\")"},{"path":"https://sipemu.github.io/fdars-r/articles/seasonal-analysis.html","id":"choosing-a-detrending-method","dir":"Articles","previous_headings":"Handling Non-Stationary Data","what":"Choosing a Detrending Method","title":"Seasonal Analysis of Functional Data","text":"Recommendation: Start \"linear\" cases. Use \"auto\" unsure. Use \"loess\" complex trends polynomial methods capture.","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/seasonal-analysis.html","id":"peak-detection","dir":"Articles","previous_headings":"","what":"Peak Detection","title":"Seasonal Analysis of Functional Data","text":"Peak detection identifies local maxima seasonal signals. useful characterizing seasonal patterns estimating period peak--peak distances.","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/seasonal-analysis.html","id":"parameter-tuning-guide","dir":"Articles","previous_headings":"Peak Detection","what":"Parameter Tuning Guide","title":"Seasonal Analysis of Functional Data","text":"Peak detection quality depends heavily parameters. ’s reference:","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/seasonal-analysis.html","id":"effect-of-parameters","dir":"Articles","previous_headings":"Peak Detection","what":"Effect of Parameters","title":"Seasonal Analysis of Functional Data","text":"Let’s demonstrate parameters affect detection quality.","code":"# Moderately noisy signal X_demo <- sin(2 * pi * t / period_true) + rnorm(length(t), sd = 0.4) fd_demo <- fdata(matrix(X_demo, nrow = 1), argvals = t)  df <- data.frame(t = t, y = X_demo)"},{"path":"https://sipemu.github.io/fdars-r/articles/seasonal-analysis.html","id":"visualizing-the-smoothing-step","dir":"Articles","previous_headings":"Peak Detection","what":"Visualizing the Smoothing Step","title":"Seasonal Analysis of Functional Data","text":"detecting peaks, let’s see Fourier basis smoothing noisy data:  Fourier basis smoothing ideal seasonal signals naturally captures periodic patterns. Peak detection smoothed data find true peaks, noise spikes.","code":"# Apply Fourier basis smoothing with CV-selected optimal nbasis cv_result <- fdata2basis_cv(fd_demo, nbasis.range = 5:25, type = \"fourier\", criterion = \"GCV\") fd_smoothed <- cv_result$fitted  # Compare original vs smoothed df_smooth <- data.frame(   t = rep(t, 2),   y = c(X_demo, fd_smoothed$data[1, ]),   type = rep(c(\"Original (noisy)\", \"Smoothed (Fourier)\"), each = length(t)) )  ggplot(df_smooth, aes(x = t, y = y, color = type)) +   geom_line(linewidth = 0.8) +   scale_color_manual(values = c(\"Original (noisy)\" = \"gray50\",                                  \"Smoothed (Fourier)\" = \"steelblue\")) +   labs(title = \"Effect of Fourier Basis Smoothing on Noisy Signal\",        subtitle = paste(\"CV-selected optimal nbasis =\", cv_result$optimal.nbasis),        x = \"Time\", y = \"Value\", color = NULL) +   theme(legend.position = \"bottom\") # Default parameters - often too many peaks peaks_default <- detect.peaks(fd_demo) cat(\"Default parameters:\", nrow(peaks_default$peaks[[1]]), \"peaks found\\n\") #> Default parameters: 96 peaks found cat(\"(Expected:\", floor(max(t) / period_true), \"peaks)\\n\") #> (Expected: 10 peaks) # Add minimum distance constraint peaks_distance <- detect.peaks(fd_demo, min_distance = period_true * 0.8) cat(\"With min_distance:\", nrow(peaks_distance$peaks[[1]]), \"peaks found\\n\") #> With min_distance: 12 peaks found # Add Fourier smoothing for best results (GCV auto-selects nbasis) peaks_smooth <- detect.peaks(fd_demo, min_distance = period_true * 0.8,                              smooth_first = TRUE, smooth_nbasis = NULL) cat(\"With smoothing:\", nrow(peaks_smooth$peaks[[1]]), \"peaks found\\n\") #> With smoothing: 10 peaks found cat(\"Estimated period from peaks:\", round(peaks_smooth$mean_period, 3), \"\\n\") #> Estimated period from peaks: 1.999"},{"path":"https://sipemu.github.io/fdars-r/articles/seasonal-analysis.html","id":"visualizing-the-difference","dir":"Articles","previous_headings":"Peak Detection","what":"Visualizing the Difference","title":"Seasonal Analysis of Functional Data","text":"peak detection noisy signals challenging: Noise creates many local maxima true peaks. Without smoothing, peak detection algorithms struggle distinguish genuine seasonal peaks random fluctuations. min_distance parameter helps, fully solve problem noise amplitude comparable signal. Key insight: seasonal data, use Fourier basis smoothing smooth_first = TRUE. Fourier basis ideal periodic signals naturally captures oscillatory patterns suppressing noise. GCV automatically selects optimal number basis functions, balancing smoothness fidelity data.","code":"# Prepare data for plotting df_default <- peaks_default$peaks[[1]] df_distance <- peaks_distance$peaks[[1]] df_smooth <- peaks_smooth$peaks[[1]]  # Create combined plot p1 <- ggplot(df, aes(x = t, y = y)) +   geom_line(color = \"gray50\", alpha = 0.7) +   geom_point(data = df_default, aes(x = time, y = value),              color = \"red\", size = 2) +   labs(title = paste(\"Default:\", nrow(df_default), \"peaks\"),        x = \"\", y = \"Value\")  p2 <- ggplot(df, aes(x = t, y = y)) +   geom_line(color = \"gray50\", alpha = 0.7) +   geom_point(data = df_distance, aes(x = time, y = value),              color = \"red\", size = 2) +   labs(title = paste(\"With min_distance:\", nrow(df_distance), \"peaks\"),        x = \"\", y = \"Value\")  p3 <- ggplot(df, aes(x = t, y = y)) +   geom_line(color = \"gray50\", alpha = 0.7) +   geom_point(data = df_smooth, aes(x = time, y = value),              color = \"red\", size = 2) +   labs(title = paste(\"With smoothing:\", nrow(df_smooth), \"peaks\"),        x = \"Time\", y = \"Value\")  library(gridExtra) grid.arrange(p1, p2, p3, ncol = 1)"},{"path":"https://sipemu.github.io/fdars-r/articles/seasonal-analysis.html","id":"prominence-filtering","dir":"Articles","previous_headings":"Peak Detection","what":"Prominence Filtering","title":"Seasonal Analysis of Functional Data","text":"Prominence measures much peak stands surrounding values. Use filter minor peaks. best results noisy data, combine prominence filtering smoothing. smoothing applied first, prominence values become meaningful reflect actual signal characteristics rather noise artifacts.","code":"# Compare prominence thresholds without smoothing (less reliable) peaks_low_prom_raw <- detect.peaks(fd_demo, min_distance = 1.5, min_prominence = 0.1) peaks_high_prom_raw <- detect.peaks(fd_demo, min_distance = 1.5, min_prominence = 0.5)  cat(\"Without smoothing:\\n\") #> Without smoothing: cat(\"  Low prominence (0.1):\", nrow(peaks_low_prom_raw$peaks[[1]]), \"peaks\\n\") #>   Low prominence (0.1): 7 peaks cat(\"  High prominence (0.5):\", nrow(peaks_high_prom_raw$peaks[[1]]), \"peaks\\n\") #>   High prominence (0.5): 1 peaks  # With smoothing - more reliable results peaks_low_prom <- detect.peaks(fd_demo, min_distance = 1.5, min_prominence = 0.1,                                 smooth_first = TRUE) peaks_high_prom <- detect.peaks(fd_demo, min_distance = 1.5, min_prominence = 0.5,                                  smooth_first = TRUE)  cat(\"\\nWith smoothing:\\n\") #>  #> With smoothing: cat(\"  Low prominence (0.1):\", nrow(peaks_low_prom$peaks[[1]]), \"peaks\\n\") #>   Low prominence (0.1): 4 peaks cat(\"  High prominence (0.5):\", nrow(peaks_high_prom$peaks[[1]]), \"peaks\\n\") #>   High prominence (0.5): 4 peaks"},{"path":"https://sipemu.github.io/fdars-r/articles/seasonal-analysis.html","id":"different-signal-amplitudes","dir":"Articles","previous_headings":"Peak Detection","what":"Different Signal Amplitudes","title":"Seasonal Analysis of Functional Data","text":"Peak detection works correctly regardless signal amplitude. algorithm normalizes internally based local signal characteristics.  four signals correctly detect 5 peaks, peak values matching respective amplitudes.","code":"t <- seq(0, 10, length.out = 200) amplitudes <- c(0.5, 1.0, 2.0, 5.0)  # Create plots for each amplitude amplitude_plots <- lapply(amplitudes, function(amp) {   X <- matrix(amp * sin(2 * pi * t / 2), nrow = 1)   fd <- fdata(X, argvals = t)   result <- detect.peaks(fd)   peaks <- result$peaks[[1]]    df <- data.frame(t = t, y = X[1,])   ggplot(df, aes(x = t, y = y)) +     geom_line(color = \"steelblue\") +     geom_point(data = peaks, aes(x = time, y = value),                color = \"red\", size = 3) +     labs(title = paste(\"Amplitude =\", amp, \"- Found\", nrow(peaks), \"peaks\"),          x = \"Time\", y = \"Value\") })  library(gridExtra) grid.arrange(grobs = amplitude_plots, ncol = 2)"},{"path":"https://sipemu.github.io/fdars-r/articles/seasonal-analysis.html","id":"non-uniform-peak-spacing","dir":"Articles","previous_headings":"Peak Detection","what":"Non-Uniform Peak Spacing","title":"Seasonal Analysis of Functional Data","text":"Real-world signals often varying frequencies complex interference patterns. detect.peaks handles cases analyzing local signal structure.","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/seasonal-analysis.html","id":"chirp-signal-increasing-frequency","dir":"Articles","previous_headings":"Peak Detection > Non-Uniform Peak Spacing","what":"Chirp Signal (Increasing Frequency)","title":"Seasonal Analysis of Functional Data","text":"chirp signal frequency increases time, causing peaks get progressively closer together.","code":"t <- seq(0, 10, length.out = 400) # Phase integral for linearly increasing frequency: phi(t) = 2*pi*(0.5*t + 0.05*t^2) phase <- 2 * pi * (0.5 * t + 0.05 * t^2) X <- matrix(sin(phase), nrow = 1) fd <- fdata(X, argvals = t)  result <- detect.peaks(fd) peaks <- result$peaks[[1]]  # Plot df <- data.frame(t = t, y = X[1,]) ggplot(df, aes(x = t, y = y)) +   geom_line(color = \"steelblue\") +   geom_point(data = peaks, aes(x = time, y = value),              color = \"red\", size = 3) +   labs(title = \"Chirp Signal: Frequency Increases Over Time\",        subtitle = paste(\"Detected\", nrow(peaks), \"peaks with decreasing spacing\"),        x = \"Time\", y = \"Value\") # Show inter-peak distances decreasing over time distances <- result$inter_peak_distances[[1]] if (length(distances) >= 2) {   df_dist <- data.frame(     peak_pair = seq_along(distances),     distance = distances   )   ggplot(df_dist, aes(x = peak_pair, y = distance)) +     geom_point(size = 3, color = \"steelblue\") +     geom_line(linetype = \"dashed\", color = \"gray50\") +     labs(title = \"Inter-Peak Distances Decrease Over Time\",          x = \"Peak Pair (sequential)\", y = \"Distance\") }"},{"path":"https://sipemu.github.io/fdars-r/articles/seasonal-analysis.html","id":"sum-of-sine-waves-interference-pattern","dir":"Articles","previous_headings":"Peak Detection > Non-Uniform Peak Spacing","what":"Sum of Sine Waves (Interference Pattern)","title":"Seasonal Analysis of Functional Data","text":"two sine waves different periods combined, create interference pattern non-uniform peak spacing.  peak detection algorithm correctly identifies local maxima even underlying signal complex structure varying peak--peak distances.","code":"t <- seq(0, 12, length.out = 300) # Sum of periods 2 and 3 X <- matrix(sin(2 * pi * t / 2) + 0.5 * sin(2 * pi * t / 3), nrow = 1) fd <- fdata(X, argvals = t)  result <- detect.peaks(fd, min_distance = 1.0) peaks <- result$peaks[[1]]  # Plot df <- data.frame(t = t, y = X[1,]) ggplot(df, aes(x = t, y = y)) +   geom_line(color = \"steelblue\") +   geom_point(data = peaks, aes(x = time, y = value),              color = \"red\", size = 3) +   labs(title = \"Sum of Two Sine Waves (periods 2 and 3)\",        subtitle = paste(\"Detected\", nrow(peaks), \"peaks with varying spacing\"),        x = \"Time\", y = \"Value\") # Show variable inter-peak distances distances <- result$inter_peak_distances[[1]] cat(\"Inter-peak distances:\", round(distances, 2), \"\\n\") #> Inter-peak distances: 2.01 1.85 2.17 2.01 1.81 cat(\"Range:\", round(min(distances), 2), \"to\", round(max(distances), 2), \"\\n\") #> Range: 1.81 to 2.17"},{"path":"https://sipemu.github.io/fdars-r/articles/seasonal-analysis.html","id":"measuring-seasonal-strength","dir":"Articles","previous_headings":"","what":"Measuring Seasonal Strength","title":"Seasonal Analysis of Functional Data","text":"Seasonal strength quantifies much signal’s variance explained seasonal component. Values range 0 (seasonality) 1 (pure seasonal signal).","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/seasonal-analysis.html","id":"variance-vs-spectral-methods","dir":"Articles","previous_headings":"Measuring Seasonal Strength","what":"Variance vs Spectral Methods","title":"Seasonal Analysis of Functional Data","text":"","code":"ss_variance <- seasonal.strength(fd_noisy, period = period_true, method = \"variance\") ss_spectral <- seasonal.strength(fd_noisy, period = period_true, method = \"spectral\")  cat(\"Variance method:\", round(ss_variance, 3), \"\\n\") #> Variance method: 0.863 cat(\"Spectral method:\", round(ss_spectral, 3), \"\\n\") #> Spectral method: 0.893"},{"path":"https://sipemu.github.io/fdars-r/articles/seasonal-analysis.html","id":"comparing-different-signal-types","dir":"Articles","previous_headings":"Measuring Seasonal Strength","what":"Comparing Different Signal Types","title":"Seasonal Analysis of Functional Data","text":"","code":"# Create signals with different seasonality levels X_noise <- rnorm(length(t))  # Pure noise fd_noise <- fdata(matrix(X_noise, nrow = 1), argvals = t)  X_mixed <- 0.5 * sin(2 * pi * t / period_true) + 0.5 * rnorm(length(t)) fd_mixed <- fdata(matrix(X_mixed, nrow = 1), argvals = t)  # Calculate strengths strengths <- c(   \"Pure seasonal\" = seasonal.strength(fd_pure, period = period_true),   \"Noisy seasonal (0.3 SD)\" = seasonal.strength(fd_noisy, period = period_true),   \"Mixed (50/50)\" = seasonal.strength(fd_mixed, period = period_true),   \"Pure noise\" = seasonal.strength(fd_noise, period = period_true) )  df_strength <- data.frame(   Signal = factor(names(strengths), levels = names(strengths)),   Strength = strengths )  ggplot(df_strength, aes(x = Signal, y = Strength, fill = Signal)) +   geom_col() +   labs(title = \"Seasonal Strength Comparison\",        x = \"\", y = \"Seasonal Strength\") +   ylim(0, 1) +   theme(legend.position = \"none\",         axis.text.x = element_text(angle = 15, hjust = 1))"},{"path":"https://sipemu.github.io/fdars-r/articles/seasonal-analysis.html","id":"time-varying-seasonal-strength","dir":"Articles","previous_headings":"Measuring Seasonal Strength","what":"Time-Varying Seasonal Strength","title":"Seasonal Analysis of Functional Data","text":"Seasonal strength can change time. Use sliding window track .","code":"# Signal that loses seasonality t_long <- seq(0, 40, length.out = 800) X_changing <- ifelse(t_long < 20,                      sin(2 * pi * t_long / period_true) + rnorm(sum(t_long < 20), sd = 0.2),                      rnorm(sum(t_long >= 20), sd = 0.5)) fd_changing <- fdata(matrix(X_changing, nrow = 1), argvals = t_long)  # Compute time-varying strength ss_curve <- seasonal.strength.curve(fd_changing, period = period_true,                                      window_size = 4 * period_true)  # Plot both signal and strength df1 <- data.frame(t = t_long, y = X_changing, panel = \"Signal\") df2 <- data.frame(t = t_long, y = ss_curve$data[1,], panel = \"Seasonal Strength\") df_combined <- rbind(df1, df2)  ggplot(df_combined, aes(x = t, y = y)) +   geom_line(color = \"steelblue\") +   facet_wrap(~panel, ncol = 1, scales = \"free_y\") +   geom_vline(xintercept = 20, linetype = \"dashed\", color = \"red\") +   labs(title = \"Time-Varying Seasonal Strength\",        subtitle = \"Seasonality stops at t = 20 (red line)\",        x = \"Time\", y = \"\")"},{"path":"https://sipemu.github.io/fdars-r/articles/seasonal-analysis.html","id":"change-detection","dir":"Articles","previous_headings":"","what":"Change Detection","title":"Seasonal Analysis of Functional Data","text":"Automatically detect seasonality starts stops.","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/seasonal-analysis.html","id":"manual-threshold","dir":"Articles","previous_headings":"Change Detection","what":"Manual Threshold","title":"Seasonal Analysis of Functional Data","text":"","code":"changes <- detect.seasonality.changes(fd_changing, period = period_true,                                        threshold = 0.3,                                        window_size = 4 * period_true,                                        min_duration = 2 * period_true) print(changes) #> Seasonality Change Detection #> ---------------------------- #> Number of changes: 1 #>  #>       time      type strength_before strength_after #> 1 20.47559 cessation       0.3152373      0.2918658"},{"path":"https://sipemu.github.io/fdars-r/articles/seasonal-analysis.html","id":"automatic-threshold-otsus-method","dir":"Articles","previous_headings":"Change Detection","what":"Automatic Threshold (Otsu’s Method)","title":"Seasonal Analysis of Functional Data","text":"don’t know appropriate threshold, use Otsu’s method determine automatically data.","code":"changes_auto <- detect.seasonality.changes.auto(fd_changing, period = period_true,                                                  threshold_method = \"otsu\") print(changes_auto) #> Seasonality Change Detection (Auto Threshold) #> ---------------------------------------------- #> Computed threshold: 0.5047 #> Number of changes: 1 #>  #>       time      type strength_before strength_after #> 1 19.52441 cessation       0.5087545      0.5030707"},{"path":"https://sipemu.github.io/fdars-r/articles/seasonal-analysis.html","id":"visualizing-change-points","dir":"Articles","previous_headings":"Change Detection","what":"Visualizing Change Points","title":"Seasonal Analysis of Functional Data","text":"","code":"df <- data.frame(t = t_long, y = X_changing)  p <- ggplot(df, aes(x = t, y = y)) +   geom_line(color = \"steelblue\", alpha = 0.7) +   labs(title = \"Seasonality Change Detection\",        x = \"Time\", y = \"Value\")  # Add change points if (nrow(changes_auto$change_points) > 0) {   for (i in 1:nrow(changes_auto$change_points)) {     cp <- changes_auto$change_points[i, ]     p <- p + geom_vline(xintercept = cp$time,                         linetype = \"dashed\",                         color = ifelse(cp$type == \"onset\", \"green4\", \"red\"),                         linewidth = 1)   }   p <- p + labs(subtitle = \"Green = onset, Red = cessation\") } print(p)"},{"path":"https://sipemu.github.io/fdars-r/articles/seasonal-analysis.html","id":"signals-with-varying-period","dir":"Articles","previous_headings":"","what":"Signals with Varying Period","title":"Seasonal Analysis of Functional Data","text":"signals periods drift change time. instantaneous.period() function uses Hilbert transform estimate period time point.","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/seasonal-analysis.html","id":"when-to-use-instantaneous-period","dir":"Articles","previous_headings":"Signals with Varying Period","what":"When to Use Instantaneous Period","title":"Seasonal Analysis of Functional Data","text":"Good use cases: Slowly drifting systems (circadian rhythms shifting seasons) Frequency-modulated (FM) signals engineering Climate oscillations variable period (e.g., ENSO) Poor use cases: Random frequency jumps (use change detection instead) Multiple concurrent periodicities (use iterative approach instead) noisy short series (use peak--peak methods instead)","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/seasonal-analysis.html","id":"chirp-signal-smoothly-increasing-frequency","dir":"Articles","previous_headings":"Signals with Varying Period","what":"Chirp Signal (Smoothly Increasing Frequency)","title":"Seasonal Analysis of Functional Data","text":"","code":"# Chirp: frequency increases linearly t_chirp <- seq(0, 10, length.out = 500) freq <- 0.5 + 0.15 * t_chirp  # Frequency increases from 0.5 to 2 phase <- 2 * pi * cumsum(freq) * diff(c(0, t_chirp)) X_chirp <- sin(phase) fd_chirp <- fdata(matrix(X_chirp, nrow = 1), argvals = t_chirp)  df <- data.frame(t = t_chirp, y = X_chirp) ggplot(df, aes(x = t, y = y)) +   geom_line(color = \"steelblue\") +   labs(title = \"Chirp Signal (Smoothly Increasing Frequency)\",        x = \"Time\", y = \"Value\") inst <- instantaneous.period(fd_chirp)  # True period (1/frequency) true_period <- 1 / freq  # Compare df <- data.frame(   t = t_chirp,   Estimated = inst$period$data[1,],   True = true_period )  # Remove extreme values at boundaries df$Estimated[df$Estimated > 5 | df$Estimated < 0] <- NA  ggplot(df, aes(x = t)) +   geom_line(aes(y = True, color = \"True\"), linewidth = 1) +   geom_line(aes(y = Estimated, color = \"Estimated\"), alpha = 0.7) +   scale_color_manual(values = c(\"True\" = \"steelblue\", \"Estimated\" = \"coral\")) +   labs(title = \"Instantaneous Period Estimation\",        x = \"Time\", y = \"Period\", color = \"\") +   ylim(0, 3)"},{"path":"https://sipemu.github.io/fdars-r/articles/seasonal-analysis.html","id":"amplitude-envelope-extraction","dir":"Articles","previous_headings":"Signals with Varying Period","what":"Amplitude Envelope Extraction","title":"Seasonal Analysis of Functional Data","text":"Hilbert transform also provides instantaneous amplitude (envelope), useful amplitude-modulated signals.","code":"# Amplitude-modulated signal envelope_true <- 1 + 0.5 * sin(2 * pi * t / 10)  # Slow modulation X_am <- envelope_true * sin(2 * pi * t / period_true) fd_am <- fdata(matrix(X_am, nrow = 1), argvals = t)  inst_am <- instantaneous.period(fd_am)  df <- data.frame(   t = t,   Signal = X_am,   Envelope = inst_am$amplitude$data[1,] )  ggplot(df, aes(x = t)) +   geom_line(aes(y = Signal), color = \"steelblue\", alpha = 0.7) +   geom_line(aes(y = Envelope), color = \"red\", linewidth = 1) +   geom_line(aes(y = -Envelope), color = \"red\", linewidth = 1) +   labs(title = \"Amplitude Envelope Extraction\",        subtitle = \"Red lines show the extracted envelope\",        x = \"Time\", y = \"Value\")"},{"path":"https://sipemu.github.io/fdars-r/articles/seasonal-analysis.html","id":"limitations-and-alternatives","dir":"Articles","previous_headings":"Signals with Varying Period","what":"Limitations and Alternatives","title":"Seasonal Analysis of Functional Data","text":"Boundary effects: Hilbert transform produces unreliable estimates near beginning end series. Noise sensitivity: High-frequency noise can corrupt period estimates. Consider smoothing first. Random frequency changes: frequency changes abruptly randomly, instantaneous period estimate becomes unreliable.  Alternative abrupt changes: Use detect.seasonality.changes() find regime boundaries, analyze segment separately.","code":"# Demonstrate limitation: signal with random frequency regime changes set.seed(123) t_rand <- seq(0, 20, length.out = 400) freq_regime <- rep(c(1, 2, 0.5, 1.5), each = 100)  # Abrupt changes X_rand <- sin(2 * pi * cumsum(freq_regime) * diff(c(0, t_rand))) fd_rand <- fdata(matrix(X_rand, nrow = 1), argvals = t_rand)  inst_rand <- instantaneous.period(fd_rand) est_period <- inst_rand$period$data[1,] est_period[est_period > 5 | est_period < 0.1] <- NA  df <- data.frame(   t = t_rand,   True = 1/freq_regime,   Estimated = est_period )  ggplot(df, aes(x = t)) +   geom_step(aes(y = True, color = \"True\"), linewidth = 1) +   geom_line(aes(y = Estimated, color = \"Estimated\"), alpha = 0.7) +   scale_color_manual(values = c(\"True\" = \"steelblue\", \"Estimated\" = \"coral\")) +   labs(title = \"Limitation: Abrupt Frequency Changes\",        subtitle = \"Hilbert transform struggles with discontinuities\",        x = \"Time\", y = \"Period\", color = \"\")"},{"path":"https://sipemu.github.io/fdars-r/articles/seasonal-analysis.html","id":"working-with-short-series","dir":"Articles","previous_headings":"","what":"Working with Short Series","title":"Seasonal Analysis of Functional Data","text":"short series 3-5 complete cycles, fdars provides specialized functions analyzing peak timing variability classifying seasonality.","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/seasonal-analysis.html","id":"challenges-with-few-cycles","dir":"Articles","previous_headings":"Working with Short Series","what":"Challenges with Few Cycles","title":"Seasonal Analysis of Functional Data","text":"Period estimation limited frequency resolution Statistical measures high uncertainty Peak--peak analysis becomes important","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/seasonal-analysis.html","id":"peak-timing-variability","dir":"Articles","previous_headings":"Working with Short Series","what":"Peak Timing Variability","title":"Seasonal Analysis of Functional Data","text":"Detect shifts peak timing cycles (e.g., phenological event shifting March April May several years).","code":"# Simulate 5 years where peak timing shifts t_short <- seq(0, 5, length.out = 500) period_short <- 1  # Peaks shift gradually later each year phase_shifts <- c(0, 0.05, 0.10, 0.08, 0.04) X_short <- rep(0, length(t_short)) for (i in 1:length(t_short)) {   year <- floor(t_short[i]) + 1   year <- min(year, 5)   X_short[i] <- sin(2 * pi * (t_short[i] + phase_shifts[year]) / period_short) } X_short <- X_short + rnorm(length(t_short), sd = 0.1)  fd_short <- fdata(matrix(X_short, nrow = 1), argvals = t_short) # Plot the short series df_short <- data.frame(t = t_short, y = X_short) ggplot(df_short, aes(x = t, y = y)) +   geom_line(color = \"steelblue\") +   geom_vline(xintercept = 0:5, linetype = \"dotted\", alpha = 0.5) +   labs(title = \"5-Year Series with Variable Peak Timing\",        x = \"Year\", y = \"Value\") # Analyze peak timing timing <- analyze.peak.timing(fd_short, period = period_short) print(timing) #> Peak Timing Variability Analysis #> --------------------------------- #> Number of peaks: 5 #> Mean timing:     0.1924 #> Std timing:      0.0364 #> Range timing:    0.1062 #> Variability:     0.3640 (moderate) #> Timing trend:    -0.0110"},{"path":"https://sipemu.github.io/fdars-r/articles/seasonal-analysis.html","id":"visualizing-peak-timing","dir":"Articles","previous_headings":"Working with Short Series","what":"Visualizing Peak Timing","title":"Seasonal Analysis of Functional Data","text":"","code":"# Get detected peaks with Fourier smoothing peaks_short <- detect.peaks(fd_short, min_distance = 0.7,                             smooth_first = TRUE, smooth_nbasis = NULL) peak_df <- peaks_short$peaks[[1]]  # Plot with peaks marked ggplot(df_short, aes(x = t, y = y)) +   geom_line(color = \"steelblue\") +   geom_point(data = peak_df, aes(x = time, y = value),              color = \"red\", size = 3) +   geom_vline(xintercept = 0:5, linetype = \"dotted\", alpha = 0.5) +   labs(title = \"5-Year Series with Detected Peaks\",        x = \"Year\", y = \"Value\") # Plot peak timing within each year if (nrow(peak_df) >= 3) {   peak_years <- floor(peak_df$time)   peak_phase <- peak_df$time - peak_years    df_timing <- data.frame(     year = peak_years + 1,     phase = peak_phase   )    ggplot(df_timing, aes(x = year, y = phase)) +     geom_point(size = 4, color = \"steelblue\") +     geom_line(linetype = \"dashed\", color = \"gray50\") +     labs(title = \"Peak Timing Variability Across Years\",          x = \"Year\", y = \"Phase within Year\") +     ylim(0, 1) }"},{"path":"https://sipemu.github.io/fdars-r/articles/seasonal-analysis.html","id":"seasonality-classification","dir":"Articles","previous_headings":"Working with Short Series","what":"Seasonality Classification","title":"Seasonal Analysis of Functional Data","text":"Automatically classify type seasonality pattern.","code":"class_result <- classify.seasonality(fd_short, period = period_short) print(class_result) #> Seasonality Classification #> -------------------------- #> Classification:   StableSeasonal #> Is seasonal:      TRUE #> Stable timing:    TRUE #> Timing variability: 0.3640 #> Seasonal strength:  0.9351 # Visualize classification metrics # Normalize timing variability to 0-1 scale (lower is better/more stable) stability_score <- 1 - min(1, class_result$timing_variability / 0.2)  class_df <- data.frame(   Metric = c(\"Seasonal Strength\", \"Timing Stability\"),   Value = c(class_result$seasonal_strength, stability_score) )  ggplot(class_df, aes(x = Metric, y = Value, fill = Metric)) +   geom_col() +   ylim(0, 1) +   labs(title = paste(\"Classification:\", class_result$classification),        x = \"\", y = \"Score\") +   scale_fill_brewer(palette = \"Set2\") +   theme(legend.position = \"none\")"},{"path":"https://sipemu.github.io/fdars-r/articles/seasonal-analysis.html","id":"classification-types","dir":"Articles","previous_headings":"Working with Short Series","what":"Classification Types","title":"Seasonal Analysis of Functional Data","text":"classify.seasonality() function returns one four classifications based seasonal strength timing variability:","code":"# Example: Stable seasonality - clean signal with consistent timing X_stable <- sin(2 * pi * t_short / period_short) + rnorm(length(t_short), sd = 0.05) fd_stable <- fdata(matrix(X_stable, nrow = 1), argvals = t_short) class_stable <- classify.seasonality(fd_stable, period = period_short)  # Example: Variable seasonality - amplitude and timing drift phase_var <- seq(0, 0.2, length.out = length(t_short)) amp_var <- 1 + 0.3 * sin(2 * pi * t_short / 3) X_variable <- amp_var * sin(2 * pi * (t_short + phase_var) / period_short) +               rnorm(length(t_short), sd = 0.2) fd_variable <- fdata(matrix(X_variable, nrow = 1), argvals = t_short) class_variable <- classify.seasonality(fd_variable, period = period_short)  # Example: Intermittent seasonality - pattern appears and disappears X_intermittent <- ifelse(t_short < 2 | t_short > 4,                          sin(2 * pi * t_short / period_short),                          rnorm(sum(t_short >= 2 & t_short <= 4), sd = 0.5)) X_intermittent <- X_intermittent + rnorm(length(t_short), sd = 0.15) fd_intermittent <- fdata(matrix(X_intermittent, nrow = 1), argvals = t_short) class_intermittent <- classify.seasonality(fd_intermittent, period = period_short)  # Example: No seasonality - pure noise X_none <- rnorm(length(t_short), sd = 1) fd_none <- fdata(matrix(X_none, nrow = 1), argvals = t_short) class_none <- classify.seasonality(fd_none, period = period_short)  # Summary cat(\"Classification results:\\n\") #> Classification results: cat(\"  Stable signal:      \", class_stable$classification,     \"(strength:\", round(class_stable$seasonal_strength, 2), \")\\n\") #>   Stable signal:       StableSeasonal (strength: 0.99 ) cat(\"  Variable signal:    \", class_variable$classification,     \"(strength:\", round(class_variable$seasonal_strength, 2), \")\\n\") #>   Variable signal:     VariableTiming (strength: 0.78 ) cat(\"  Intermittent signal:\", class_intermittent$classification,     \"(strength:\", round(class_intermittent$seasonal_strength, 2), \")\\n\") #>   Intermittent signal: IntermittentSeasonal (strength: 0.49 ) cat(\"  No seasonality:     \", class_none$classification,     \"(strength:\", round(class_none$seasonal_strength, 2), \")\\n\") #>   No seasonality:      NonSeasonal (strength: 0.01 ) # Visualize all four classification types df_examples <- data.frame(   t = rep(t_short, 4),   y = c(X_stable, X_variable, X_intermittent, X_none),   Type = factor(rep(c(\"Stable\", \"Variable\", \"Intermittent\", \"None\"),                     each = length(t_short)),                 levels = c(\"Stable\", \"Variable\", \"Intermittent\", \"None\")) )  ggplot(df_examples, aes(x = t, y = y)) +   geom_line(color = \"steelblue\") +   facet_wrap(~Type, ncol = 1, scales = \"free_y\") +   labs(title = \"Seasonality Classification Examples\",        x = \"Time\", y = \"Value\")"},{"path":"https://sipemu.github.io/fdars-r/articles/seasonal-analysis.html","id":"automatic-fourier-smoothing-for-short-series","dir":"Articles","previous_headings":"Working with Short Series","what":"Automatic Fourier Smoothing for Short Series","title":"Seasonal Analysis of Functional Data","text":"Peak detection automatic smoothing especially important noisy short series.","code":"# More noisy short series X_noisy_short <- sin(2 * pi * t_short / period_short) + rnorm(length(t_short), sd = 0.5) fd_noisy_short <- fdata(matrix(X_noisy_short, nrow = 1), argvals = t_short)  # Auto-select smoothing via Fourier basis CV cv_short <- fdata2basis_cv(fd_noisy_short, nbasis.range = 3:15, type = \"fourier\") peaks_auto <- detect.peaks(cv_short$fitted, min_distance = 0.7) cat(\"Peaks found with Fourier CV smoothing:\", nrow(peaks_auto$peaks[[1]]), \"\\n\") #> Peaks found with Fourier CV smoothing: 5 cat(\"Expected peaks:\", 5, \"\\n\") #> Expected peaks: 5 cat(\"Estimated period:\", round(peaks_auto$mean_period, 3), \"\\n\") #> Estimated period: 0.997"},{"path":"https://sipemu.github.io/fdars-r/articles/seasonal-analysis.html","id":"multiple-curves","dir":"Articles","previous_headings":"","what":"Multiple Curves","title":"Seasonal Analysis of Functional Data","text":"functions work multiple curves simultaneously.","code":"n_curves <- 5 t <- seq(0, 10, length.out = 200) periods <- seq(1.8, 2.2, length.out = n_curves)  # Slightly varying periods  X <- matrix(0, n_curves, length(t)) for (i in 1:n_curves) {   X[i, ] <- sin(2 * pi * t / periods[i]) + rnorm(length(t), sd = 0.2) }  fd_curves <- fdata(X, argvals = t)  # Plot all curves plot(fd_curves) +   labs(title = \"Multiple Seasonal Curves\",        x = \"Time\", y = \"Value\") # Period estimation uses the mean curve est_mean <- estimate.period(fd_curves, method = \"fft\") cat(\"Estimated period (from mean):\", est_mean$period, \"\\n\") #> Estimated period (from mean): 2.01005 cat(\"True mean period:\", mean(periods), \"\\n\") #> True mean period: 2  # Peak detection for each curve peaks_curves <- detect.peaks(fd_curves, min_distance = 1.5) cat(\"\\nMean period from peaks:\", peaks_curves$mean_period, \"\\n\") #>  #> Mean period from peaks: 1.730653  # Seasonal strength (aggregated) ss_curves <- seasonal.strength(fd_curves, period = 2) cat(\"Seasonal strength:\", round(ss_curves, 3), \"\\n\") #> Seasonal strength: 0.557"},{"path":[]},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/articles/seasonal-analysis.html","id":"decision-guide","dir":"Articles","previous_headings":"Summary","what":"Decision Guide","title":"Seasonal Analysis of Functional Data","text":"Non-stationary data (trends present): Linear trend: detrend(method = \"linear\") use detrend_method = \"linear\" parameter Complex/curved trend: detrend(method = \"loess\") method = \"auto\" Growing seasonal amplitude: decompose(method = \"multiplicative\") Full decomposition needed: decompose() returns trend + seasonal + remainder Period estimation: Period unknown, signal stable: estimate.period(method = \"fft\") Period unknown, data trend: estimate.period(detrend_method = \"linear\") Period unknown, multiple independent periods: detect.periods() Period varies smoothly time: instantaneous.period() Peak detection: Clean data: detect.peaks() default parameters Noisy data: Add smooth_first = TRUE (Fourier smoothing GCV-selected nbasis) Data trend: Add detrend_method = \"linear\" Still many peaks: Increase min_prominence Seasonal strength: Single measurement: seasonal.strength() Data trend: seasonal.strength(detrend_method = \"linear\") Track changes time: seasonal.strength.curve() Detect seasonality stops: detect.seasonality.changes.auto() Short series (3-5 cycles): Characterize timing shifts: analyze.peak.timing() Classify pattern type: classify.seasonality()","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/seasonal-analysis.html","id":"processing-large-numbers-of-series","dir":"Articles","previous_headings":"Summary","what":"Processing Large Numbers of Series","title":"Seasonal Analysis of Functional Data","text":"analyzing many series (e.g., 500k time series), use tiered approach balance speed depth analysis: Tier 1 - Fast screening (series): filters ~80% series clear seasonality typical mixed datasets. Tier 2 - Validation (remaining ~20%): Tier 3 - Full analysis (top candidates ): Parallelization: fdars Rust functions thread-safe. Use parallel::mclapply() future.apply::future_lapply() parallel processing: Memory management: Process batches 1000-5000 series Store summary results (period, confidence, classification) Stream data disk rather loading ","code":"# Quick FFT period estimation - very fast est <- estimate.period(fd, method = \"fft\") if (est$confidence < 0.3) return(\"no_seasonality\") # Add seasonal strength check ss <- seasonal.strength(fd, period = est$period) if (ss < 0.2) return(\"weak_seasonality\") # Expensive operations - classification, multiple periods class <- classify.seasonality(fd, period = est$period) periods <- detect.periods(fd)  # if multiple periods suspected # Example batch processing workflow library(parallel) results <- mclapply(series_list, function(fd) {   est <- estimate.period(fd, method = \"fft\")   if (est$confidence < 0.3) return(list(classification = \"none\"))   ss <- seasonal.strength(fd, period = est$period)   list(period = est$period, confidence = est$confidence, strength = ss) }, mc.cores = detectCores() - 1)"},{"path":"https://sipemu.github.io/fdars-r/articles/simulation-toolbox.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Simulating Functional Data","text":"fdars package provides comprehensive tools simulating functional data. useful : Method validation: Testing statistical methods data known properties Power analysis: Determining sample sizes effect sizes Teaching: Creating examples controlled characteristics Benchmarking: Comparing algorithm performance vignette covers Karhunen-Loeve simulation framework related tools.","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/simulation-toolbox.html","id":"karhunen-loeve-simulation","dir":"Articles","previous_headings":"","what":"Karhunen-Loeve Simulation","title":"Simulating Functional Data","text":"Karhunen-Loeve (KL) expansion represents stochastic process : X(t)=μ(t)+∑k=1∞ξkϕk(t) X(t) = \\mu(t) + \\sum_{k=1}^{\\infty} \\xi_k \\phi_k(t) : - μ(t)\\mu(t) mean function - ϕk(t)\\phi_k(t) orthonormal eigenfunctions - ξk∼N(0,λk)\\xi_k \\sim N(0, \\lambda_k) independent scores variances λk\\lambda_k simulation, truncate MM terms generate curves via simFunData().","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/simulation-toolbox.html","id":"basic-example","dir":"Articles","previous_headings":"Karhunen-Loeve Simulation","what":"Basic Example","title":"Simulating Functional Data","text":"","code":"# Define evaluation points t <- seq(0, 1, length.out = 100)  # Simulate 20 curves with 5 basis functions fd <- simFunData(n = 20, argvals = t, M = 5, seed = 42) autoplot(fd) + labs(title = \"Simulated Functional Data\")"},{"path":"https://sipemu.github.io/fdars-r/articles/simulation-toolbox.html","id":"reproducibility","dir":"Articles","previous_headings":"Karhunen-Loeve Simulation","what":"Reproducibility","title":"Simulating Functional Data","text":"Set seed reproducible results:","code":"fd1 <- simFunData(n = 5, argvals = t, M = 5, seed = 123) fd2 <- simFunData(n = 5, argvals = t, M = 5, seed = 123)  # Verify they're identical all.equal(fd1$data, fd2$data) #> [1] TRUE"},{"path":"https://sipemu.github.io/fdars-r/articles/simulation-toolbox.html","id":"eigenfunction-bases","dir":"Articles","previous_headings":"","what":"Eigenfunction Bases","title":"Simulating Functional Data","text":"shape simulated curves depends eigenfunction basis. Use eFun() generate different types.","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/simulation-toolbox.html","id":"fourier-basis","dir":"Articles","previous_headings":"Eigenfunction Bases","what":"Fourier Basis","title":"Simulating Functional Data","text":"Best periodic smooth oscillating data:","code":"phi_fourier <- eFun(t, M = 5, type = \"Fourier\") phi_df <- data.frame(t = rep(t, 5),                      phi = as.vector(phi_fourier),                      k = factor(rep(1:5, each = length(t)))) ggplot(phi_df, aes(x = t, y = phi, color = k)) +   geom_line(linewidth = 1) +   labs(title = \"Fourier Eigenfunctions\", x = \"t\", y = expression(phi(t)), color = \"k\") +   theme_minimal() fd_fourier <- simFunData(n = 20, argvals = t, M = 5,                          eFun.type = \"Fourier\", eVal.type = \"exponential\", seed = 42) autoplot(fd_fourier) + labs(title = \"Fourier Basis Simulation\")"},{"path":"https://sipemu.github.io/fdars-r/articles/simulation-toolbox.html","id":"legendre-polynomials","dir":"Articles","previous_headings":"Eigenfunction Bases","what":"Legendre Polynomials","title":"Simulating Functional Data","text":"Orthogonal polynomials [0, 1]:","code":"phi_poly <- eFun(t, M = 5, type = \"Poly\") phi_df <- data.frame(t = rep(t, 5),                      phi = as.vector(phi_poly),                      degree = factor(rep(0:4, each = length(t)))) ggplot(phi_df, aes(x = t, y = phi, color = degree)) +   geom_line(linewidth = 1) +   labs(title = \"Legendre Polynomial Eigenfunctions\", x = \"t\", y = expression(phi(t))) +   theme_minimal() fd_poly <- simFunData(n = 20, argvals = t, M = 5,                       eFun.type = \"Poly\", eVal.type = \"exponential\", seed = 42) autoplot(fd_poly) + labs(title = \"Polynomial Basis Simulation\")"},{"path":"https://sipemu.github.io/fdars-r/articles/simulation-toolbox.html","id":"wiener-process-eigenfunctions","dir":"Articles","previous_headings":"Eigenfunction Bases","what":"Wiener Process Eigenfunctions","title":"Simulating Functional Data","text":"Eigenfunctions Brownian motion covariance K(s,t)=min(s,t)K(s,t) = \\min(s,t):","code":"phi_wiener <- eFun(t, M = 5, type = \"Wiener\") phi_df <- data.frame(t = rep(t, 5),                      phi = as.vector(phi_wiener),                      k = factor(rep(1:5, each = length(t)))) ggplot(phi_df, aes(x = t, y = phi, color = k)) +   geom_line(linewidth = 1) +   labs(title = \"Wiener Process Eigenfunctions\", x = \"t\", y = expression(phi(t)), color = \"k\") +   theme_minimal() fd_wiener <- simFunData(n = 20, argvals = t, M = 10,                         eFun.type = \"Wiener\", eVal.type = \"wiener\", seed = 42) autoplot(fd_wiener) + labs(title = \"Wiener Process Simulation\")"},{"path":"https://sipemu.github.io/fdars-r/articles/simulation-toolbox.html","id":"eigenvalue-decay","dir":"Articles","previous_headings":"","what":"Eigenvalue Decay","title":"Simulating Functional Data","text":"eigenvalue sequence controls much mode contributes variance.","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/simulation-toolbox.html","id":"comparing-decay-patterns","dir":"Articles","previous_headings":"Eigenvalue Decay","what":"Comparing Decay Patterns","title":"Simulating Functional Data","text":"","code":"M <- 20 lambda_lin <- eVal(M, \"linear\")      # lambda_k = 1/k lambda_exp <- eVal(M, \"exponential\") # lambda_k = exp(-k) lambda_wie <- eVal(M, \"wiener\")      # lambda_k = 1/((k-0.5)*pi)^2  df_evals <- data.frame(   k = rep(1:M, 3),   lambda = c(lambda_lin, lambda_exp, lambda_wie),   type = rep(c(\"Linear\", \"Exponential\", \"Wiener\"), each = M) )  ggplot(df_evals, aes(x = k, y = lambda, color = type)) +   geom_line(linewidth = 1) +   geom_point() +   scale_y_log10() +   labs(title = \"Eigenvalue Decay Patterns\",        x = \"Mode k\", y = expression(lambda[k]),        color = \"Decay Type\") +   theme(legend.position = \"right\")"},{"path":"https://sipemu.github.io/fdars-r/articles/simulation-toolbox.html","id":"effect-on-curve-smoothness","dir":"Articles","previous_headings":"Eigenvalue Decay","what":"Effect on Curve Smoothness","title":"Simulating Functional Data","text":"Faster decay = smoother curves (higher modes contribute less):","code":"# Linear decay - rougher curves fd_lin <- simFunData(n = 10, argvals = t, M = 10,                      eFun.type = \"Fourier\", eVal.type = \"linear\", seed = 42) # Exponential decay - smoother curves fd_exp <- simFunData(n = 10, argvals = t, M = 10,                      eFun.type = \"Fourier\", eVal.type = \"exponential\", seed = 42)  p1 <- autoplot(fd_lin) + labs(title = \"Linear Decay (Rougher)\") p2 <- autoplot(fd_exp) + labs(title = \"Exponential Decay (Smoother)\") gridExtra::grid.arrange(p1, p2, ncol = 2)"},{"path":"https://sipemu.github.io/fdars-r/articles/simulation-toolbox.html","id":"adding-mean-function","dir":"Articles","previous_headings":"","what":"Adding Mean Function","title":"Simulating Functional Data","text":"Simulate data specified mean:","code":"# Define mean function mean_fn <- function(t) 2 * sin(2 * pi * t) + t  # Simulate with mean fd_mean <- simFunData(n = 30, argvals = t, M = 5, mean = mean_fn, seed = 42)  # Visualize with ggplot2 mean_df <- data.frame(t = t, mean = mean_fn(t)) autoplot(fd_mean) +   geom_line(data = mean_df, aes(x = t, y = mean), color = \"red\", linewidth = 1.5, inherit.aes = FALSE) +   labs(title = \"Simulated Data with Sinusoidal Mean\")"},{"path":"https://sipemu.github.io/fdars-r/articles/simulation-toolbox.html","id":"adding-measurement-error","dir":"Articles","previous_headings":"","what":"Adding Measurement Error","title":"Simulating Functional Data","text":"Use addError() add noise simulated (real) data:","code":"fd_clean <- simFunData(n = 10, argvals = t, M = 5, seed = 42)  # Add different noise levels fd_low <- addError(fd_clean, sd = 0.1, seed = 123) fd_med <- addError(fd_clean, sd = 0.3, seed = 123) fd_high <- addError(fd_clean, sd = 0.5, seed = 123)  p1 <- autoplot(fd_clean) + labs(title = \"Clean Data\") p2 <- autoplot(fd_low) + labs(title = \"Low Noise (sd = 0.1)\") p3 <- autoplot(fd_med) + labs(title = \"Medium Noise (sd = 0.3)\") p4 <- autoplot(fd_high) + labs(title = \"High Noise (sd = 0.5)\") gridExtra::grid.arrange(p1, p2, p3, p4, ncol = 2)"},{"path":"https://sipemu.github.io/fdars-r/articles/simulation-toolbox.html","id":"curve-level-noise","dir":"Articles","previous_headings":"Adding Measurement Error","what":"Curve-Level Noise","title":"Simulating Functional Data","text":"Add constant noise value per curve (useful modeling measurement bias):","code":"fd_curve_noise <- addError(fd_clean, sd = 0.5, type = \"curve\", seed = 123) autoplot(fd_curve_noise) + labs(title = \"Curve-Level Noise\")"},{"path":"https://sipemu.github.io/fdars-r/articles/simulation-toolbox.html","id":"creating-sparseirregular-data","dir":"Articles","previous_headings":"","what":"Creating Sparse/Irregular Data","title":"Simulating Functional Data","text":"Use sparsify() simulate irregular sampling:  See “Irregular Sampling” vignette details working sparse data.","code":"fd <- simFunData(n = 10, argvals = t, M = 5, seed = 42)  # Create sparse version ifd <- sparsify(fd, minObs = 10, maxObs = 30, seed = 123) print(ifd) #> Irregular Functional Data Object #> ================================= #>   Number of observations: 10  #>   Points per curve: #>     Min: 10  #>     Median: 21.5  #>     Max: 29  #>     Total: 212  #>   Domain: [ 0 , 1 ] autoplot(ifd) + labs(title = \"Sparsified Functional Data\")"},{"path":"https://sipemu.github.io/fdars-r/articles/simulation-toolbox.html","id":"multivariate-functional-data","dir":"Articles","previous_headings":"","what":"Multivariate Functional Data","title":"Simulating Functional Data","text":"Simulate multiple correlated functional components:","code":"t1 <- seq(0, 1, length.out = 100) t2 <- seq(0, 0.5, length.out = 50)  mfd <- simMultiFunData(   n = 15,   argvals = list(t1, t2),   M = c(5, 3),   eFun.type = c(\"Fourier\", \"Wiener\"),   eVal.type = c(\"exponential\", \"linear\"),   seed = 42 )  print(mfd) #> Multivariate Functional Data Object #> =================================== #>   Number of observations: 15  #>   Number of components: 2  #>  #>   Component 1 : #>     Evaluation points: 100  #>     Domain: [ 0 , 1 ] #>   Component 2 : #>     Evaluation points: 50  #>     Domain: [ 0 , 0.5 ] p1 <- autoplot(mfd$components[[1]]) + labs(title = \"Component 1 (Fourier)\") p2 <- autoplot(mfd$components[[2]]) + labs(title = \"Component 2 (Wiener)\") gridExtra::grid.arrange(p1, p2, ncol = 2)"},{"path":"https://sipemu.github.io/fdars-r/articles/simulation-toolbox.html","id":"comparison-with-gp-simulation","dir":"Articles","previous_headings":"","what":"Comparison with GP Simulation","title":"Simulating Functional Data","text":"package also offers Gaussian Process simulation via make.gaussian.process():","code":"# KL simulation fd_kl <- simFunData(n = 10, argvals = t, M = 10,                     eFun.type = \"Wiener\", eVal.type = \"wiener\", seed = 42)  # GP simulation with Brownian motion kernel set.seed(42) fd_gp <- make.gaussian.process(n = 10, t = t,                                 cov = kernel.brownian())  p1 <- autoplot(fd_kl) + labs(title = \"KL Simulation (Wiener)\") p2 <- autoplot(fd_gp) + labs(title = \"GP Simulation (Brownian Kernel)\") gridExtra::grid.arrange(p1, p2, ncol = 2)"},{"path":"https://sipemu.github.io/fdars-r/articles/simulation-toolbox.html","id":"complete-simulation-recipe","dir":"Articles","previous_headings":"","what":"Complete Simulation Recipe","title":"Simulating Functional Data","text":"’s complete workflow power analysis:","code":"set.seed(42)  # 1. Simulate two groups with different means n_per_group <- 30 t <- seq(0, 1, length.out = 100)  mean_group1 <- function(t) sin(2 * pi * t) mean_group2 <- function(t) sin(2 * pi * t) + 0.5 * cos(4 * pi * t)  group1 <- simFunData(n = n_per_group, argvals = t, M = 5, mean = mean_group1) group2 <- simFunData(n = n_per_group, argvals = t, M = 5, mean = mean_group2)  # 2. Add measurement noise group1 <- addError(group1, sd = 0.2) group2 <- addError(group2, sd = 0.2)  # 3. Visualize with ggplot2 mean_df1 <- data.frame(t = t, mean = mean_group1(t)) mean_df2 <- data.frame(t = t, mean = mean_group2(t))  p1 <- autoplot(group1, alpha = 0.5) +   geom_line(data = mean_df1, aes(x = t, y = mean), color = \"blue\", linewidth = 1.5, inherit.aes = FALSE) +   labs(title = \"Group 1\")  p2 <- autoplot(group2, alpha = 0.5) +   geom_line(data = mean_df2, aes(x = t, y = mean), color = \"red\", linewidth = 1.5, inherit.aes = FALSE) +   labs(title = \"Group 2\")  # Side-by-side plots gridExtra::grid.arrange(p1, p2, ncol = 2)"},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/articles/working-with-derivatives.html","id":"why-derivatives-matter-in-fda","dir":"Articles","previous_headings":"","what":"Why Derivatives Matter in FDA","title":"Working with Derivatives","text":"functional data analysis, derivatives reveal critical information original curves may hide: Velocity: First derivative shows rate change Acceleration: Second derivative shows rate changes Curvature: Related second derivative, shows bending curves Phase variation: Timing events (peaks, valleys) across subjects Many real-world questions fast things change, just values observed.","code":"library(fdars) #>  #> Attaching package: 'fdars' #> The following objects are masked from 'package:stats': #>  #>     cov, decompose, deriv, median, sd, var #> The following object is masked from 'package:base': #>  #>     norm library(ggplot2) theme_set(theme_minimal()) set.seed(42)"},{"path":"https://sipemu.github.io/fdars-r/articles/working-with-derivatives.html","id":"loading-growth-data","dir":"Articles","previous_headings":"","what":"Loading Growth Data","title":"Working with Derivatives","text":"Berkeley Growth Study ideal demonstrating derivatives: - Height curves show overall growth pattern - Velocity (1st derivative) reveals growth spurts - Acceleration (2nd derivative) shows onset end spurts","code":"# Load or simulate growth data if (requireNamespace(\"fda\", quietly = TRUE)) {   data(growth, package = \"fda\")   age <- growth$age   heights <- t(growth$hgtf)  # Girls' heights   n <- nrow(heights) } else {   message(\"Install 'fda' package for real data: install.packages('fda')\")   # Simulate realistic growth-like data with variable PHV timing   # Using logistic model where inflection point = PHV age   age <- seq(1, 18, length.out = 31)   n <- 20   heights <- matrix(0, n, length(age))   for (i in 1:n) {     final_height <- rnorm(1, 165, 5)     # Adult height (cm)     init_height <- rnorm(1, 75, 2)       # Height at age 1 (cm)     phv_age <- rnorm(1, 11.5, 1)         # Age at PHV (early ~10, late ~13)     growth_rate <- rnorm(1, 0.45, 0.05)  # Growth curve steepness      # Logistic growth: h(t) = init + (final - init) / (1 + exp(-k*(t - phv)))     # PHV occurs at inflection point (t = phv_age)     heights[i, ] <- init_height + (final_height - init_height) /       (1 + exp(-growth_rate * (age - phv_age)))     heights[i, ] <- heights[i, ] + rnorm(length(age), sd = 0.5)   } }  fd <- fdata(heights, argvals = age) cat(\"Loaded\", n, \"growth curves from ages\", min(age), \"to\", max(age), \"\\n\") #> Loaded 54 growth curves from ages 1 to 18"},{"path":"https://sipemu.github.io/fdars-r/articles/working-with-derivatives.html","id":"the-problem-noise-amplifies-with-differentiation","dir":"Articles","previous_headings":"","what":"The Problem: Noise Amplifies with Differentiation","title":"Working with Derivatives","text":"Let’s see happens naively differentiate noisy data: noise measurements becomes dramatically amplified derivatives!","code":"# Add some measurement noise heights_noisy <- heights + matrix(rnorm(length(heights), sd = 1), nrow = n) fd_noisy <- fdata(heights_noisy, argvals = age)  # Compute derivative of noisy data fd_deriv_noisy <- deriv(fd_noisy, nderiv = 1)  # Compare to original derivative fd_deriv <- deriv(fd, nderiv = 1)  # Plot using ggplot2 df_deriv <- data.frame(   age = rep(fd_deriv$argvals, 2),   velocity = c(fd_deriv$data[1, ], fd_deriv_noisy$data[1, ]),   type = rep(c(\"Original Data\", \"Noisy Data\"), each = length(fd_deriv$argvals)) )  ggplot(df_deriv, aes(x = age, y = velocity)) +   geom_line() +   facet_wrap(~ type) +   coord_cartesian(ylim = c(-2, 15)) +   labs(x = \"Age (years)\", y = \"Velocity (cm/year)\",        title = \"Effect of Noise on Derivative Estimation\") +   theme_minimal()"},{"path":"https://sipemu.github.io/fdars-r/articles/working-with-derivatives.html","id":"solution-smooth-before-differentiating","dir":"Articles","previous_headings":"","what":"Solution: Smooth Before Differentiating","title":"Working with Derivatives","text":"key insight: Always smooth data computing derivatives. P-splines excellent provide smooth derivatives:","code":"# Smooth the noisy data with P-splines fd_smooth <- pspline(fd_noisy)  # Now compute derivatives from smoothed data fd_velocity <- deriv(fd_smooth$fdata, nderiv = 1) fd_acceleration <- deriv(fd_smooth$fdata, nderiv = 2)"},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/articles/working-with-derivatives.html","id":"height-curves-original","dir":"Articles","previous_headings":"Understanding Growth Derivatives","what":"Height Curves (Original)","title":"Working with Derivatives","text":"","code":"plot(fd_smooth$fdata, main = \"Smoothed Height Curves\",      xlab = \"Age (years)\", ylab = \"Height (cm)\")"},{"path":"https://sipemu.github.io/fdars-r/articles/working-with-derivatives.html","id":"velocity-curves-first-derivative","dir":"Articles","previous_headings":"Understanding Growth Derivatives","what":"Velocity Curves (First Derivative)","title":"Working with Derivatives","text":"Velocity shows growth rate cm/year. pubertal growth spurt clearly visible peak around age 11-13:  Key observations: - Infancy: high velocity (children grow fast) - Childhood: Gradual decline ~5 cm/year - Puberty: Sharp peak (growth spurt) - Adulthood: Velocity approaches zero (growth stops)","code":"library(ggplot2) plot(fd_velocity) +   geom_hline(yintercept = 0, linetype = 2, color = \"gray\") +   labs(title = \"Growth Velocity (First Derivative)\",        x = \"Age (years)\", y = \"Velocity (cm/year)\")"},{"path":"https://sipemu.github.io/fdars-r/articles/working-with-derivatives.html","id":"acceleration-curves-second-derivative","dir":"Articles","previous_headings":"Understanding Growth Derivatives","what":"Acceleration Curves (Second Derivative)","title":"Working with Derivatives","text":"Acceleration shows growth speeds (positive) slows (negative):  Key observations: - Zero crossing (positive negative): Peak growth spurt (PHV - Peak Height Velocity) - Minimum acceleration: rapid deceleration growth","code":"plot(fd_acceleration) +   geom_hline(yintercept = 0, linetype = 2, color = \"gray\") +   labs(title = \"Growth Acceleration (Second Derivative)\",        x = \"Age (years)\", y = \"Acceleration (cm/year^2)\")"},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/articles/working-with-derivatives.html","id":"peak-height-velocity-phv","dir":"Articles","previous_headings":"Finding Important Events","what":"Peak Height Velocity (PHV)","title":"Working with Derivatives","text":"age peak height velocity important biological marker:","code":"# Find age of maximum velocity for each individual phv_ages <- apply(fd_velocity$data, 1, function(v) {   age[which.max(v)] })  # Summary statistics cat(\"Peak Height Velocity Ages:\\n\") #> Peak Height Velocity Ages: cat(\"  Mean:\", round(mean(phv_ages), 1), \"years\\n\") #>   Mean: 1 years cat(\"  SD:\", round(sd(phv_ages), 1), \"years\\n\") #>   SD: 0.1 years cat(\"  Range:\", round(min(phv_ages), 1), \"-\", round(max(phv_ages), 1), \"years\\n\") #>   Range: 1 - 1.8 years  # Histogram using ggplot2 df_phv <- data.frame(phv_age = phv_ages)  ggplot(df_phv, aes(x = phv_age)) +   geom_histogram(bins = 10, fill = \"lightblue\", color = \"white\") +   geom_vline(xintercept = mean(phv_ages), color = \"red\", linewidth = 1) +   labs(x = \"Age at PHV (years)\", y = \"Count\",        title = \"Distribution of PHV Ages\") +   theme_minimal()"},{"path":"https://sipemu.github.io/fdars-r/articles/working-with-derivatives.html","id":"visualizing-individual-variation","dir":"Articles","previous_headings":"Finding Important Events","what":"Visualizing Individual Variation","title":"Working with Derivatives","text":"","code":"# Select early and late developers early_idx <- which.min(phv_ages) late_idx <- which.max(phv_ages) median_idx <- which.min(abs(phv_ages - median(phv_ages)))  # Create data frame for height curves df_height_var <- data.frame(   age = rep(age, 3),   height = c(fd_smooth$fdata$data[early_idx, ],              fd_smooth$fdata$data[median_idx, ],              fd_smooth$fdata$data[late_idx, ]),   developer = factor(rep(c(\"Early\", \"Median\", \"Late\"), each = length(age)),                      levels = c(\"Early\", \"Median\", \"Late\")) )  # Create data frame for velocity curves df_vel_var <- data.frame(   age = rep(age, 3),   velocity = c(fd_velocity$data[early_idx, ],                fd_velocity$data[median_idx, ],                fd_velocity$data[late_idx, ]),   developer = factor(rep(c(\"Early\", \"Median\", \"Late\"), each = length(age)),                      levels = c(\"Early\", \"Median\", \"Late\")) )  # Height plot p1 <- ggplot(df_height_var, aes(x = age, y = height, color = developer, group = developer)) +   geom_line(linewidth = 1) +   scale_color_manual(values = c(\"Early\" = \"blue\", \"Median\" = \"gray50\", \"Late\" = \"red\")) +   labs(x = \"Age (years)\", y = \"Height (cm)\",        title = \"Height: Early vs Late Developers\", color = NULL) +   theme_minimal() +   theme(legend.position = \"bottom\")  # Velocity plot p2 <- ggplot(df_vel_var, aes(x = age, y = velocity, color = developer, group = developer)) +   geom_line(linewidth = 1) +   geom_hline(yintercept = 0, linetype = \"dashed\", color = \"gray\") +   scale_color_manual(values = c(\"Early\" = \"blue\", \"Median\" = \"gray50\", \"Late\" = \"red\")) +   labs(x = \"Age (years)\", y = \"Velocity (cm/year)\",        title = \"Velocity: Early vs Late Developers\", color = NULL) +   theme_minimal() +   theme(legend.position = \"bottom\")  # Display both plots (using patchwork if available, otherwise gridExtra) if (requireNamespace(\"patchwork\", quietly = TRUE)) {   library(patchwork)   p1 + p2 } else {   print(p1)   print(p2) }"},{"path":"https://sipemu.github.io/fdars-r/articles/working-with-derivatives.html","id":"derivative-based-distances","dir":"Articles","previous_headings":"","what":"Derivative-Based Distances","title":"Working with Derivatives","text":"shape velocity acceleration curves may meaningful comparing individuals height curves .","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/working-with-derivatives.html","id":"using-semimetric-deriv","dir":"Articles","previous_headings":"Derivative-Based Distances","what":"Using semimetric.deriv()","title":"Working with Derivatives","text":"","code":"# Distance based on first derivative (velocity) dist_height <- metric.lp(fd_smooth$fdata) dist_velocity <- semimetric.deriv(fd_smooth$fdata, nderiv = 1) dist_acceleration <- semimetric.deriv(fd_smooth$fdata, nderiv = 2)  # Compare distance matrices (first 10 individuals) cat(\"Correlation between distance types:\\n\") #> Correlation between distance types: cat(\"  Height vs Velocity:\", round(cor(as.vector(dist_height[1:10, 1:10]),                                         as.vector(dist_velocity[1:10, 1:10])), 3), \"\\n\") #>   Height vs Velocity: 0.673 cat(\"  Height vs Acceleration:\", round(cor(as.vector(dist_height[1:10, 1:10]),                                             as.vector(dist_acceleration[1:10, 1:10])), 3), \"\\n\") #>   Height vs Acceleration: 0.452"},{"path":"https://sipemu.github.io/fdars-r/articles/working-with-derivatives.html","id":"clustering-by-growth-pattern","dir":"Articles","previous_headings":"Derivative-Based Distances","what":"Clustering by Growth Pattern","title":"Working with Derivatives","text":"Different distance measures can reveal different groupings:","code":"# Cluster using velocity-based distance (semimetric.deriv as the metric function) km_velocity <- cluster.kmeans(fd_smooth$fdata, ncl = 2,                                metric = semimetric.deriv, nderiv = 1, seed = 123)  # Create data frames for plotting df_height_clust <- data.frame(   age = rep(age, n),   height = as.vector(t(fd_smooth$fdata$data)),   curve = rep(1:n, each = length(age)),   cluster = factor(rep(km_velocity$cluster, each = length(age))) )  df_vel_clust <- data.frame(   age = rep(age, n),   velocity = as.vector(t(fd_velocity$data)),   curve = rep(1:n, each = length(age)),   cluster = factor(rep(km_velocity$cluster, each = length(age))) )  # Height by cluster plot p1 <- ggplot(df_height_clust, aes(x = age, y = height, group = curve, color = cluster)) +   geom_line(alpha = 0.5, linewidth = 0.5) +   scale_color_manual(values = c(\"1\" = \"blue\", \"2\" = \"red\")) +   labs(x = \"Age (years)\", y = \"Height (cm)\",        title = \"Clusters (Velocity-based)\", color = \"Cluster\") +   theme_minimal() +   theme(legend.position = \"bottom\")  # Velocity by cluster plot p2 <- ggplot(df_vel_clust, aes(x = age, y = velocity, group = curve, color = cluster)) +   geom_line(alpha = 0.5, linewidth = 0.5) +   geom_hline(yintercept = 0, linetype = \"dashed\", color = \"gray\") +   scale_color_manual(values = c(\"1\" = \"blue\", \"2\" = \"red\")) +   labs(x = \"Age (years)\", y = \"Velocity (cm/year)\",        title = \"Velocity Curves by Cluster\", color = \"Cluster\") +   theme_minimal() +   theme(legend.position = \"bottom\")  # Display both plots if (requireNamespace(\"patchwork\", quietly = TRUE)) {   p1 + p2 } else {   print(p1)   print(p2) }"},{"path":"https://sipemu.github.io/fdars-r/articles/working-with-derivatives.html","id":"d-functional-data-partial-derivatives","dir":"Articles","previous_headings":"","what":"2D Functional Data: Partial Derivatives","title":"Working with Derivatives","text":"surfaces (2D functional data), compute partial derivatives:","code":"# Create a simple 2D example: temperature surface (space x time) s <- seq(0, 1, length.out = 20)  # spatial coordinate t <- seq(0, 1, length.out = 25)  # time coordinate  # Generate surface: wave pattern Z <- outer(s, t, function(x, y) sin(2*pi*x) * cos(2*pi*y) + 0.1*rnorm(length(x)))  # Create 2D fdata fd2d <- fdata(Z, argvals = list(s = s, t = t), fdata2d = TRUE)  # Partial derivatives # Note: For 2D data, use nderiv parameter to specify derivative type # nderiv = 1 for ds, nderiv = 2 for dt, etc."},{"path":"https://sipemu.github.io/fdars-r/articles/working-with-derivatives.html","id":"optimal-smoothing-for-derivatives","dir":"Articles","previous_headings":"","what":"Optimal Smoothing for Derivatives","title":"Working with Derivatives","text":"goal estimate derivatives, may need different smoothing curves . Higher penalty (smoothing) often gives better derivative estimates:","code":"# Compare different smoothing levels lambdas <- c(0.01, 0.1, 1, 10) idx <- 1  # Create data frame for all lambda values df_smooth <- do.call(rbind, lapply(lambdas, function(lam) {   fd_s <- pspline(fd_noisy, lambda = lam)   fd_v <- deriv(fd_s$fdata, nderiv = 1)   data.frame(     age = rep(fd_v$argvals, 2),     velocity = c(fd_v$data[idx, ], fd_deriv$data[idx, ]),     type = rep(c(\"Smoothed\", \"Reference\"), each = length(fd_v$argvals)),     lambda = paste(\"lambda =\", lam)   ) })) df_smooth$lambda <- factor(df_smooth$lambda, levels = paste(\"lambda =\", lambdas))  ggplot(df_smooth, aes(x = age, y = velocity, color = type, linetype = type)) +   geom_line(linewidth = 0.8) +   geom_hline(yintercept = 0, linetype = \"dotted\", color = \"gray\") +   scale_color_manual(values = c(\"Smoothed\" = \"blue\", \"Reference\" = \"red\")) +   scale_linetype_manual(values = c(\"Smoothed\" = \"solid\", \"Reference\" = \"dashed\")) +   facet_wrap(~ lambda, ncol = 2) +   labs(x = \"Age (years)\", y = \"Velocity (cm/year)\",        title = \"Derivative Estimation with Different Smoothing Levels\",        color = NULL, linetype = NULL) +   theme_minimal() +   theme(legend.position = \"bottom\")"},{"path":"https://sipemu.github.io/fdars-r/articles/working-with-derivatives.html","id":"practical-workflow","dir":"Articles","previous_headings":"","what":"Practical Workflow","title":"Working with Derivatives","text":"’s recommended workflow derivative analysis:","code":"# 1. Load and inspect raw data cat(\"Step 1: Inspect raw data\\n\") #> Step 1: Inspect raw data summary(fd) #> Functional data summary #> ======================= #> Type: 1D (curve)  #> Number of observations: 54  #> Number of evaluation points: 31  #>  #> Data range: #>   Min: 67.3  #>   Max: 183.2  #>   Mean: 135.1664  #>   SD: 31.28565  # 2. Smooth with appropriate method cat(\"\\nStep 2: Smooth data (P-splines)\\n\") #>  #> Step 2: Smooth data (P-splines) fd_smooth <- pspline(fd, lambda = NULL)  # NULL = automatic selection  # 3. Compute derivatives cat(\"\\nStep 3: Compute derivatives\\n\") #>  #> Step 3: Compute derivatives fd_d1 <- deriv(fd_smooth$fdata, nderiv = 1) fd_d2 <- deriv(fd_smooth$fdata, nderiv = 2)  # 4. Extract features from derivatives cat(\"\\nStep 4: Extract features\\n\") #>  #> Step 4: Extract features features <- data.frame(   id = 1:n,   max_velocity = apply(fd_d1$data, 1, max),   age_at_max_vel = apply(fd_d1$data, 1, function(v) age[which.max(v)]),   min_acceleration = apply(fd_d2$data, 1, min) ) head(features) #>   id max_velocity age_at_max_vel min_acceleration #> 1  1     15.61790            1.0        -9.683712 #> 2  2     16.59168            1.5       -19.500398 #> 3  3     15.98360            1.0       -10.561677 #> 4  4     13.05737            1.5        -7.280834 #> 5  5     14.80809            1.0        -9.408322 #> 6  6     16.82903            1.0       -10.610381  # 5. Use for further analysis cat(\"\\nStep 5: Use features for analysis\\n\") #>  #> Step 5: Use features for analysis cat(\"Correlation between age at PHV and max velocity:\",     round(cor(features$age_at_max_vel, features$max_velocity), 3), \"\\n\") #> Correlation between age at PHV and max velocity: -0.301"},{"path":"https://sipemu.github.io/fdars-r/articles/working-with-derivatives.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Working with Derivatives","text":"Key Takeaways: Always smooth computing derivatives - noise amplifies dramatically smoothing derivatives - may need higher λ\\lambda curves Derivatives reveal dynamics - growth spurts, timing, phase variation Derivative-based distances - useful shape-based clustering comparison","code":""},{"path":"https://sipemu.github.io/fdars-r/articles/working-with-derivatives.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Working with Derivatives","text":"Ramsay, J.O. Silverman, B.W. (2005). Functional Data Analysis. Springer. (Chapter 5: Smoothing Functional Data; Chapter 9: Principal Differential Analysis) Tuddenham, R.D. Snyder, M.M. (1954). Physical growth California boys girls birth eighteen years. University California Publications Child Development, 1, 183-364.","code":""},{"path":"https://sipemu.github.io/fdars-r/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Simon Müller. Author, maintainer.","code":""},{"path":"https://sipemu.github.io/fdars-r/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Müller S (2026). fdars: Functional Data Analysis Rust. R package version 0.3.0, https://sipemu.github.io/fdars-r/.","code":"@Manual{,   title = {fdars: Functional Data Analysis in Rust},   author = {Simon Müller},   year = {2026},   note = {R package version 0.3.0},   url = {https://sipemu.github.io/fdars-r/}, }"},{"path":"https://sipemu.github.io/fdars-r/index.html","id":"fdars","dir":"","previous_headings":"","what":"fdars - Functional Data Analysis in Rust","title":"fdars - Functional Data Analysis in Rust","text":"Functional Data Analysis Rust - high-performance R package functional data analysis Rust backend.","code":""},{"path":"https://sipemu.github.io/fdars-r/index.html","id":"what-is-functional-data-analysis","dir":"","previous_headings":"","what":"What is Functional Data Analysis?","title":"fdars - Functional Data Analysis in Rust","text":"Functional Data Analysis (FDA) branch statistics deals data observation function, curve, surface rather single number vector. Examples include: Temperature curves: Daily temperature recordings year multiple weather stations Growth curves: Height measurements children tracked time Spectroscopy data: Absorbance spectra measured across wavelengths Financial trajectories: Stock price movements trading days Medical signals: ECG, EEG, fMRI time series Traditional statistical methods treat time point separate variable, losing inherent smoothness continuity data. FDA treats entire curve single observation, enabling powerful interpretable analyses.","code":""},{"path":"https://sipemu.github.io/fdars-r/index.html","id":"features","dir":"","previous_headings":"","what":"Features","title":"fdars - Functional Data Analysis in Rust","text":"fdars comprehensive toolkit functional data analysis high-performance Rust backend providing 10-200x speedups pure R implementations.","code":""},{"path":"https://sipemu.github.io/fdars-r/index.html","id":"data-representation","dir":"","previous_headings":"Features","what":"Data Representation","title":"fdars - Functional Data Analysis in Rust","text":"1D functional data - Curves, time series, spectra 2D functional data - Surfaces, images, spatial fields Metadata support - Attach IDs covariates observations Flexible /O - Create matrices, arrays, data frames","code":""},{"path":"https://sipemu.github.io/fdars-r/index.html","id":"depth--centrality","dir":"","previous_headings":"Features","what":"Depth & Centrality","title":"fdars - Functional Data Analysis in Rust","text":"Measure “central” “typical” curve : - Fraiman-Muniz (FM), Band depth (BD), Modified band depth (MBD) - Modal depth, Random projection (RP, RT, RPD) - Functional spatial depth (FSD, KFSD) - Depth-based median, trimmed mean, trimmed variance","code":""},{"path":"https://sipemu.github.io/fdars-r/index.html","id":"outlier-detection","dir":"","previous_headings":"Features","what":"Outlier Detection","title":"fdars - Functional Data Analysis in Rust","text":"Multiple approaches identify anomalous curves: - Depth-based trimming weighting - Likelihood ratio test (LRT) - Functional boxplot - Magnitude-Shape plot (magnitude vs shape outliers) - Outliergram (MEI vs MBD)","code":""},{"path":"https://sipemu.github.io/fdars-r/index.html","id":"distance--similarity","dir":"","previous_headings":"Features","what":"Distance & Similarity","title":"fdars - Functional Data Analysis in Rust","text":"Quantify differences curves: - Lp distances (L1, L2, L∞) - Hausdorff distance - Dynamic time warping (DTW) - PCA-based derivative-based semimetrics","code":""},{"path":"https://sipemu.github.io/fdars-r/index.html","id":"regression","dir":"","previous_headings":"Features","what":"Regression","title":"fdars - Functional Data Analysis in Rust","text":"Predict scalar outcomes functional predictors: - Principal component regression (fregre.pc) - Basis expansion regression (fregre.basis) - Nonparametric kernel regression (fregre.np) - Cross-validation model selection","code":""},{"path":"https://sipemu.github.io/fdars-r/index.html","id":"clustering","dir":"","previous_headings":"Features","what":"Clustering","title":"fdars - Functional Data Analysis in Rust","text":"Group similar curves together: - K-means clustering K-means++ initialization - Fuzzy C-means soft membership - Automatic selection optimal k (silhouette, CH, elbow)","code":""},{"path":"https://sipemu.github.io/fdars-r/index.html","id":"smoothing--basis-expansion","dir":"","previous_headings":"Features","what":"Smoothing & Basis Expansion","title":"fdars - Functional Data Analysis in Rust","text":"Nadaraya-Watson, local linear/polynomial regression B-spline Fourier basis expansions P-splines automatic smoothing parameter selection Cross-validation (GCV, AIC, BIC) basis selection","code":""},{"path":"https://sipemu.github.io/fdars-r/index.html","id":"functional-statistics","dir":"","previous_headings":"Features","what":"Functional Statistics","title":"fdars - Functional Data Analysis in Rust","text":"Mean, variance, standard deviation, covariance Geometric median (L1 median) Bootstrap confidence intervals Hypothesis testing functional means","code":""},{"path":"https://sipemu.github.io/fdars-r/index.html","id":"gaussian-process-simulation","dir":"","previous_headings":"Features","what":"Gaussian Process Simulation","title":"fdars - Functional Data Analysis in Rust","text":"Generate synthetic functional data: - Multiple covariance kernels (Gaussian, Matérn, Exponential, Periodic) - Kernel composition (addition, multiplication) - Brownian motion Ornstein-Uhlenbeck processes","code":""},{"path":"https://sipemu.github.io/fdars-r/index.html","id":"group-comparison","dir":"","previous_headings":"Features","what":"Group Comparison","title":"fdars - Functional Data Analysis in Rust","text":"-group distance matrices (centroid, Hausdorff, depth-based) Permutation tests significant group differences Visualization (heatmaps, dendrograms)","code":""},{"path":"https://sipemu.github.io/fdars-r/index.html","id":"visualization","dir":"","previous_headings":"Features","what":"Visualization","title":"fdars - Functional Data Analysis in Rust","text":"Curve plots categorical/continuous coloring Group means confidence intervals Functional boxplots FPCA component visualization Outlier diagnostic plots","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/index.html","id":"prerequisites","dir":"","previous_headings":"Installation","what":"Prerequisites","title":"fdars - Functional Data Analysis in Rust","text":"R (>= 4.0) Rust toolchain (install rustup.rs) C compiler (gcc, clang)","code":""},{"path":"https://sipemu.github.io/fdars-r/index.html","id":"from-github","dir":"","previous_headings":"Installation","what":"From GitHub","title":"fdars - Functional Data Analysis in Rust","text":"Note: Windows, may need Rtools installed.","code":"# Install remotes if needed install.packages(\"remotes\")  # Install fdars (with documentation) remotes::install_github(\"sipemu/fdars-r\", build_vignettes = TRUE)"},{"path":"https://sipemu.github.io/fdars-r/index.html","id":"from-binary-release-no-rust-required","dir":"","previous_headings":"Installation","what":"From Binary Release (No Rust Required)","title":"fdars - Functional Data Analysis in Rust","text":"Download pre-built binary GitHub Releases:","code":"# macOS install.packages(\"path/to/fdars_x.y.z.tgz\", repos = NULL, type = \"mac.binary\")  # Windows install.packages(\"path/to/fdars_x.y.z.zip\", repos = NULL, type = \"win.binary\")"},{"path":"https://sipemu.github.io/fdars-r/index.html","id":"from-source","dir":"","previous_headings":"Installation","what":"From Source","title":"fdars - Functional Data Analysis in Rust","text":"","code":"# Clone the repository git clone https://github.com/sipemu/fdars-r.git cd fdars-r  # Build and install R CMD build . R CMD INSTALL fdars_*.tar.gz"},{"path":"https://sipemu.github.io/fdars-r/index.html","id":"quick-start","dir":"","previous_headings":"","what":"Quick Start","title":"fdars - Functional Data Analysis in Rust","text":"","code":"library(fdars)  # Create functional data from a matrix (rows = observations, cols = time points) t <- seq(0, 1, length.out = 100) X <- matrix(0, 20, 100) for (i in 1:20) {   X[i, ] <- sin(2 * pi * t) + rnorm(100, sd = 0.1) } fd <- fdata(X, argvals = t)  # Compute depth - measures how \"central\" each curve is depths <- depth(fd)  # default: FM method depths <- depth(fd, method = \"mode\")  # or specify method  # Find the functional median (most central curve) median_curve <- median(fd)  # default: FM method  # Detect outliers outliers <- outliers.depth.trim(fd, trim = 0.1)  # Functional regression: predict scalar y from functional X y <- rowMeans(X) + rnorm(20, sd = 0.1) model <- fregre.pc(fd, y, ncomp = 3) predictions <- predict(model, fd)  # Cluster curves into groups clusters <- cluster.kmeans(fd, ncl = 2)  # Smooth noisy curves S <- S.NW(t, h = 0.1)  # Nadaraya-Watson smoother smoothed <- S %*% X[1, ]"},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/index.html","id":"functional-data-objects-fdata","dir":"","previous_headings":"Key Concepts","what":"Functional Data Objects (fdata)","title":"fdars - Functional Data Analysis in Rust","text":"fdata class stores functional data matrix rows observations columns evaluation points:","code":"fd <- fdata(data_matrix, argvals = time_points, rangeval = c(0, 1))"},{"path":"https://sipemu.github.io/fdars-r/index.html","id":"identifiers-and-metadata","dir":"","previous_headings":"Key Concepts > Functional Data Objects (fdata)","what":"Identifiers and Metadata","title":"fdars - Functional Data Analysis in Rust","text":"can attach identifiers metadata (covariates) functional data objects: Note: metadata contains id column non-default row names, must match fdata identifiers. error thrown mismatch.","code":"# Create fdata with IDs and metadata meta <- data.frame(   group = factor(c(\"control\", \"treatment\", ...)),   age = c(25, 32, ...),   response = c(0.5, 0.8, ...) ) fd <- fdata(X, id = paste0(\"patient_\", 1:n), metadata = meta)  # Access fields fd$id              # Character vector of identifiers fd$metadata$group  # Access metadata columns  # Subsetting preserves metadata fd_sub <- fd[1:10, ]  # id and metadata are also subsetted  # View metadata info print(fd)    # Shows metadata columns summary(fd)  # Shows metadata types and ranges"},{"path":"https://sipemu.github.io/fdars-r/index.html","id":"depth-functions","dir":"","previous_headings":"Key Concepts","what":"Depth Functions","title":"fdars - Functional Data Analysis in Rust","text":"Depth measures “central” “typical” curve relative sample. Higher depth = central. Use unified depth() function method parameter:","code":"depth(fd, method = \"FM\")     # Fraiman-Muniz depth (default) depth(fd, method = \"BD\")     # Band depth depth(fd, method = \"MBD\")    # Modified band depth depth(fd, method = \"mode\")   # Modal depth (kernel density) depth(fd, method = \"RP\")     # Random projection depth depth(fd, method = \"RT\")     # Random Tukey depth depth(fd, method = \"FSD\")    # Functional spatial depth depth(fd, method = \"KFSD\")   # Kernel functional spatial depth depth(fd, method = \"RPD\")    # Random projection with derivatives"},{"path":"https://sipemu.github.io/fdars-r/index.html","id":"functional-regression","dir":"","previous_headings":"Key Concepts","what":"Functional Regression","title":"fdars - Functional Data Analysis in Rust","text":"Predict scalar response functional predictors: fregre.pc - Principal component regression fregre.basis - Basis expansion regression fregre.np - Nonparametric kernel regression models support predict() new data.","code":""},{"path":"https://sipemu.github.io/fdars-r/index.html","id":"distance-metrics","dir":"","previous_headings":"Key Concepts","what":"Distance Metrics","title":"fdars - Functional Data Analysis in Rust","text":"Measure similarity curves using metric() method parameter: Individual functions also available: metric.lp, metric.hausdorff, metric.DTW, semimetric.pca, semimetric.deriv.","code":"metric(fd, method = \"lp\")        # Lp distance (default, L2 = Euclidean) metric(fd, method = \"hausdorff\") # Hausdorff distance metric(fd, method = \"dtw\")       # Dynamic time warping metric(fd, method = \"pca\")       # PCA-based semimetric metric(fd, method = \"deriv\")     # Derivative-based semimetric"},{"path":"https://sipemu.github.io/fdars-r/index.html","id":"outlier-detection-1","dir":"","previous_headings":"Key Concepts","what":"Outlier Detection","title":"fdars - Functional Data Analysis in Rust","text":"Identify unusual curves: outliers.depth.trim - Trimmed depth-based detection outliers.depth.pond - Weighted depth-based detection outliers.lrt - Likelihood ratio test outliers.boxplot - Functional boxplot-based detection magnitudeshape - Magnitude-Shape outlier detection outliergram - Outliergram (MEI vs MBD plot)","code":""},{"path":"https://sipemu.github.io/fdars-r/index.html","id":"labeling-outliers-by-id-or-metadata","dir":"","previous_headings":"Key Concepts > Outlier Detection","what":"Labeling Outliers by ID or Metadata","title":"fdars - Functional Data Analysis in Rust","text":"magnitudeshape outliergram support labeling points ID metadata columns:","code":"# Create fdata with IDs and metadata fd <- fdata(X, id = paste0(\"patient_\", 1:n),             metadata = data.frame(subject_id = paste0(\"S\", 1:n)))  # Outliergram with custom labels og <- outliergram(fd) plot(og, label = \"id\")           # Label outliers with patient IDs plot(og, label = \"subject_id\")   # Label with metadata column plot(og, label_all = TRUE)       # Label ALL points, not just outliers  # magnitudeshape with custom labels magnitudeshape(fd, label = \"id\")        # Label outliers with patient IDs magnitudeshape(fd, label = NULL)        # No labels"},{"path":"https://sipemu.github.io/fdars-r/index.html","id":"functional-statistics-1","dir":"","previous_headings":"Key Concepts","what":"Functional Statistics","title":"fdars - Functional Data Analysis in Rust","text":"mean(fd) - Functional mean var(fd) - Functional variance sd(fd) - Functional standard deviation cov(fd) - Functional covariance gmed(fd) - Geometric median (L1 median via Weiszfeld algorithm)","code":""},{"path":"https://sipemu.github.io/fdars-r/index.html","id":"covariance-functions-and-gaussian-process-generation","dir":"","previous_headings":"Key Concepts","what":"Covariance Functions and Gaussian Process Generation","title":"fdars - Functional Data Analysis in Rust","text":"Generate synthetic functional data Gaussian processes various covariance kernels: Available covariance functions: - kernel_gaussian - Squared exponential (RBF) kernel, infinitely smooth - kernel_exponential - Exponential kernel (Matern ν=0.5), rough - kernel_matern - Matern family smoothness parameter ν - kernel_brownian - Brownian motion covariance (1D ) - kernel_linear - Linear kernel - kernel_polynomial - Polynomial kernel - kernel_whitenoise - Independent noise point - kernel_periodic - Periodic kernel (1D ) - kernel_add - Combine kernels addition - kernel_mult - Combine kernels multiplication","code":"# Smooth samples with Gaussian (squared exponential) kernel fd_smooth <- make_gaussian_process(n = 20, t = seq(0, 1, length.out = 100),                                    cov = kernel_gaussian(length_scale = 0.2))  # Rough samples with Matern kernel fd_rough <- make_gaussian_process(n = 20, t = seq(0, 1, length.out = 100),                                   cov = kernel_matern(nu = 1.5))  # Periodic samples fd_periodic <- make_gaussian_process(n = 10, t = seq(0, 2, length.out = 200),                                      cov = kernel_periodic(period = 0.5))  # Combine kernels: signal + noise cov_total <- kernel_add(kernel_gaussian(variance = 1), kernel_whitenoise(variance = 0.1)) fd_noisy <- make_gaussian_process(n = 10, t = seq(0, 1, length.out = 100), cov = cov_total)"},{"path":"https://sipemu.github.io/fdars-r/index.html","id":"depth-based-medians-and-trimmed-means","dir":"","previous_headings":"Key Concepts","what":"Depth-Based Medians and Trimmed Means","title":"fdars - Functional Data Analysis in Rust","text":"Use unified functions method parameter:","code":"# Median (curve with maximum depth) median(fd)                          # default: FM method median(fd, method = \"mode\")         # modal depth-based median  # Trimmed mean (mean of deepest curves) trimmed(fd, trim = 0.1)             # default: FM method trimmed(fd, trim = 0.1, method = \"RP\")  # RP depth-based trimmed mean  # Trimmed variance trimvar(fd, trim = 0.1)             # default: FM method trimvar(fd, trim = 0.1, method = \"mode\")"},{"path":"https://sipemu.github.io/fdars-r/index.html","id":"visualization-1","dir":"","previous_headings":"Key Concepts","what":"Visualization","title":"fdars - Functional Data Analysis in Rust","text":"show.mean = TRUE - Overlay group mean curves show.ci = TRUE - Show confidence interval ribbons per group boxplot.fdata - Functional boxplot depth-based envelopes magnitudeshape - Magnitude-Shape outlier detection visualization outliergram - Outliergram shape outlier detection (MEI vs MBD plot) plot.fdata2pc - FPCA visualization (components, variance, scores)","code":""},{"path":"https://sipemu.github.io/fdars-r/index.html","id":"group-comparison-1","dir":"","previous_headings":"Key Concepts","what":"Group Comparison","title":"fdars - Functional Data Analysis in Rust","text":"group.distance - Compute distances groups (centroid, Hausdorff, depth-based) group.test - Permutation test significant group differences plot.group.distance - Visualize group distances (heatmap, dendrogram)","code":""},{"path":"https://sipemu.github.io/fdars-r/index.html","id":"clustering-1","dir":"","previous_headings":"Key Concepts","what":"Clustering","title":"fdars - Functional Data Analysis in Rust","text":"cluster.kmeans - K-means clustering functional data cluster.optim - Optimal k selection using silhouette, CH, elbow cluster.fcm - Fuzzy C-means clustering soft membership cluster.init - K-means++ center initialization","code":""},{"path":"https://sipemu.github.io/fdars-r/index.html","id":"curve-registration","dir":"","previous_headings":"Key Concepts","what":"Curve Registration","title":"fdars - Functional Data Analysis in Rust","text":"register.fd - Shift registration using cross-correlation","code":""},{"path":"https://sipemu.github.io/fdars-r/index.html","id":"feature-extraction","dir":"","previous_headings":"Key Concepts","what":"Feature Extraction","title":"fdars - Functional Data Analysis in Rust","text":"localavg.fdata - Extract local average features curves","code":""},{"path":"https://sipemu.github.io/fdars-r/index.html","id":"id_2d-functional-data-surfaces","dir":"","previous_headings":"Key Concepts","what":"2D Functional Data (Surfaces)","title":"fdars - Functional Data Analysis in Rust","text":"fdars supports 2D functional data (surfaces/images). following functions full 2D support: Note: Band depths (BD, MBD), RPD, DTW support 2D data.","code":"# Create 2D functional data (e.g., 10 surfaces on a 20x30 grid) n <- 10 m1 <- 20 m2 <- 30 s <- seq(0, 1, length.out = m1) t <- seq(0, 1, length.out = m2)  # Generate surfaces: f(s,t) = sin(2*pi*s) * cos(2*pi*t) + noise X <- array(0, dim = c(n, m1, m2)) for (i in 1:n) {   for (si in 1:m1) {     for (ti in 1:m2) {       X[i, si, ti] <- sin(2*pi*s[si]) * cos(2*pi*t[ti]) + rnorm(1, sd = 0.1)     }   } }  fd2d <- fdata(X, argvals = list(s, t), fdata2d = TRUE)  # All these work with 2D data: mean_surface <- mean(fd2d)           # Mean surface var_surface <- var(fd2d)             # Pointwise variance depths <- depth(fd2d)                # Depth values median_surface <- median(fd2d)       # Depth-based median gmed_surface <- gmed(fd2d)           # Geometric median  # Plot 2D data (heatmap + contours) plot(fd2d)"},{"path":"https://sipemu.github.io/fdars-r/index.html","id":"converting-dataframes-to-2d-fdata","dir":"","previous_headings":"Key Concepts > 2D Functional Data (Surfaces)","what":"Converting DataFrames to 2D fdata","title":"fdars - Functional Data Analysis in Rust","text":"Use df_to_fdata2d() convert long-format DataFrames 2D functional data:","code":"# DataFrame structure: id column, s-index column, t-value columns df <- data.frame(   id = rep(c(\"surf1\", \"surf2\"), each = 5),   s = rep(1:5, 2),   t1 = rnorm(10), t2 = rnorm(10), t3 = rnorm(10) )  # Convert to 2D fdata fd2d <- df_to_fdata2d(df, id_col = 1, s_col = 2)  # With metadata (must have one row per surface) meta <- data.frame(group = c(\"A\", \"B\"), value = c(1.5, 2.3)) fd2d <- df_to_fdata2d(df, id_col = 1, s_col = 2, metadata = meta)"},{"path":"https://sipemu.github.io/fdars-r/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"fdars - Functional Data Analysis in Rust","text":"MIT","code":""},{"path":"https://sipemu.github.io/fdars-r/index.html","id":"author","dir":"","previous_headings":"","what":"Author","title":"fdars - Functional Data Analysis in Rust","text":"Simon Mueller","code":""},{"path":"https://sipemu.github.io/fdars-r/index.html","id":"acknowledgments","dir":"","previous_headings":"","what":"Acknowledgments","title":"fdars - Functional Data Analysis in Rust","text":"Built extendr R-Rust integration Uses rayon parallelization","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/AKer.cos.html","id":null,"dir":"Reference","previous_headings":"","what":"Asymmetric Cosine Kernel — AKer.cos","title":"Asymmetric Cosine Kernel — AKer.cos","text":"Asymmetric Cosine Kernel","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/AKer.cos.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Asymmetric Cosine Kernel — AKer.cos","text":"","code":"AKer.cos(u)"},{"path":"https://sipemu.github.io/fdars-r/reference/AKer.cos.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Asymmetric Cosine Kernel — AKer.cos","text":"u Numeric vector evaluation points.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/AKer.cos.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Asymmetric Cosine Kernel — AKer.cos","text":"Kernel values u (0 u < 0).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/AKer.cos.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Asymmetric Cosine Kernel — AKer.cos","text":"","code":"u <- seq(-0.5, 1.5, length.out = 100) plot(u, AKer.cos(u), type = \"l\", main = \"Asymmetric Cosine Kernel\")"},{"path":"https://sipemu.github.io/fdars-r/reference/AKer.epa.html","id":null,"dir":"Reference","previous_headings":"","what":"Asymmetric Epanechnikov Kernel — AKer.epa","title":"Asymmetric Epanechnikov Kernel — AKer.epa","text":"Asymmetric Epanechnikov Kernel","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/AKer.epa.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Asymmetric Epanechnikov Kernel — AKer.epa","text":"","code":"AKer.epa(u)"},{"path":"https://sipemu.github.io/fdars-r/reference/AKer.epa.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Asymmetric Epanechnikov Kernel — AKer.epa","text":"u Numeric vector evaluation points.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/AKer.epa.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Asymmetric Epanechnikov Kernel — AKer.epa","text":"Kernel values u (0 outside [0, 1]).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/AKer.epa.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Asymmetric Epanechnikov Kernel — AKer.epa","text":"","code":"u <- seq(-0.5, 1.5, length.out = 100) plot(u, AKer.epa(u), type = \"l\", main = \"Asymmetric Epanechnikov Kernel\")"},{"path":"https://sipemu.github.io/fdars-r/reference/AKer.norm.html","id":null,"dir":"Reference","previous_headings":"","what":"Asymmetric Normal Kernel — AKer.norm","title":"Asymmetric Normal Kernel — AKer.norm","text":"Asymmetric Normal Kernel","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/AKer.norm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Asymmetric Normal Kernel — AKer.norm","text":"","code":"AKer.norm(u)"},{"path":"https://sipemu.github.io/fdars-r/reference/AKer.norm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Asymmetric Normal Kernel — AKer.norm","text":"u Numeric vector evaluation points.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/AKer.norm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Asymmetric Normal Kernel — AKer.norm","text":"Kernel values u (0 u < 0).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/AKer.norm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Asymmetric Normal Kernel — AKer.norm","text":"","code":"u <- seq(-0.5, 3, length.out = 100) plot(u, AKer.norm(u), type = \"l\", main = \"Asymmetric Normal Kernel\")"},{"path":"https://sipemu.github.io/fdars-r/reference/AKer.quar.html","id":null,"dir":"Reference","previous_headings":"","what":"Asymmetric Quartic Kernel — AKer.quar","title":"Asymmetric Quartic Kernel — AKer.quar","text":"Asymmetric Quartic Kernel","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/AKer.quar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Asymmetric Quartic Kernel — AKer.quar","text":"","code":"AKer.quar(u)"},{"path":"https://sipemu.github.io/fdars-r/reference/AKer.quar.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Asymmetric Quartic Kernel — AKer.quar","text":"u Numeric vector evaluation points.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/AKer.quar.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Asymmetric Quartic Kernel — AKer.quar","text":"Kernel values u (0 outside [0, 1]).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/AKer.quar.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Asymmetric Quartic Kernel — AKer.quar","text":"","code":"u <- seq(-0.5, 1.5, length.out = 100) plot(u, AKer.quar(u), type = \"l\", main = \"Asymmetric Quartic Kernel\")"},{"path":"https://sipemu.github.io/fdars-r/reference/AKer.tri.html","id":null,"dir":"Reference","previous_headings":"","what":"Asymmetric Triweight Kernel — AKer.tri","title":"Asymmetric Triweight Kernel — AKer.tri","text":"Asymmetric Triweight Kernel","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/AKer.tri.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Asymmetric Triweight Kernel — AKer.tri","text":"","code":"AKer.tri(u)"},{"path":"https://sipemu.github.io/fdars-r/reference/AKer.tri.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Asymmetric Triweight Kernel — AKer.tri","text":"u Numeric vector evaluation points.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/AKer.tri.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Asymmetric Triweight Kernel — AKer.tri","text":"Kernel values u (0 outside [0, 1]).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/AKer.tri.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Asymmetric Triweight Kernel — AKer.tri","text":"","code":"u <- seq(-0.5, 1.5, length.out = 100) plot(u, AKer.tri(u), type = \"l\", main = \"Asymmetric Triweight Kernel\")"},{"path":"https://sipemu.github.io/fdars-r/reference/AKer.unif.html","id":null,"dir":"Reference","previous_headings":"","what":"Asymmetric Uniform Kernel — AKer.unif","title":"Asymmetric Uniform Kernel — AKer.unif","text":"Asymmetric Uniform Kernel","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/AKer.unif.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Asymmetric Uniform Kernel — AKer.unif","text":"","code":"AKer.unif(u)"},{"path":"https://sipemu.github.io/fdars-r/reference/AKer.unif.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Asymmetric Uniform Kernel — AKer.unif","text":"u Numeric vector evaluation points.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/AKer.unif.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Asymmetric Uniform Kernel — AKer.unif","text":"Kernel values u (0 outside [0, 1]).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/AKer.unif.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Asymmetric Uniform Kernel — AKer.unif","text":"","code":"u <- seq(-0.5, 1.5, length.out = 100) plot(u, AKer.unif(u), type = \"l\", main = \"Asymmetric Uniform Kernel\")"},{"path":"https://sipemu.github.io/fdars-r/reference/CV.S.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-Validation for Smoother Selection — CV.S","title":"Cross-Validation for Smoother Selection — CV.S","text":"Compute leave-one-cross-validation criterion smoother.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/CV.S.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-Validation for Smoother Selection — CV.S","text":"","code":"CV.S(S.type, tt, h, y, Ker = \"norm\", w = NULL)"},{"path":"https://sipemu.github.io/fdars-r/reference/CV.S.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-Validation for Smoother Selection — CV.S","text":"S.type Function compute smoother matrix (e.g., S.NW, S.LLR). tt Evaluation points. h Bandwidth parameter. y Response vector smooth. Ker Kernel type. w Optional weights.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/CV.S.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-Validation for Smoother Selection — CV.S","text":"cross-validation score (mean squared prediction error).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/CV.S.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-Validation for Smoother Selection — CV.S","text":"","code":"tt <- seq(0, 1, length.out = 50) y <- sin(2 * pi * tt) + rnorm(50, sd = 0.1) cv_score <- CV.S(S.NW, tt, h = 0.1, y = y)"},{"path":"https://sipemu.github.io/fdars-r/reference/GCV.S.html","id":null,"dir":"Reference","previous_headings":"","what":"Generalized Cross-Validation for Smoother Selection — GCV.S","title":"Generalized Cross-Validation for Smoother Selection — GCV.S","text":"Compute GCV criterion: RSS / (1 - tr(S)/n)^2","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/GCV.S.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generalized Cross-Validation for Smoother Selection — GCV.S","text":"","code":"GCV.S(S.type, tt, h, y, Ker = \"norm\", w = NULL)"},{"path":"https://sipemu.github.io/fdars-r/reference/GCV.S.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generalized Cross-Validation for Smoother Selection — GCV.S","text":"S.type Function compute smoother matrix. tt Evaluation points. h Bandwidth parameter. y Response vector. Ker Kernel type. w Optional weights.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/GCV.S.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generalized Cross-Validation for Smoother Selection — GCV.S","text":"GCV score.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/GCV.S.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generalized Cross-Validation for Smoother Selection — GCV.S","text":"","code":"tt <- seq(0, 1, length.out = 50) y <- sin(2 * pi * tt) + rnorm(50, sd = 0.1) gcv_score <- GCV.S(S.NW, tt, h = 0.1, y = y)"},{"path":"https://sipemu.github.io/fdars-r/reference/IKer.cos.html","id":null,"dir":"Reference","previous_headings":"","what":"Integrated Cosine Kernel — IKer.cos","title":"Integrated Cosine Kernel — IKer.cos","text":"Integral Ker.cos -1 u.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/IKer.cos.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Integrated Cosine Kernel — IKer.cos","text":"","code":"IKer.cos(u)"},{"path":"https://sipemu.github.io/fdars-r/reference/IKer.cos.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Integrated Cosine Kernel — IKer.cos","text":"u Numeric vector evaluation points.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/IKer.cos.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Integrated Cosine Kernel — IKer.cos","text":"Cumulative integral values.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/IKer.cos.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Integrated Cosine Kernel — IKer.cos","text":"","code":"u <- seq(-1.5, 1.5, length.out = 100) plot(u, IKer.cos(u), type = \"l\", main = \"Integrated Cosine Kernel\")"},{"path":"https://sipemu.github.io/fdars-r/reference/IKer.epa.html","id":null,"dir":"Reference","previous_headings":"","what":"Integrated Epanechnikov Kernel — IKer.epa","title":"Integrated Epanechnikov Kernel — IKer.epa","text":"Integral Ker.epa -1 u.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/IKer.epa.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Integrated Epanechnikov Kernel — IKer.epa","text":"","code":"IKer.epa(u)"},{"path":"https://sipemu.github.io/fdars-r/reference/IKer.epa.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Integrated Epanechnikov Kernel — IKer.epa","text":"u Numeric vector evaluation points.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/IKer.epa.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Integrated Epanechnikov Kernel — IKer.epa","text":"Cumulative integral values.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/IKer.epa.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Integrated Epanechnikov Kernel — IKer.epa","text":"","code":"u <- seq(-1.5, 1.5, length.out = 100) plot(u, IKer.epa(u), type = \"l\", main = \"Integrated Epanechnikov Kernel\")"},{"path":"https://sipemu.github.io/fdars-r/reference/IKer.norm.html","id":null,"dir":"Reference","previous_headings":"","what":"Integrated Normal Kernel — IKer.norm","title":"Integrated Normal Kernel — IKer.norm","text":"Integrated Normal Kernel","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/IKer.norm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Integrated Normal Kernel — IKer.norm","text":"","code":"IKer.norm(u)"},{"path":"https://sipemu.github.io/fdars-r/reference/IKer.norm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Integrated Normal Kernel — IKer.norm","text":"u Numeric vector evaluation points.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/IKer.norm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Integrated Normal Kernel — IKer.norm","text":"Cumulative integral normal kernel -Inf u.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/IKer.norm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Integrated Normal Kernel — IKer.norm","text":"","code":"u <- seq(-3, 3, length.out = 100) plot(u, IKer.norm(u), type = \"l\", main = \"Integrated Normal Kernel\")"},{"path":"https://sipemu.github.io/fdars-r/reference/IKer.quar.html","id":null,"dir":"Reference","previous_headings":"","what":"Integrated Quartic Kernel — IKer.quar","title":"Integrated Quartic Kernel — IKer.quar","text":"Integral Ker.quar -1 u.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/IKer.quar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Integrated Quartic Kernel — IKer.quar","text":"","code":"IKer.quar(u)"},{"path":"https://sipemu.github.io/fdars-r/reference/IKer.quar.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Integrated Quartic Kernel — IKer.quar","text":"u Numeric vector evaluation points.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/IKer.quar.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Integrated Quartic Kernel — IKer.quar","text":"Cumulative integral values.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/IKer.quar.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Integrated Quartic Kernel — IKer.quar","text":"","code":"u <- seq(-1.5, 1.5, length.out = 100) plot(u, IKer.quar(u), type = \"l\", main = \"Integrated Quartic Kernel\")"},{"path":"https://sipemu.github.io/fdars-r/reference/IKer.tri.html","id":null,"dir":"Reference","previous_headings":"","what":"Integrated Triweight Kernel — IKer.tri","title":"Integrated Triweight Kernel — IKer.tri","text":"Integral Ker.tri -1 u.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/IKer.tri.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Integrated Triweight Kernel — IKer.tri","text":"","code":"IKer.tri(u)"},{"path":"https://sipemu.github.io/fdars-r/reference/IKer.tri.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Integrated Triweight Kernel — IKer.tri","text":"u Numeric vector evaluation points.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/IKer.tri.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Integrated Triweight Kernel — IKer.tri","text":"Cumulative integral values.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/IKer.tri.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Integrated Triweight Kernel — IKer.tri","text":"","code":"u <- seq(-1.5, 1.5, length.out = 100) plot(u, IKer.tri(u), type = \"l\", main = \"Integrated Triweight Kernel\")"},{"path":"https://sipemu.github.io/fdars-r/reference/IKer.unif.html","id":null,"dir":"Reference","previous_headings":"","what":"Integrated Uniform Kernel — IKer.unif","title":"Integrated Uniform Kernel — IKer.unif","text":"Integral Ker.unif -1 u.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/IKer.unif.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Integrated Uniform Kernel — IKer.unif","text":"","code":"IKer.unif(u)"},{"path":"https://sipemu.github.io/fdars-r/reference/IKer.unif.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Integrated Uniform Kernel — IKer.unif","text":"u Numeric vector evaluation points.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/IKer.unif.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Integrated Uniform Kernel — IKer.unif","text":"Cumulative integral values.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/IKer.unif.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Integrated Uniform Kernel — IKer.unif","text":"","code":"u <- seq(-1.5, 1.5, length.out = 100) plot(u, IKer.unif(u), type = \"l\", main = \"Integrated Uniform Kernel\")"},{"path":"https://sipemu.github.io/fdars-r/reference/Ker.cos.html","id":null,"dir":"Reference","previous_headings":"","what":"Cosine Kernel — Ker.cos","title":"Cosine Kernel — Ker.cos","text":"Cosine Kernel","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/Ker.cos.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cosine Kernel — Ker.cos","text":"","code":"Ker.cos(u)"},{"path":"https://sipemu.github.io/fdars-r/reference/Ker.cos.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cosine Kernel — Ker.cos","text":"u Numeric vector evaluation points.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/Ker.cos.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cosine Kernel — Ker.cos","text":"Kernel values u (0 outside [-1, 1]).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/Ker.cos.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cosine Kernel — Ker.cos","text":"","code":"u <- seq(-1.5, 1.5, length.out = 100) plot(u, Ker.cos(u), type = \"l\", main = \"Cosine Kernel\")"},{"path":"https://sipemu.github.io/fdars-r/reference/Ker.epa.html","id":null,"dir":"Reference","previous_headings":"","what":"Epanechnikov Kernel — Ker.epa","title":"Epanechnikov Kernel — Ker.epa","text":"Epanechnikov Kernel","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/Ker.epa.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Epanechnikov Kernel — Ker.epa","text":"","code":"Ker.epa(u)"},{"path":"https://sipemu.github.io/fdars-r/reference/Ker.epa.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Epanechnikov Kernel — Ker.epa","text":"u Numeric vector evaluation points.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/Ker.epa.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Epanechnikov Kernel — Ker.epa","text":"Kernel values u (0 outside [-1, 1]).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/Ker.epa.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Epanechnikov Kernel — Ker.epa","text":"","code":"u <- seq(-1.5, 1.5, length.out = 100) plot(u, Ker.epa(u), type = \"l\", main = \"Epanechnikov Kernel\")"},{"path":"https://sipemu.github.io/fdars-r/reference/Ker.norm.html","id":null,"dir":"Reference","previous_headings":"","what":"Kernel Functions — Ker.norm","title":"Kernel Functions — Ker.norm","text":"Symmetric, asymmetric, integrated kernel functions nonparametric smoothing density estimation. Normal (Gaussian) Kernel","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/Ker.norm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Kernel Functions — Ker.norm","text":"","code":"Ker.norm(u)"},{"path":"https://sipemu.github.io/fdars-r/reference/Ker.norm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Kernel Functions — Ker.norm","text":"u Numeric vector evaluation points.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/Ker.norm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Kernel Functions — Ker.norm","text":"Kernel values u.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/Ker.norm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Kernel Functions — Ker.norm","text":"","code":"u <- seq(-3, 3, length.out = 100) plot(u, Ker.norm(u), type = \"l\", main = \"Normal Kernel\")"},{"path":"https://sipemu.github.io/fdars-r/reference/Ker.quar.html","id":null,"dir":"Reference","previous_headings":"","what":"Quartic (Biweight) Kernel — Ker.quar","title":"Quartic (Biweight) Kernel — Ker.quar","text":"Quartic (Biweight) Kernel","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/Ker.quar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Quartic (Biweight) Kernel — Ker.quar","text":"","code":"Ker.quar(u)"},{"path":"https://sipemu.github.io/fdars-r/reference/Ker.quar.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Quartic (Biweight) Kernel — Ker.quar","text":"u Numeric vector evaluation points.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/Ker.quar.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Quartic (Biweight) Kernel — Ker.quar","text":"Kernel values u (0 outside [-1, 1]).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/Ker.quar.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Quartic (Biweight) Kernel — Ker.quar","text":"","code":"u <- seq(-1.5, 1.5, length.out = 100) plot(u, Ker.quar(u), type = \"l\", main = \"Quartic Kernel\")"},{"path":"https://sipemu.github.io/fdars-r/reference/Ker.tri.html","id":null,"dir":"Reference","previous_headings":"","what":"Triweight Kernel — Ker.tri","title":"Triweight Kernel — Ker.tri","text":"Triweight Kernel","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/Ker.tri.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Triweight Kernel — Ker.tri","text":"","code":"Ker.tri(u)"},{"path":"https://sipemu.github.io/fdars-r/reference/Ker.tri.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Triweight Kernel — Ker.tri","text":"u Numeric vector evaluation points.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/Ker.tri.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Triweight Kernel — Ker.tri","text":"Kernel values u (0 outside [-1, 1]).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/Ker.tri.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Triweight Kernel — Ker.tri","text":"","code":"u <- seq(-1.5, 1.5, length.out = 100) plot(u, Ker.tri(u), type = \"l\", main = \"Triweight Kernel\")"},{"path":"https://sipemu.github.io/fdars-r/reference/Ker.unif.html","id":null,"dir":"Reference","previous_headings":"","what":"Uniform (Rectangular) Kernel — Ker.unif","title":"Uniform (Rectangular) Kernel — Ker.unif","text":"Uniform (Rectangular) Kernel","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/Ker.unif.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Uniform (Rectangular) Kernel — Ker.unif","text":"","code":"Ker.unif(u)"},{"path":"https://sipemu.github.io/fdars-r/reference/Ker.unif.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Uniform (Rectangular) Kernel — Ker.unif","text":"u Numeric vector evaluation points.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/Ker.unif.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Uniform (Rectangular) Kernel — Ker.unif","text":"Kernel values u (0 outside [-1, 1]).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/Ker.unif.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Uniform (Rectangular) Kernel — Ker.unif","text":"","code":"u <- seq(-1.5, 1.5, length.out = 100) plot(u, Ker.unif(u), type = \"l\", main = \"Uniform Kernel\")"},{"path":"https://sipemu.github.io/fdars-r/reference/Kernel.asymmetric.html","id":null,"dir":"Reference","previous_headings":"","what":"Unified Asymmetric Kernel Interface — Kernel.asymmetric","title":"Unified Asymmetric Kernel Interface — Kernel.asymmetric","text":"Evaluates asymmetric kernel function name.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/Kernel.asymmetric.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Unified Asymmetric Kernel Interface — Kernel.asymmetric","text":"","code":"Kernel.asymmetric(u, type.Ker = \"norm\")"},{"path":"https://sipemu.github.io/fdars-r/reference/Kernel.asymmetric.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Unified Asymmetric Kernel Interface — Kernel.asymmetric","text":"u Numeric vector evaluation points. type.Ker Kernel type: \"norm\", \"epa\", \"tri\", \"quar\", \"cos\", \"unif\".","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/Kernel.asymmetric.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Unified Asymmetric Kernel Interface — Kernel.asymmetric","text":"Kernel values u.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/Kernel.asymmetric.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Unified Asymmetric Kernel Interface — Kernel.asymmetric","text":"","code":"u <- seq(-0.5, 1.5, length.out = 100) plot(u, Kernel.asymmetric(u, \"epa\"), type = \"l\")"},{"path":"https://sipemu.github.io/fdars-r/reference/Kernel.html","id":null,"dir":"Reference","previous_headings":"","what":"Unified Symmetric Kernel Interface — Kernel","title":"Unified Symmetric Kernel Interface — Kernel","text":"Evaluates symmetric kernel function name.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/Kernel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Unified Symmetric Kernel Interface — Kernel","text":"","code":"Kernel(u, type.Ker = \"norm\")"},{"path":"https://sipemu.github.io/fdars-r/reference/Kernel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Unified Symmetric Kernel Interface — Kernel","text":"u Numeric vector evaluation points. type.Ker Kernel type: \"norm\", \"epa\", \"tri\", \"quar\", \"cos\", \"unif\".","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/Kernel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Unified Symmetric Kernel Interface — Kernel","text":"Kernel values u.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/Kernel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Unified Symmetric Kernel Interface — Kernel","text":"","code":"u <- seq(-1.5, 1.5, length.out = 100) plot(u, Kernel(u, \"epa\"), type = \"l\") lines(u, Kernel(u, \"norm\"), col = \"red\")"},{"path":"https://sipemu.github.io/fdars-r/reference/Kernel.integrate.html","id":null,"dir":"Reference","previous_headings":"","what":"Unified Integrated Kernel Interface — Kernel.integrate","title":"Unified Integrated Kernel Interface — Kernel.integrate","text":"Evaluates integrated kernel function name.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/Kernel.integrate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Unified Integrated Kernel Interface — Kernel.integrate","text":"","code":"Kernel.integrate(u, Ker = \"norm\", a = -1)"},{"path":"https://sipemu.github.io/fdars-r/reference/Kernel.integrate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Unified Integrated Kernel Interface — Kernel.integrate","text":"u Numeric vector evaluation points. Ker Kernel type: \"norm\", \"epa\", \"tri\", \"quar\", \"cos\", \"unif\". Lower integration bound (default -1 symmetric kernels). currently used (always integrates -1 -Inf).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/Kernel.integrate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Unified Integrated Kernel Interface — Kernel.integrate","text":"Cumulative integral values.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/Kernel.integrate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Unified Integrated Kernel Interface — Kernel.integrate","text":"","code":"u <- seq(-1.5, 1.5, length.out = 100) plot(u, Kernel.integrate(u, \"epa\"), type = \"l\")"},{"path":"https://sipemu.github.io/fdars-r/reference/S.KNN.html","id":null,"dir":"Reference","previous_headings":"","what":"K-Nearest Neighbors Smoother Matrix — S.KNN","title":"K-Nearest Neighbors Smoother Matrix — S.KNN","text":"Compute smoother matrix using adaptive bandwidth based k nearest neighbors. bandwidth point distance k-th nearest neighbor.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/S.KNN.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"K-Nearest Neighbors Smoother Matrix — S.KNN","text":"","code":"S.KNN(tt, knn, Ker = \"norm\", w = NULL, cv = FALSE)"},{"path":"https://sipemu.github.io/fdars-r/reference/S.KNN.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"K-Nearest Neighbors Smoother Matrix — S.KNN","text":"tt Evaluation points (numeric vector). knn Number nearest neighbors. Ker Kernel function name. w Optional weights vector. cv Logical. TRUE, compute leave-one-cross-validation matrix.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/S.KNN.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"K-Nearest Neighbors Smoother Matrix — S.KNN","text":"n x n smoother matrix S.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/S.KNN.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"K-Nearest Neighbors Smoother Matrix — S.KNN","text":"","code":"tt <- seq(0, 1, length.out = 50) S <- S.KNN(tt, knn = 10)"},{"path":"https://sipemu.github.io/fdars-r/reference/S.LCR.html","id":null,"dir":"Reference","previous_headings":"","what":"Local Cubic Regression Smoother Matrix — S.LCR","title":"Local Cubic Regression Smoother Matrix — S.LCR","text":"Convenience function Local Polynomial Regression degree 3.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/S.LCR.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Local Cubic Regression Smoother Matrix — S.LCR","text":"","code":"S.LCR(tt, h, Ker = \"norm\", w = NULL, cv = FALSE)"},{"path":"https://sipemu.github.io/fdars-r/reference/S.LCR.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Local Cubic Regression Smoother Matrix — S.LCR","text":"tt Evaluation points (numeric vector). h Bandwidth parameter. Ker Kernel function name. w Optional weights vector. cv Logical. TRUE, compute leave-one-cross-validation matrix.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/S.LCR.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Local Cubic Regression Smoother Matrix — S.LCR","text":"n x n smoother matrix S.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/S.LCR.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Local Cubic Regression Smoother Matrix — S.LCR","text":"","code":"tt <- seq(0, 1, length.out = 50) S <- S.LCR(tt, h = 0.15)"},{"path":"https://sipemu.github.io/fdars-r/reference/S.LLR.html","id":null,"dir":"Reference","previous_headings":"","what":"Local Linear Regression Smoother Matrix — S.LLR","title":"Local Linear Regression Smoother Matrix — S.LLR","text":"Compute Local Linear Regression (LLR) smoother matrix. LLR better boundary bias properties Nadaraya-Watson.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/S.LLR.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Local Linear Regression Smoother Matrix — S.LLR","text":"","code":"S.LLR(tt, h, Ker = \"norm\", w = NULL, cv = FALSE)"},{"path":"https://sipemu.github.io/fdars-r/reference/S.LLR.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Local Linear Regression Smoother Matrix — S.LLR","text":"tt Evaluation points (numeric vector). h Bandwidth parameter. Ker Kernel function name. One \"norm\", \"epa\", \"tri\", \"quar\", \"cos\", \"unif\". w Optional weights vector length n. cv Logical. TRUE, compute leave-one-cross-validation matrix.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/S.LLR.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Local Linear Regression Smoother Matrix — S.LLR","text":"n x n smoother matrix S.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/S.LLR.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Local Linear Regression Smoother Matrix — S.LLR","text":"","code":"tt <- seq(0, 1, length.out = 50) S <- S.LLR(tt, h = 0.1)"},{"path":"https://sipemu.github.io/fdars-r/reference/S.LPR.html","id":null,"dir":"Reference","previous_headings":"","what":"Local Polynomial Regression Smoother Matrix — S.LPR","title":"Local Polynomial Regression Smoother Matrix — S.LPR","text":"Compute Local Polynomial Regression smoother matrix degree p. Special cases: p=0 Nadaraya-Watson, p=1 Local Linear Regression.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/S.LPR.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Local Polynomial Regression Smoother Matrix — S.LPR","text":"","code":"S.LPR(tt, h, p = 1, Ker = \"norm\", w = NULL, cv = FALSE)"},{"path":"https://sipemu.github.io/fdars-r/reference/S.LPR.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Local Polynomial Regression Smoother Matrix — S.LPR","text":"tt Evaluation points (numeric vector). h Bandwidth parameter. p Polynomial degree (default 1 local linear). Ker Kernel function name. w Optional weights vector. cv Logical. TRUE, compute leave-one-cross-validation matrix.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/S.LPR.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Local Polynomial Regression Smoother Matrix — S.LPR","text":"n x n smoother matrix S.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/S.LPR.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Local Polynomial Regression Smoother Matrix — S.LPR","text":"","code":"tt <- seq(0, 1, length.out = 50) S <- S.LPR(tt, h = 0.1, p = 2)  # Local quadratic regression"},{"path":"https://sipemu.github.io/fdars-r/reference/S.NW.html","id":null,"dir":"Reference","previous_headings":"","what":"Smoothing Functions for Functional Data — S.NW","title":"Smoothing Functions for Functional Data — S.NW","text":"Functions computing smoothing matrices applying kernel smoothing functional data. Nadaraya-Watson Kernel Smoother Matrix","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/S.NW.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Smoothing Functions for Functional Data — S.NW","text":"","code":"S.NW(tt, h, Ker = \"norm\", w = NULL, cv = FALSE)"},{"path":"https://sipemu.github.io/fdars-r/reference/S.NW.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Smoothing Functions for Functional Data — S.NW","text":"tt Evaluation points (numeric vector). h Bandwidth parameter. Ker Kernel function name. One \"norm\", \"epa\", \"tri\", \"quar\", \"cos\", \"unif\", custom function. w Optional weights vector length n. cv Logical. TRUE, compute leave-one-cross-validation matrix (diagonal zero).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/S.NW.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Smoothing Functions for Functional Data — S.NW","text":"n x n smoother matrix S smooth(y) = S %*% y.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/S.NW.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Smoothing Functions for Functional Data — S.NW","text":"Compute Nadaraya-Watson kernel smoother matrix.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/S.NW.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Smoothing Functions for Functional Data — S.NW","text":"","code":"tt <- seq(0, 1, length.out = 50) S <- S.NW(tt, h = 0.1) dim(S)  # 50 x 50 #> [1] 50 50"},{"path":"https://sipemu.github.io/fdars-r/reference/addError.html","id":null,"dir":"Reference","previous_headings":"","what":"Add Measurement Error to Functional Data — addError","title":"Add Measurement Error to Functional Data — addError","text":"Adds independent Gaussian noise functional data observations.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/addError.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add Measurement Error to Functional Data — addError","text":"","code":"addError(fdataobj, sd = 0.1, type = c(\"pointwise\", \"curve\"), seed = NULL)"},{"path":"https://sipemu.github.io/fdars-r/reference/addError.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add Measurement Error to Functional Data — addError","text":"fdataobj object class fdata. sd Standard deviation Gaussian noise. type Type noise: pointwise (Default) Independent noise evaluation point. f_i(t_j) gets independent noise. curve Common noise level per curve. curve gets single random value added points. seed Optional integer random seed reproducibility.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/addError.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add Measurement Error to Functional Data — addError","text":"fdata object added noise.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/reference/addError.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add Measurement Error to Functional Data — addError","text":"","code":"t <- seq(0, 1, length.out = 100) fd_clean <- simFunData(n = 20, argvals = t, M = 5, seed = 42) fd_noisy <- addError(fd_clean, sd = 0.1)  par(mfrow = c(1, 2)) plot(fd_clean, main = \"Clean Data\")  plot(fd_noisy, main = \"With Noise (sd = 0.1)\")  par(mfrow = c(1, 1))  # Higher noise level fd_very_noisy <- addError(fd_clean, sd = 0.5) plot(fd_very_noisy, main = \"High Noise (sd = 0.5)\")"},{"path":"https://sipemu.github.io/fdars-r/reference/analyze.peak.timing.html","id":null,"dir":"Reference","previous_headings":"","what":"Analyze Peak Timing Variability — analyze.peak.timing","title":"Analyze Peak Timing Variability — analyze.peak.timing","text":"short series (e.g., 3-5 years yearly data), function detects one peak per cycle analyzes peak timing varies cycles. Uses Fourier basis smoothing peak detection.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/analyze.peak.timing.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Analyze Peak Timing Variability — analyze.peak.timing","text":"","code":"analyze.peak.timing(fdataobj, period, smooth_nbasis = NULL)"},{"path":"https://sipemu.github.io/fdars-r/reference/analyze.peak.timing.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Analyze Peak Timing Variability — analyze.peak.timing","text":"fdataobj fdata object. period Known period (e.g., 365 daily data yearly seasonality). smooth_nbasis Number Fourier basis functions smoothing. NULL, uses GCV automatic selection (range 5-25). Default: NULL.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/analyze.peak.timing.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Analyze Peak Timing Variability — analyze.peak.timing","text":"list components: peak_times Vector peak times peak_values Vector peak values normalized_timing Position within cycle (0-1 scale) mean_timing Mean normalized timing std_timing Standard deviation normalized timing range_timing Range normalized timing (max - min) variability_score Variability score (0 = stable, 1 = highly variable) timing_trend Linear trend timing (positive = peaks getting later) cycle_indices Cycle indices (1-indexed)","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/analyze.peak.timing.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Analyze Peak Timing Variability — analyze.peak.timing","text":"variability score computed std_timing / 0.1, capped 1. score > 0.5 suggests peaks shifting substantially cycles. timing_trend indicates peaks systematically moving earlier later time. Fourier basis smoothing ideal seasonal signals naturally captures periodic patterns.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/analyze.peak.timing.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Analyze Peak Timing Variability — analyze.peak.timing","text":"","code":"# 5 years of yearly data where peak shifts t <- seq(0, 5, length.out = 365 * 5) periods <- c(1, 1, 1, 1, 1)  # 5 complete years # Peaks shift: March (0.2), April (0.3), May (0.4), April (0.3), March (0.2) peak_phases <- c(0.2, 0.3, 0.4, 0.3, 0.2) X <- sin(2 * pi * t + rep(peak_phases, each = 365)) fd <- fdata(matrix(X, nrow = 1), argvals = t)  result <- analyze.peak.timing(fd, period = 1) print(result$variability_score)  # Shows timing variability #> [1] 0.1233248"},{"path":"https://sipemu.github.io/fdars-r/reference/as.fdata.irregFdata.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert Irregular Functional Data to Regular Grid — as.fdata.irregFdata","title":"Convert Irregular Functional Data to Regular Grid — as.fdata.irregFdata","text":"Creates regular fdata object irregFdata object interpolating placing NA unobserved points.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/as.fdata.irregFdata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert Irregular Functional Data to Regular Grid — as.fdata.irregFdata","text":"","code":"# S3 method for class 'irregFdata' as.fdata(x, argvals = NULL, method = c(\"na\", \"linear\", \"nearest\"), ...)  as.fdata(x, ...)  # S3 method for class 'fdata' as.fdata(x, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/as.fdata.irregFdata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert Irregular Functional Data to Regular Grid — as.fdata.irregFdata","text":"x object class irregFdata. argvals Target regular grid. NULL, uses union observation points. method Interpolation method: na (Default) fill exact matches; points NA linear Linear interpolation observed points nearest Nearest neighbor interpolation ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/as.fdata.irregFdata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert Irregular Functional Data to Regular Grid — as.fdata.irregFdata","text":"fdata object NA unobserved points (unless interpolated).","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/reference/as.fdata.irregFdata.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert Irregular Functional Data to Regular Grid — as.fdata.irregFdata","text":"","code":"# Create sparse data t <- seq(0, 1, length.out = 100) fd <- simFunData(n = 10, argvals = t, M = 5, seed = 42) ifd <- sparsify(fd, minObs = 10, maxObs = 30, seed = 123)  # Convert back to regular grid with NA fd_na <- as.fdata(ifd)  # Convert with linear interpolation fd_interp <- as.fdata(ifd, method = \"linear\")"},{"path":"https://sipemu.github.io/fdars-r/reference/autoperiod.html","id":null,"dir":"Reference","previous_headings":"","what":"Autoperiod: Hybrid FFT + ACF Period Detection — autoperiod","title":"Autoperiod: Hybrid FFT + ACF Period Detection — autoperiod","text":"Implements Autoperiod algorithm (Vlachos et al. 2005) combines FFT-based candidate detection ACF validation gradient ascent refinement robust period estimation.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/autoperiod.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Autoperiod: Hybrid FFT + ACF Period Detection — autoperiod","text":"","code":"autoperiod(   fdataobj,   n_candidates = 5,   gradient_steps = 10,   detrend_method = c(\"none\", \"linear\", \"auto\") )"},{"path":"https://sipemu.github.io/fdars-r/reference/autoperiod.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Autoperiod: Hybrid FFT + ACF Period Detection — autoperiod","text":"fdataobj fdata object. n_candidates Maximum number FFT peaks consider candidates. Default: 5. candidates increases robustness also computation time. gradient_steps Number gradient ascent steps period refinement. Default: 10. steps improves precision. detrend_method Detrending method apply period estimation: \"none\" detrending (default) \"linear\" Remove linear trend \"auto\" Automatic AIC-based selection detrending method","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/autoperiod.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Autoperiod: Hybrid FFT + ACF Period Detection — autoperiod","text":"list class \"autoperiod_result\" components: period Best detected period confidence Combined confidence (normalized FFT power * ACF validation) fft_power FFT power detected period acf_validation ACF validation score (0-1) n_candidates Number candidates evaluated candidates Data frame candidate periods scores","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/autoperiod.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Autoperiod: Hybrid FFT + ACF Period Detection — autoperiod","text":"Autoperiod algorithm works three stages: Candidate Detection: Finds peaks FFT periodogram ACF Validation: Validates candidate using autocorrelation function. Checks ACF shows peak candidate period, applies harmonic analysis distinguish fundamental periods harmonics. Gradient Refinement: Refines candidate using gradient ascent ACF find exact period maximizes ACF peak. final period chosen based product normalized FFT power ACF validation score.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/autoperiod.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Autoperiod: Hybrid FFT + ACF Period Detection — autoperiod","text":"Vlachos, M., Yu, P., & Castelli, V. (2005). periodicity detection structural periodic similarity. Proceedings 2005 SIAM International Conference Data Mining.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/reference/autoperiod.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Autoperiod: Hybrid FFT + ACF Period Detection — autoperiod","text":"","code":"# Generate seasonal data with period = 2 t <- seq(0, 20, length.out = 400) X <- matrix(sin(2 * pi * t / 2) + 0.1 * rnorm(400), nrow = 1) fd <- fdata(X, argvals = t)  # Detect period using Autoperiod result <- autoperiod(fd) print(result) #> Autoperiod Detection #> -------------------- #> Period:         2.0050 #> Confidence:     0.9801 #> FFT Power:      0.5041 #> ACF Validation: 1.0000 #> Candidates:     5  # View all candidates print(result$candidates) #>      period    fft_power  acf_score combined_score #> 1 2.0050125 0.5041332413 1.00000000   9.801127e-01 #> 2 0.1230069 0.0002283611 0.55978906   2.485291e-04 #> 3 0.2108212 0.0002246269 0.47722953   2.084106e-04 #> 4 0.5168326 0.0002032098 0.00741635   2.929986e-06 #> 5 0.2194511 0.0001802642 0.47722953   1.672505e-04"},{"path":"https://sipemu.github.io/fdars-r/reference/autoplot.fdata.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a ggplot for fdata objects — autoplot.fdata","title":"Create a ggplot for fdata objects — autoplot.fdata","text":"1D functional data, plots curves lines optional coloring external variables. 2D functional data, plots surfaces heatmaps contour lines.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/autoplot.fdata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a ggplot for fdata objects — autoplot.fdata","text":"","code":"# S3 method for class 'fdata' autoplot(   object,   color = NULL,   alpha = NULL,   show.mean = FALSE,   show.ci = FALSE,   ci.level = 0.9,   palette = NULL,   ... )"},{"path":"https://sipemu.github.io/fdars-r/reference/autoplot.fdata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a ggplot for fdata objects — autoplot.fdata","text":"object object class 'fdata'. color Optional vector coloring curves. Can : Numeric vector: curves colored continuous scale (viridis) Factor/character: curves colored discrete groups Must length equal number curves. alpha Transparency individual curve lines. Default 0.7 basic plots, automatically reduced 0.3 show.mean = TRUE show.ci = TRUE reduce visual clutter allow mean curves stand . Can explicitly set override default. show.mean Logical. TRUE color categorical, overlay group mean curves thicker lines (default FALSE). show.ci Logical. TRUE color categorical, show pointwise confidence interval ribbons per group (default FALSE). ci.level Confidence level CI ribbons (default 0.90 90 percent). palette Optional named vector colors categorical coloring, e.g., c(\"\" = \"blue\", \"B\" = \"red\"). ... Additional arguments (currently ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/autoplot.fdata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a ggplot for fdata objects — autoplot.fdata","text":"ggplot object.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/autoplot.fdata.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a ggplot for fdata objects — autoplot.fdata","text":"Use autoplot() get ggplot object without displaying . Use plot() display plot (returns invisibly).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/autoplot.fdata.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a ggplot for fdata objects — autoplot.fdata","text":"","code":"library(ggplot2) # Get ggplot object without displaying fd <- fdata(matrix(rnorm(200), 20, 10)) p <- autoplot(fd)  # Customize the plot p + theme_minimal()   # Color by numeric variable y <- rnorm(20) autoplot(fd, color = y)   # Color by category with mean and CI groups <- factor(rep(c(\"A\", \"B\"), each = 10)) autoplot(fd, color = groups, show.mean = TRUE, show.ci = TRUE)"},{"path":"https://sipemu.github.io/fdars-r/reference/autoplot.irregFdata.html","id":null,"dir":"Reference","previous_headings":"","what":"Autoplot method for irregFdata objects — autoplot.irregFdata","title":"Autoplot method for irregFdata objects — autoplot.irregFdata","text":"Autoplot method irregFdata objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/autoplot.irregFdata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Autoplot method for irregFdata objects — autoplot.irregFdata","text":"","code":"# S3 method for class 'irregFdata' autoplot(object, ..., alpha = 0.7)"},{"path":"https://sipemu.github.io/fdars-r/reference/autoplot.irregFdata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Autoplot method for irregFdata objects — autoplot.irregFdata","text":"object irregFdata object. ... Additional arguments (ignored). alpha Transparency lines.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/autoplot.irregFdata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Autoplot method for irregFdata objects — autoplot.irregFdata","text":"ggplot object.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/basis.aic.html","id":null,"dir":"Reference","previous_headings":"","what":"AIC for Basis Representation — basis.aic","title":"AIC for Basis Representation — basis.aic","text":"Computes Akaike Information Criterion basis representation. Lower AIC indicates better model (balancing fit complexity).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/basis.aic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"AIC for Basis Representation — basis.aic","text":"","code":"basis.aic(   fdataobj,   nbasis,   type = c(\"bspline\", \"fourier\"),   lambda = 0,   pooled = TRUE )"},{"path":"https://sipemu.github.io/fdars-r/reference/basis.aic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"AIC for Basis Representation — basis.aic","text":"fdataobj fdata object. nbasis Number basis functions. type Basis type: \"bspline\" (default) \"fourier\". lambda Smoothing/penalty parameter (default 0). pooled Logical. TRUE (default), compute single AIC across curves. FALSE, compute AIC curve return mean.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/basis.aic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"AIC for Basis Representation — basis.aic","text":"AIC value (scalar).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/basis.aic.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"AIC for Basis Representation — basis.aic","text":"AIC computed : $$AIC = n \\log(RSS/n) + 2 \\cdot edf$$ pooled = TRUE, criterion uses total observations total effective degrees freedom (n_curves * edf). pooled = FALSE, criterion computed curve separately mean returned.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/basis.bic.html","id":null,"dir":"Reference","previous_headings":"","what":"BIC for Basis Representation — basis.bic","title":"BIC for Basis Representation — basis.bic","text":"Computes Bayesian Information Criterion basis representation. BIC penalizes complexity strongly AIC larger samples.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/basis.bic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"BIC for Basis Representation — basis.bic","text":"","code":"basis.bic(   fdataobj,   nbasis,   type = c(\"bspline\", \"fourier\"),   lambda = 0,   pooled = TRUE )"},{"path":"https://sipemu.github.io/fdars-r/reference/basis.bic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"BIC for Basis Representation — basis.bic","text":"fdataobj fdata object. nbasis Number basis functions. type Basis type: \"bspline\" (default) \"fourier\". lambda Smoothing/penalty parameter (default 0). pooled Logical. TRUE (default), compute single BIC across curves. FALSE, compute BIC curve return mean.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/basis.bic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"BIC for Basis Representation — basis.bic","text":"BIC value (scalar).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/basis.bic.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"BIC for Basis Representation — basis.bic","text":"BIC computed : $$BIC = n \\log(RSS/n) + \\log(n) \\cdot edf$$ pooled = TRUE, criterion uses total observations total effective degrees freedom (n_curves * edf). pooled = FALSE, criterion computed curve separately mean returned.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/basis.gcv.html","id":null,"dir":"Reference","previous_headings":"","what":"GCV Score for Basis Representation — basis.gcv","title":"GCV Score for Basis Representation — basis.gcv","text":"Computes Generalized Cross-Validation score basis representation. Lower GCV indicates better fit appropriate complexity.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/basis.gcv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GCV Score for Basis Representation — basis.gcv","text":"","code":"basis.gcv(   fdataobj,   nbasis,   type = c(\"bspline\", \"fourier\"),   lambda = 0,   pooled = TRUE )"},{"path":"https://sipemu.github.io/fdars-r/reference/basis.gcv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GCV Score for Basis Representation — basis.gcv","text":"fdataobj fdata object. nbasis Number basis functions. type Basis type: \"bspline\" (default) \"fourier\". lambda Smoothing/penalty parameter (default 0, penalty). pooled Logical. TRUE (default), compute single GCV across curves. FALSE, compute GCV curve return mean.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/basis.gcv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"GCV Score for Basis Representation — basis.gcv","text":"GCV score (scalar).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/basis.gcv.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"GCV Score for Basis Representation — basis.gcv","text":"GCV computed : $$GCV = \\frac{RSS/n}{(1 - edf/n)^2}$$ RSS residual sum squares edf effective degrees freedom (trace hat matrix). pooled = TRUE, criterion computed globally across curves. pooled = FALSE, criterion computed curve separately mean returned. Use pooled = FALSE curves heterogeneous noise levels.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/basis.gcv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"GCV Score for Basis Representation — basis.gcv","text":"","code":"t <- seq(0, 1, length.out = 50) X <- matrix(sin(2 * pi * t) + rnorm(50, sd = 0.1), nrow = 1) fd <- fdata(X, argvals = t)  # Compare GCV for different nbasis gcv_5 <- basis.gcv(fd, nbasis = 5) gcv_10 <- basis.gcv(fd, nbasis = 10) gcv_20 <- basis.gcv(fd, nbasis = 20)"},{"path":"https://sipemu.github.io/fdars-r/reference/basis2fdata.html","id":null,"dir":"Reference","previous_headings":"","what":"Basis Representation Functions for Functional Data — basis2fdata","title":"Basis Representation Functions for Functional Data — basis2fdata","text":"Functions representing functional data using basis expansions, including B-splines, Fourier bases, P-splines penalization. Reconstruct Functional Data Basis Coefficients","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/basis2fdata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Basis Representation Functions for Functional Data — basis2fdata","text":"","code":"basis2fdata(   coefs,   argvals,   nbasis = NULL,   type = c(\"bspline\", \"fourier\"),   rangeval = NULL )"},{"path":"https://sipemu.github.io/fdars-r/reference/basis2fdata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Basis Representation Functions for Functional Data — basis2fdata","text":"coefs Coefficient matrix [n x nbasis] n number curves nbasis number basis functions. Can also vector single curve. argvals Numeric vector evaluation points reconstruction. nbasis Number basis functions. NULL, inferred ncol(coefs). type Basis type: \"bspline\" (default) \"fourier\". rangeval Range argvals. Default: range(argvals).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/basis2fdata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Basis Representation Functions for Functional Data — basis2fdata","text":"fdata object reconstructed curves.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/basis2fdata.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Basis Representation Functions for Functional Data — basis2fdata","text":"Given basis coefficients, reconstruct functional data evaluating basis expansion specified argument values. reconstruction computes X(t) = sum(coef_k * B_k(t)) B_k basis functions evaluated argvals.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/basis2fdata.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Basis Representation Functions for Functional Data — basis2fdata","text":"","code":"# Create some functional data t <- seq(0, 1, length.out = 100) X <- matrix(sin(2 * pi * t), nrow = 1) fd <- fdata(X, argvals = t)  # Project to basis and reconstruct coefs <- fdata2basis(fd, nbasis = 15, type = \"fourier\") fd_recon <- basis2fdata(coefs, argvals = t, type = \"fourier\")"},{"path":"https://sipemu.github.io/fdars-r/reference/basis2fdata_2d.html","id":null,"dir":"Reference","previous_headings":"","what":"Reconstruct 2D Functional Data from Tensor Product Basis Coefficients — basis2fdata_2d","title":"Reconstruct 2D Functional Data from Tensor Product Basis Coefficients — basis2fdata_2d","text":"Reconstructs 2D surfaces tensor product basis coefficients.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/basis2fdata_2d.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reconstruct 2D Functional Data from Tensor Product Basis Coefficients — basis2fdata_2d","text":"","code":"basis2fdata_2d(   coefs,   argvals,   nbasis.s,   nbasis.t,   type = c(\"bspline\", \"fourier\") )"},{"path":"https://sipemu.github.io/fdars-r/reference/basis2fdata_2d.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reconstruct 2D Functional Data from Tensor Product Basis Coefficients — basis2fdata_2d","text":"coefs Coefficient matrix [n x (nbasis.s * nbasis.t)]. argvals List two numeric vectors s t coordinates. nbasis.s Number basis functions s direction. nbasis.t Number basis functions t direction. type Basis type: \"bspline\" (default) \"fourier\".","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/basis2fdata_2d.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reconstruct 2D Functional Data from Tensor Product Basis Coefficients — basis2fdata_2d","text":"2D fdata object.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/boxplot.fdata.html","id":null,"dir":"Reference","previous_headings":"","what":"Functional Boxplot — boxplot.fdata","title":"Functional Boxplot — boxplot.fdata","text":"Creates functional boxplot visualizing distribution functional data. boxplot shows median curve, central 50 percent envelope, fence (equivalent whiskers), outliers.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/boxplot.fdata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functional Boxplot — boxplot.fdata","text":"","code":"# S3 method for class 'fdata' boxplot(   x,   prob = 0.5,   factor = 1.5,   depth.func = depth.MBD,   show.outliers = TRUE,   col.median = \"black\",   col.envelope = \"magenta\",   col.fence = \"pink\",   col.outliers = \"red\",   ... )"},{"path":"https://sipemu.github.io/fdars-r/reference/boxplot.fdata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functional Boxplot — boxplot.fdata","text":"x object class 'fdata'. prob Proportion curves central region (default 0.5 50 percent). factor Factor fence calculation (default 1.5, standard boxplots). depth.func Depth function use. Default depth.MBD. show.outliers Logical. TRUE (default), show outlier curves. col.median Color median curve (default \"black\"). col.envelope Color central envelope (default \"magenta\"). col.fence Color fence region (default \"pink\"). col.outliers Color outlier curves (default \"red\"). ... Additional arguments passed depth function.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/boxplot.fdata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Functional Boxplot — boxplot.fdata","text":"list class 'fbplot' components: median Index median curve central Indices curves central region outliers Indices outlier curves depth Depth values curves plot ggplot object","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/boxplot.fdata.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Functional Boxplot — boxplot.fdata","text":"functional boxplot (Sun & Genton, 2011) generalizes standard boxplot functional data using depth ordering: Median: curve maximum depth Central region: Envelope curves top 50 percent depth Fence: 1.5 times envelope width beyond central region Outliers: Curves exceed fence point","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/boxplot.fdata.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Functional Boxplot — boxplot.fdata","text":"Sun, Y. Genton, M.G. (2011). Functional boxplots. Journal Computational Graphical Statistics, 20(2), 316-334.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/reference/boxplot.fdata.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Functional Boxplot — boxplot.fdata","text":"","code":"# Create functional data with outliers set.seed(42) t <- seq(0, 1, length.out = 50) X <- matrix(0, 30, 50) for (i in 1:28) X[i, ] <- sin(2*pi*t) + rnorm(50, sd = 0.2) X[29, ] <- sin(2*pi*t) + 2  # Magnitude outlier X[30, ] <- cos(2*pi*t)       # Shape outlier fd <- fdata(X, argvals = t)  # Create functional boxplot fbp <- boxplot(fd)"},{"path":"https://sipemu.github.io/fdars-r/reference/cfd.autoperiod.html","id":null,"dir":"Reference","previous_headings":"","what":"CFDAutoperiod: Clustered Filtered Detrended Autoperiod — cfd.autoperiod","title":"CFDAutoperiod: Clustered Filtered Detrended Autoperiod — cfd.autoperiod","text":"Implements CFDAutoperiod algorithm (Puech et al. 2020) applies first-order differencing detrending, uses density-based clustering spectral peaks ACF validation original signal.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/cfd.autoperiod.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CFDAutoperiod: Clustered Filtered Detrended Autoperiod — cfd.autoperiod","text":"","code":"cfd.autoperiod(fdataobj, cluster_tolerance = 0.1, min_cluster_size = 1)"},{"path":"https://sipemu.github.io/fdars-r/reference/cfd.autoperiod.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"CFDAutoperiod: Clustered Filtered Detrended Autoperiod — cfd.autoperiod","text":"fdataobj fdata object. cluster_tolerance Relative tolerance clustering nearby period candidates. Default: 0.1 (10% relative difference). Candidates within tolerance grouped clusters. min_cluster_size Minimum number candidates required form valid cluster. Default: 1.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/cfd.autoperiod.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"CFDAutoperiod: Clustered Filtered Detrended Autoperiod — cfd.autoperiod","text":"list class \"cfd_autoperiod_result\" components: period Primary detected period (best validated cluster center) confidence Combined confidence (ACF validation * spectral power) acf_validation ACF validation score primary period n_periods Number validated period clusters periods detected period cluster centers confidences Confidence scores detected period","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/cfd.autoperiod.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"CFDAutoperiod: Clustered Filtered Detrended Autoperiod — cfd.autoperiod","text":"CFDAutoperiod algorithm works five stages: Differencing: First-order differencing removes polynomial trends FFT: Computes periodogram detrended signal Peak Detection: Finds peaks noise floor Clustering: Groups nearby period candidates clusters ACF Validation: Validates cluster centers using ACF original (non-differenced) signal method particularly effective : Signals strong polynomial trends Multiple concurrent periodicities Signals spectral leakage creates nearby spurious peaks","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/cfd.autoperiod.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"CFDAutoperiod: Clustered Filtered Detrended Autoperiod — cfd.autoperiod","text":"Puech, T., Boussard, M., D'Amato, ., & Millerand, G. (2020). fully automated periodicity detection time series. Advanced Analytics Learning Temporal Data (pp. 43-54). Springer.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/reference/cfd.autoperiod.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"CFDAutoperiod: Clustered Filtered Detrended Autoperiod — cfd.autoperiod","text":"","code":"# Generate data with trend t <- seq(0, 20, length.out = 400) X <- matrix(0.2 * t + sin(2 * pi * t / 2), nrow = 1) fd <- fdata(X, argvals = t)  # CFDAutoperiod handles trends via differencing result <- cfd.autoperiod(fd) print(result) #> CFDAutoperiod Detection #> ----------------------- #> Primary Period: 2.0000 #> Confidence:     0.8939 #> ACF Validation: 0.8939 #> Periods Found:  1  # Multiple periods detected X2 <- matrix(sin(2 * pi * t / 2) + 0.5 * sin(2 * pi * t / 5), nrow = 1) fd2 <- fdata(X2, argvals = t) result2 <- cfd.autoperiod(fd2) print(result2$periods)  # All detected periods #> [1] 2"},{"path":"https://sipemu.github.io/fdars-r/reference/classify.seasonality.html","id":null,"dir":"Reference","previous_headings":"","what":"Classify Seasonality Type — classify.seasonality","title":"Classify Seasonality Type — classify.seasonality","text":"Classifies type seasonality functional data. Particularly useful short series (3-5 years) identify stable vs variable timing patterns.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/classify.seasonality.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Classify Seasonality Type — classify.seasonality","text":"","code":"classify.seasonality(   fdataobj,   period,   strength_threshold = NULL,   timing_threshold = NULL )"},{"path":"https://sipemu.github.io/fdars-r/reference/classify.seasonality.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Classify Seasonality Type — classify.seasonality","text":"fdataobj fdata object. period Known seasonal period. strength_threshold Threshold seasonal/non-seasonal (default: 0.3). timing_threshold Max std normalized timing \"stable\" (default: 0.05).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/classify.seasonality.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Classify Seasonality Type — classify.seasonality","text":"list components: is_seasonal Logical: series seasonal overall? has_stable_timing Logical: peak timing stable across cycles? timing_variability Timing variability score (0-1) seasonal_strength Overall seasonal strength cycle_strengths Per-cycle seasonal strength weak_seasons Indices weak/missing seasons (0-indexed) classification One : \"StableSeasonal\", \"VariableTiming\", \"IntermittentSeasonal\", \"NonSeasonal\" peak_timing Peak timing analysis (peaks detected)","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/classify.seasonality.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Classify Seasonality Type — classify.seasonality","text":"Classification types: StableSeasonal: Regular peaks consistent timing VariableTiming: Regular peaks timing shifts cycles IntermittentSeasonal: cycles seasonal, NonSeasonal: clear seasonality","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/classify.seasonality.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Classify Seasonality Type — classify.seasonality","text":"","code":"# Pure seasonal signal t <- seq(0, 10, length.out = 500) X <- matrix(sin(2 * pi * t / 2), nrow = 1) fd <- fdata(X, argvals = t)  result <- classify.seasonality(fd, period = 2) print(result$classification)  # \"StableSeasonal\" #> [1] \"StableSeasonal\""},{"path":"https://sipemu.github.io/fdars-r/reference/cluster.fcm.html","id":null,"dir":"Reference","previous_headings":"","what":"Fuzzy C-Means Clustering for Functional Data — cluster.fcm","title":"Fuzzy C-Means Clustering for Functional Data — cluster.fcm","text":"Performs fuzzy c-means clustering functional data, curve membership degree cluster rather hard assignment.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/cluster.fcm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fuzzy C-Means Clustering for Functional Data — cluster.fcm","text":"","code":"cluster.fcm(fdataobj, ncl, m = 2, max.iter = 100, tol = 1e-06, seed = NULL)"},{"path":"https://sipemu.github.io/fdars-r/reference/cluster.fcm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fuzzy C-Means Clustering for Functional Data — cluster.fcm","text":"fdataobj object class 'fdata'. ncl Number clusters. m Fuzziness parameter (default 2). Must > 1. Higher values give softer cluster boundaries. max.iter Maximum number iterations (default 100). tol Convergence tolerance (default 1e-6). seed Optional random seed reproducibility.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/cluster.fcm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fuzzy C-Means Clustering for Functional Data — cluster.fcm","text":"list class 'fuzzycmeans.fd' components: membership Matrix membership degrees (n x ncl). row sums 1. cluster Hard cluster assignments (argmax membership). centers fdata object containing cluster centers. objective Final value objective function. fdataobj input functional data object.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/cluster.fcm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fuzzy C-Means Clustering for Functional Data — cluster.fcm","text":"Fuzzy c-means minimizes objective function: $$J = \\sum_{=1}^n \\sum_{c=1}^k u_{ic}^m ||X_i - v_c||^2$$ u_ic membership curve cluster c, v_c cluster center, m fuzziness parameter. membership degrees updated : $$u_{ic} = 1 / \\sum_{j=1}^k (d_{ic}/d_{ij})^{2/(m-1)}$$ m approaches 1, FCM becomes equivalent hard k-means. m increases, clusters become softer (overlap). m = 2 common choice.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/reference/cluster.fcm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fuzzy C-Means Clustering for Functional Data — cluster.fcm","text":"","code":"# Create functional data with THREE groups - one genuinely overlapping set.seed(42) t <- seq(0, 1, length.out = 50) n <- 45 X <- matrix(0, n, 50)  # Group 1: Sine waves centered at 0 for (i in 1:15) X[i, ] <- sin(2*pi*t) + rnorm(50, sd = 0.2) # Group 2: Sine waves centered at 1.5 (clearly separated from group 1) for (i in 16:30) X[i, ] <- sin(2*pi*t) + 1.5 + rnorm(50, sd = 0.2) # Group 3: Between groups 1 and 2 (true overlap - ambiguous membership) for (i in 31:45) X[i, ] <- sin(2*pi*t) + 0.75 + rnorm(50, sd = 0.3)  fd <- fdata(X, argvals = t)  # Fuzzy clustering reveals the overlap fcm <- cluster.fcm(fd, ncl = 3, seed = 123)  # Curves in group 3 (31-45) have split membership - this is the key benefit! cat(\"Membership for curves 31-35 (overlap region):\\n\") #> Membership for curves 31-35 (overlap region): print(round(fcm$membership[31:35, ], 2)) #>      [,1] [,2] [,3] #> [1,] 0.02 0.02 0.96 #> [2,] 0.01 0.01 0.97 #> [3,] 0.01 0.02 0.96 #> [4,] 0.02 0.04 0.94 #> [5,] 0.02 0.01 0.97  # Compare to hard clustering which forces a decision km <- cluster.kmeans(fd, ncl = 3, seed = 123) cat(\"\\nHard vs Fuzzy assignment for curve 35:\\n\") #>  #> Hard vs Fuzzy assignment for curve 35: cat(\"K-means cluster:\", km$cluster[35], \"\\n\") #> K-means cluster: 3  cat(\"FCM memberships:\", round(fcm$membership[35, ], 2), \"\\n\") #> FCM memberships: 0.02 0.01 0.97"},{"path":"https://sipemu.github.io/fdars-r/reference/cluster.init.html","id":null,"dir":"Reference","previous_headings":"","what":"K-Means++ Center Initialization — cluster.init","title":"K-Means++ Center Initialization — cluster.init","text":"Initialize cluster centers using k-means++ algorithm, selects centers probability proportional squared distance existing centers.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/cluster.init.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"K-Means++ Center Initialization — cluster.init","text":"","code":"cluster.init(fdataobj, ncl, metric = \"L2\", seed = NULL)"},{"path":"https://sipemu.github.io/fdars-r/reference/cluster.init.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"K-Means++ Center Initialization — cluster.init","text":"fdataobj object class 'fdata'. ncl Number clusters. metric Metric use. One \"L2\", \"L1\", \"Linf\". seed Optional random seed.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/cluster.init.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"K-Means++ Center Initialization — cluster.init","text":"fdata object containing initial cluster centers.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/cluster.init.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"K-Means++ Center Initialization — cluster.init","text":"","code":"t <- seq(0, 1, length.out = 50) X <- matrix(rnorm(30 * 50), 30, 50) fd <- fdata(X, argvals = t) init_centers <- cluster.init(fd, ncl = 3)"},{"path":"https://sipemu.github.io/fdars-r/reference/cluster.kmeans.html","id":null,"dir":"Reference","previous_headings":"","what":"Clustering Functions for Functional Data — cluster.kmeans","title":"Clustering Functions for Functional Data — cluster.kmeans","text":"Functions clustering functional data, including k-means related algorithms. Functional K-Means Clustering","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/cluster.kmeans.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Clustering Functions for Functional Data — cluster.kmeans","text":"","code":"cluster.kmeans(   fdataobj,   ncl,   metric = \"L2\",   max.iter = 100,   nstart = 10,   seed = NULL,   draw = FALSE,   ... )"},{"path":"https://sipemu.github.io/fdars-r/reference/cluster.kmeans.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Clustering Functions for Functional Data — cluster.kmeans","text":"fdataobj object class 'fdata'. ncl Number clusters. metric Either string (\"L2\", \"L1\", \"Linf\") fast Rust-based distance computation, metric/semimetric function (e.g., metric.lp, metric.hausdorff, semimetric.pca). Using function provides flexibility may slower semimetrics computed R. max.iter Maximum number iterations (default 100). nstart Number random starts (default 10). best result (lowest within-cluster sum squares) returned. seed Optional random seed reproducibility. draw Logical. TRUE, plot clustered curves (yet implemented). ... Additional arguments passed metric function.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/cluster.kmeans.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Clustering Functions for Functional Data — cluster.kmeans","text":"list class 'cluster.kmeans' components: cluster Integer vector cluster assignments (1 ncl). centers fdata object containing cluster centers. withinss Within-cluster sum squares cluster. tot.withinss Total within-cluster sum squares. size Number observations cluster. fdataobj input functional data object.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/cluster.kmeans.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Clustering Functions for Functional Data — cluster.kmeans","text":"Performs k-means clustering functional data using specified metric. Uses k-means++ initialization better initial centers. metric string (\"L2\", \"L1\", \"Linf\"), entire k-means algorithm runs Rust parallel processing, providing 50-200x speedup. metric function, distances computed using function. Functions like metric.lp, metric.hausdorff, metric.DTW Rust backends remain fast. Semimetric functions (semimetric.*) computed R slower large datasets.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/cluster.kmeans.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Clustering Functions for Functional Data — cluster.kmeans","text":"","code":"# Create functional data with two groups t <- seq(0, 1, length.out = 50) n <- 30 X <- matrix(0, n, 50) true_cluster <- rep(1:2, each = 15) for (i in 1:n) {   if (true_cluster[i] == 1) {     X[i, ] <- sin(2*pi*t) + rnorm(50, sd = 0.1)   } else {     X[i, ] <- cos(2*pi*t) + rnorm(50, sd = 0.1)   } } fd <- fdata(X, argvals = t)  # Cluster with string metric (fast Rust path) result <- cluster.kmeans(fd, ncl = 2, metric = \"L2\") table(result$cluster, true_cluster) #>    true_cluster #>      1  2 #>   1 15  0 #>   2  0 15  # Cluster with metric function (also fast - Rust backend) result2 <- cluster.kmeans(fd, ncl = 2, metric = metric.lp)  # Cluster with semimetric (flexible but slower) result3 <- cluster.kmeans(fd, ncl = 2, metric = semimetric.pca, ncomp = 3)"},{"path":"https://sipemu.github.io/fdars-r/reference/cluster.optim.html","id":null,"dir":"Reference","previous_headings":"","what":"Optimal Number of Clusters for Functional K-Means — cluster.optim","title":"Optimal Number of Clusters for Functional K-Means — cluster.optim","text":"Determines optimal number clusters functional k-means clustering using various criteria: elbow method, silhouette score, Calinski-Harabasz index.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/cluster.optim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimal Number of Clusters for Functional K-Means — cluster.optim","text":"","code":"cluster.optim(   fdataobj,   ncl.range = 2:10,   criterion = c(\"silhouette\", \"CH\", \"elbow\"),   metric = \"L2\",   max.iter = 100,   nstart = 10,   seed = NULL,   ... )"},{"path":"https://sipemu.github.io/fdars-r/reference/cluster.optim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Optimal Number of Clusters for Functional K-Means — cluster.optim","text":"fdataobj object class 'fdata'. ncl.range Range number clusters evaluate. Default 2:10. criterion Criterion use selecting optimal k: \"silhouette\" Mean silhouette coefficient (default). Higher better. \"CH\" Calinski-Harabasz index. Higher better. \"elbow\" Within-cluster sum squares. Look elbow plot. metric Either string (\"L2\", \"L1\", \"Linf\") metric function. max.iter Maximum iterations k-means (default 100). nstart Number random starts (default 10). seed Random seed reproducibility. ... Additional arguments passed cluster.kmeans.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/cluster.optim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Optimal Number of Clusters for Functional K-Means — cluster.optim","text":"list class 'cluster.optim' components: optimal.k Optimal number clusters based criterion criterion Name criterion used scores Vector criterion values k ncl.range Range k values tested models List cluster.kmeans objects k best.model cluster.kmeans object optimal k","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/cluster.optim.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Optimal Number of Clusters for Functional K-Means — cluster.optim","text":"Silhouette score: Measures similar curve cluster compared clusters. Values range -1 1, higher better. Optimal k maximizes mean silhouette. Calinski-Harabasz index: Ratio -cluster within-cluster dispersion. Higher values indicate better defined clusters. Optimal k maximizes CH. Elbow method: Plots total within-cluster sum squares vs k. optimal k \"elbow\" adding clusters significantly reduce WSS. subjective best assessed visually using plot().","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/cluster.optim.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Optimal Number of Clusters for Functional K-Means — cluster.optim","text":"","code":"# Create functional data with 3 groups set.seed(42) t <- seq(0, 1, length.out = 50) n <- 60 X <- matrix(0, n, 50) true_k <- rep(1:3, each = 20) for (i in 1:n) {   if (true_k[i] == 1) {     X[i, ] <- sin(2*pi*t) + rnorm(50, sd = 0.1)   } else if (true_k[i] == 2) {     X[i, ] <- cos(2*pi*t) + rnorm(50, sd = 0.1)   } else {     X[i, ] <- sin(4*pi*t) + rnorm(50, sd = 0.1)   } } fd <- fdata(X, argvals = t)  # Find optimal k using silhouette opt <- cluster.optim(fd, ncl.range = 2:6, criterion = \"silhouette\") print(opt) #> Optimal K-Means Clustering #> ========================== #> Criterion: silhouette  #> K range tested: 2 - 6  #> Optimal k: 3  #>  #> Scores by k: #>  k  score #>  2 0.5673 #>  3 0.8597 #>  4 0.5849 #>  5 0.5865 #>  6 0.3127 plot(opt)"},{"path":"https://sipemu.github.io/fdars-r/reference/cov.html","id":null,"dir":"Reference","previous_headings":"","what":"Functional Covariance Function — cov","title":"Functional Covariance Function — cov","text":"Computes covariance function (surface) functional data. 1D: Cov(s, t) = E[(X(s) - mu(s))(X(t) - mu(t))] 2D: Covariance across flattened domain.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/cov.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functional Covariance Function — cov","text":"","code":"cov(fdataobj, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/cov.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functional Covariance Function — cov","text":"fdataobj object class 'fdata'. ... Additional arguments (currently ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/cov.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Functional Covariance Function — cov","text":"list components: cov covariance matrix (m x m 1D, (m1m2) x (m1m2) 2D) argvals evaluation points (input) mean mean function","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/cov.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Functional Covariance Function — cov","text":"","code":"# 1D functional data t <- seq(0, 1, length.out = 50) X <- matrix(0, 20, 50) for (i in 1:20) X[i, ] <- sin(2*pi*t) + rnorm(50, sd = 0.2) fd <- fdata(X, argvals = t) cov_result <- cov(fd) image(cov_result$cov, main = \"Covariance Surface\")"},{"path":"https://sipemu.github.io/fdars-r/reference/decompose.html","id":null,"dir":"Reference","previous_headings":"","what":"Seasonal-Trend Decomposition — decompose","title":"Seasonal-Trend Decomposition — decompose","text":"Decomposes functional data trend, seasonal, remainder components. Similar STL (Seasonal-Trend decomposition using LOESS).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/decompose.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Seasonal-Trend Decomposition — decompose","text":"","code":"decompose(   fdataobj,   period = NULL,   method = c(\"additive\", \"multiplicative\"),   trend_method = c(\"loess\", \"spline\"),   bandwidth = 0.3,   n_harmonics = 3 )"},{"path":"https://sipemu.github.io/fdars-r/reference/decompose.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Seasonal-Trend Decomposition — decompose","text":"fdataobj fdata object. period Seasonal period. NULL, estimated automatically using FFT. method Decomposition method: \"additive\" data = trend + seasonal + remainder (default) \"multiplicative\" data = trend * seasonal * remainder trend_method Method trend extraction: \"loess\" \"spline\". Default: \"loess\". bandwidth Bandwidth trend extraction (fraction range). Default: 0.3. n_harmonics Number Fourier harmonics seasonal component. Default: 3.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/decompose.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Seasonal-Trend Decomposition — decompose","text":"list components: trend fdata object trend component seasonal fdata object seasonal component remainder fdata object remainder/residual period Period used decomposition method Decomposition method (\"additive\" \"multiplicative\")","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/decompose.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Seasonal-Trend Decomposition — decompose","text":"additive decomposition: data = trend + seasonal + remainder. trend extracted using LOESS spline smoothing, seasonal component estimated fitting Fourier harmonics detrended data. multiplicative decomposition: data = trend * seasonal * remainder. achieved log-transforming data, applying additive decomposition, back-transforming. Use seasonal amplitude grows trend level.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/reference/decompose.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Seasonal-Trend Decomposition — decompose","text":"","code":"# Additive seasonal pattern t <- seq(0, 20, length.out = 400) X <- matrix(2 + 0.3 * t + sin(2 * pi * t / 2.5), nrow = 1) fd <- fdata(X, argvals = t)  result <- decompose(fd, period = 2.5, method = \"additive\") # plot(result$trend)      # Linear trend # plot(result$seasonal)   # Sinusoidal seasonal # plot(result$remainder)  # Residual noise  # Multiplicative pattern (amplitude grows with level) X_mult <- matrix((2 + 0.3 * t) * (1 + 0.3 * sin(2 * pi * t / 2.5)), nrow = 1) fd_mult <- fdata(X_mult, argvals = t)  result_mult <- decompose(fd_mult, period = 2.5, method = \"multiplicative\")"},{"path":"https://sipemu.github.io/fdars-r/reference/depth.BD.html","id":null,"dir":"Reference","previous_headings":"","what":"Band Depth — depth.BD","title":"Band Depth — depth.BD","text":"Wrapper depth(method = \"BD\"). Useful function argument.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/depth.BD.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Band Depth — depth.BD","text":"","code":"depth.BD(fdataobj, fdataori = NULL, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/depth.BD.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Band Depth — depth.BD","text":"fdataobj object class 'fdata'. fdataori Reference sample (default: fdataobj ). ... Additional arguments.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/depth.BD.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Band Depth — depth.BD","text":"Numeric vector depth values.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/reference/depth.FM.html","id":null,"dir":"Reference","previous_headings":"","what":"Fraiman-Muniz Depth — depth.FM","title":"Fraiman-Muniz Depth — depth.FM","text":"Wrapper depth(method = \"FM\"). Useful function argument.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/depth.FM.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fraiman-Muniz Depth — depth.FM","text":"","code":"depth.FM(fdataobj, fdataori = NULL, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/depth.FM.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fraiman-Muniz Depth — depth.FM","text":"fdataobj object class 'fdata'. fdataori Reference sample (default: fdataobj ). ... Additional arguments.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/depth.FM.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fraiman-Muniz Depth — depth.FM","text":"Numeric vector depth values.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/reference/depth.FSD.html","id":null,"dir":"Reference","previous_headings":"","what":"Functional Spatial Depth — depth.FSD","title":"Functional Spatial Depth — depth.FSD","text":"Wrapper depth(method = \"FSD\"). Useful function argument.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/depth.FSD.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functional Spatial Depth — depth.FSD","text":"","code":"depth.FSD(fdataobj, fdataori = NULL, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/depth.FSD.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functional Spatial Depth — depth.FSD","text":"fdataobj object class 'fdata'. fdataori Reference sample (default: fdataobj ). ... Additional arguments.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/depth.FSD.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Functional Spatial Depth — depth.FSD","text":"Numeric vector depth values.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/reference/depth.KFSD.html","id":null,"dir":"Reference","previous_headings":"","what":"Kernel Functional Spatial Depth — depth.KFSD","title":"Kernel Functional Spatial Depth — depth.KFSD","text":"Wrapper depth(method = \"KFSD\"). Useful function argument.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/depth.KFSD.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Kernel Functional Spatial Depth — depth.KFSD","text":"","code":"depth.KFSD(fdataobj, fdataori = NULL, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/depth.KFSD.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Kernel Functional Spatial Depth — depth.KFSD","text":"fdataobj object class 'fdata'. fdataori Reference sample (default: fdataobj ). ... Additional arguments.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/depth.KFSD.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Kernel Functional Spatial Depth — depth.KFSD","text":"Numeric vector depth values.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/reference/depth.MBD.html","id":null,"dir":"Reference","previous_headings":"","what":"Modified Band Depth — depth.MBD","title":"Modified Band Depth — depth.MBD","text":"Wrapper depth(method = \"MBD\"). Useful function argument.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/depth.MBD.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Modified Band Depth — depth.MBD","text":"","code":"depth.MBD(fdataobj, fdataori = NULL, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/depth.MBD.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Modified Band Depth — depth.MBD","text":"fdataobj object class 'fdata'. fdataori Reference sample (default: fdataobj ). ... Additional arguments.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/depth.MBD.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Modified Band Depth — depth.MBD","text":"Numeric vector depth values.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/reference/depth.MEI.html","id":null,"dir":"Reference","previous_headings":"","what":"Modified Epigraph Index — depth.MEI","title":"Modified Epigraph Index — depth.MEI","text":"Wrapper depth(method = \"MEI\"). Useful function argument.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/depth.MEI.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Modified Epigraph Index — depth.MEI","text":"","code":"depth.MEI(fdataobj, fdataori = NULL, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/depth.MEI.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Modified Epigraph Index — depth.MEI","text":"fdataobj object class 'fdata'. fdataori Reference sample (default: fdataobj ). ... Additional arguments.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/depth.MEI.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Modified Epigraph Index — depth.MEI","text":"Numeric vector depth values.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/reference/depth.RP.html","id":null,"dir":"Reference","previous_headings":"","what":"Random Projection Depth — depth.RP","title":"Random Projection Depth — depth.RP","text":"Wrapper depth(method = \"RP\"). Useful function argument.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/depth.RP.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random Projection Depth — depth.RP","text":"","code":"depth.RP(fdataobj, fdataori = NULL, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/depth.RP.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random Projection Depth — depth.RP","text":"fdataobj object class 'fdata'. fdataori Reference sample (default: fdataobj ). ... Additional arguments.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/depth.RP.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random Projection Depth — depth.RP","text":"Numeric vector depth values.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/reference/depth.RPD.html","id":null,"dir":"Reference","previous_headings":"","what":"Random Projection Depth with Derivatives — depth.RPD","title":"Random Projection Depth with Derivatives — depth.RPD","text":"Wrapper depth(method = \"RPD\"). Useful function argument.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/depth.RPD.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random Projection Depth with Derivatives — depth.RPD","text":"","code":"depth.RPD(fdataobj, fdataori = NULL, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/depth.RPD.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random Projection Depth with Derivatives — depth.RPD","text":"fdataobj object class 'fdata'. fdataori Reference sample (default: fdataobj ). ... Additional arguments.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/depth.RPD.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random Projection Depth with Derivatives — depth.RPD","text":"Numeric vector depth values.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/reference/depth.RT.html","id":null,"dir":"Reference","previous_headings":"","what":"Random Tukey Depth — depth.RT","title":"Random Tukey Depth — depth.RT","text":"Wrapper depth(method = \"RT\"). Useful function argument.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/depth.RT.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random Tukey Depth — depth.RT","text":"","code":"depth.RT(fdataobj, fdataori = NULL, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/depth.RT.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random Tukey Depth — depth.RT","text":"fdataobj object class 'fdata'. fdataori Reference sample (default: fdataobj ). ... Additional arguments.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/depth.RT.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random Tukey Depth — depth.RT","text":"Numeric vector depth values.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/reference/depth.html","id":null,"dir":"Reference","previous_headings":"","what":"Depth Functions for Functional Data — depth","title":"Depth Functions for Functional Data — depth","text":"Functions computing various depth measures functional data. Compute Functional Data Depth","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/depth.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Depth Functions for Functional Data — depth","text":"","code":"depth(   fdataobj,   fdataori = NULL,   method = c(\"FM\", \"mode\", \"RP\", \"RT\", \"BD\", \"MBD\", \"MEI\", \"FSD\", \"KFSD\", \"RPD\"),   ... )"},{"path":"https://sipemu.github.io/fdars-r/reference/depth.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Depth Functions for Functional Data — depth","text":"fdataobj object class 'fdata' compute depth . fdataori object class 'fdata' reference sample. NULL, uses fdataobj reference. method Depth method use. One \"FM\" (Fraiman-Muniz), \"mode\" (modal), \"RP\" (random projection), \"RT\" (random Tukey), \"BD\" (band depth), \"MBD\" (modified band depth), \"MEI\" (modified epigraph index), \"FSD\" (functional spatial depth), \"KFSD\" (kernel functional spatial depth), \"RPD\" (random projection derivatives). Default \"FM\". ... Additional arguments passed specific depth function.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/depth.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Depth Functions for Functional Data — depth","text":"numeric vector depth values, one per curve fdataobj.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/depth.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Depth Functions for Functional Data — depth","text":"Unified interface computing various depth measures functional data. Available methods: FM Fraiman-Muniz depth - integrates univariate depths domain mode Modal depth - based kernel density estimation RP Random projection depth - projects random directions RT Random Tukey depth - halfspace depth via random projections BD Band depth - proportion bands containing curve (1D ) MBD Modified band depth - allows partial containment (1D ) MEI Modified epigraph index - proportion time curves (1D ) FSD Functional spatial depth - based spatial signs KFSD Kernel functional spatial depth - smoothed FSD RPD Random projection derivatives - includes curve derivatives","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/depth.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Depth Functions for Functional Data — depth","text":"","code":"fd <- fdata(matrix(rnorm(100), 10, 10))  # Different depth methods depth(fd, method = \"FM\") #>  [1] 0.48 0.46 0.40 0.66 0.52 0.36 0.52 0.66 0.52 0.42 depth(fd, method = \"mode\") #>  [1] 0.2714079 0.1717654 0.2102241 0.2917229 0.2032817 0.1923078 0.2250097 #>  [8] 0.2894317 0.2493039 0.1962121 depth(fd, method = \"RP\") #>  [1] 0.2836364 0.2109091 0.2654545 0.3109091 0.3218182 0.2672727 0.2781818 #>  [8] 0.2454545 0.3018182 0.2418182"},{"path":"https://sipemu.github.io/fdars-r/reference/depth.mode.html","id":null,"dir":"Reference","previous_headings":"","what":"Modal Depth — depth.mode","title":"Modal Depth — depth.mode","text":"Wrapper depth(method = \"mode\"). Useful function argument.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/depth.mode.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Modal Depth — depth.mode","text":"","code":"depth.mode(fdataobj, fdataori = NULL, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/depth.mode.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Modal Depth — depth.mode","text":"fdataobj object class 'fdata'. fdataori Reference sample (default: fdataobj ). ... Additional arguments.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/depth.mode.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Modal Depth — depth.mode","text":"Numeric vector depth values.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/reference/deriv.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute functional derivative — deriv","title":"Compute functional derivative — deriv","text":"Compute numerical derivative functional data. Uses finite differences fast computation via Rust.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/deriv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute functional derivative — deriv","text":"","code":"deriv(   fdataobj,   nderiv = 1,   method = \"diff\",   class.out = \"fdata\",   nbasis = NULL,   ... )"},{"path":"https://sipemu.github.io/fdars-r/reference/deriv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute functional derivative — deriv","text":"fdataobj object class 'fdata'. nderiv Derivative order (1, 2, ...). Default 1. 2D data, first-order derivatives currently supported. method Method computing derivatives. Currently \"diff\" (finite differences) supported. class.Output class, either \"fdata\" \"fd\". Default \"fdata\". nbasis used (compatibility fda.usc). ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/deriv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute functional derivative — deriv","text":"1D data: 'fdata' object containing derivative values. 2D data: list components ds, dt, dsdt, 'fdata' object containing respective partial derivative.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/deriv.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute functional derivative — deriv","text":"1D functional data (curves), computes nth derivative. 2D functional data (surfaces), computes partial derivatives: ds: partial derivative respect s (first argument) dt: partial derivative respect t (second argument) dsdt: mixed partial derivative","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/deriv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute functional derivative — deriv","text":"","code":"# Create smooth curves t <- seq(0, 2*pi, length.out = 100) X <- matrix(0, 10, 100) for (i in 1:10) X[i, ] <- sin(t + i/5) fd <- fdata(X, argvals = t)  # First derivative (should be approximately cos) fd_deriv <- deriv(fd, nderiv = 1)"},{"path":"https://sipemu.github.io/fdars-r/reference/detect.peaks.html","id":null,"dir":"Reference","previous_headings":"","what":"Detect Peaks in Functional Data — detect.peaks","title":"Detect Peaks in Functional Data — detect.peaks","text":"Detects local maxima (peaks) functional data using derivative zero-crossings. Returns peak times, values, prominence measures.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/detect.peaks.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detect Peaks in Functional Data — detect.peaks","text":"","code":"detect.peaks(   fdataobj,   min_distance = NULL,   min_prominence = NULL,   smooth_first = FALSE,   smooth_nbasis = NULL,   detrend_method = c(\"none\", \"linear\", \"auto\") )"},{"path":"https://sipemu.github.io/fdars-r/reference/detect.peaks.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Detect Peaks in Functional Data — detect.peaks","text":"fdataobj fdata object. min_distance Minimum time peaks. Default: NULL (constraint). min_prominence Minimum prominence peak (0-1 scale). Peaks lower prominence filtered . Default: NULL (filter). smooth_first Logical. TRUE, apply Fourier basis smoothing peak detection. Recommended noisy data. Default: FALSE. smooth_nbasis Number Fourier basis functions smoothing. NULL smooth_first=TRUE, uses GCV automatically select optimal nbasis (range 5-25). Default: NULL (auto). detrend_method Detrending method apply peak detection: \"none\" detrending (default) \"linear\" Remove linear trend \"auto\" Automatic AIC-based selection detrending method","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/detect.peaks.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Detect Peaks in Functional Data — detect.peaks","text":"list components: peaks List data frames, one per curve, columns: time, value, prominence inter_peak_distances List numeric vectors distances consecutive peaks mean_period Mean inter-peak distance across curves (estimates period)","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/detect.peaks.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Detect Peaks in Functional Data — detect.peaks","text":"Peak prominence measures much peak stands surroundings. computed height difference peak highest two minimum values either side, normalized data range. Fourier basis smoothing ideal seasonal signals naturally captures periodic patterns without introducing boundary artifacts. data trends, use detrend_method remove trend detecting peaks. prevents trend affecting peak prominence calculations.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/detect.peaks.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Detect Peaks in Functional Data — detect.peaks","text":"","code":"# Generate data with clear peaks t <- seq(0, 10, length.out = 200) X <- matrix(sin(2 * pi * t / 2), nrow = 1) fd <- fdata(X, argvals = t)  # Detect peaks peaks <- detect.peaks(fd, min_distance = 1.5) print(peaks$mean_period)  # Should be close to 2 #> [1] 2.01005  # With automatic Fourier smoothing (GCV selects nbasis) peaks_smooth <- detect.peaks(fd, min_distance = 1.5, smooth_first = TRUE)  # With detrending for trending data X_trend <- matrix(2 + 0.5 * t + sin(2 * pi * t / 2), nrow = 1) fd_trend <- fdata(X_trend, argvals = t) peaks_det <- detect.peaks(fd_trend, detrend_method = \"linear\")"},{"path":"https://sipemu.github.io/fdars-r/reference/detect.period.html","id":null,"dir":"Reference","previous_headings":"","what":"Seasonal Analysis Functions for Functional Data — detect.period","title":"Seasonal Analysis Functions for Functional Data — detect.period","text":"Functions analyzing seasonal patterns functional data including period estimation, peak detection, seasonal strength measurement, detection seasonality changes. Detect Period Multiple Methods","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/detect.period.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Seasonal Analysis Functions for Functional Data — detect.period","text":"","code":"detect.period(   fdataobj,   method = c(\"sazed\", \"autoperiod\", \"cfd\", \"fft\", \"acf\"),   ... )"},{"path":"https://sipemu.github.io/fdars-r/reference/detect.period.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Seasonal Analysis Functions for Functional Data — detect.period","text":"fdataobj fdata object. method Detection method use: \"sazed\" SAZED ensemble (default) - parameter-free, robust \"autoperiod\" Autoperiod - hybrid FFT + ACF gradient ascent \"cfd\" CFDAutoperiod - differencing + clustering + ACF validation \"fft\" Simple FFT periodogram peak \"acf\" Simple ACF peak detection ... Additional arguments passed underlying method: tolerance SAZED: relative tolerance voting (default 0.1) n_candidates Autoperiod: max FFT peaks consider (default 5) gradient_steps Autoperiod: refinement steps (default 10) cluster_tolerance CFD: clustering tolerance (default 0.1) min_cluster_size CFD: minimum cluster size (default 1) max_lag ACF: maximum lag search detrend_method FFT/ACF: \"none\", \"linear\", \"auto\"","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/detect.period.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Seasonal Analysis Functions for Functional Data — detect.period","text":"period detection result. exact class depends method: sazed_result SAZED method autoperiod_result Autoperiod method cfd_autoperiod_result CFD method period_estimate FFT ACF methods","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/detect.period.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Seasonal Analysis Functions for Functional Data — detect.period","text":"Unified interface period detection dispatches specialized algorithms based chosen method. Provides single entry point period detection functionality. Method selection guidance: sazed: Best general-purpose choice. Combines 5 methods uses voting - robust across signal types tuning needed. autoperiod: Good need candidate details gradient-refined estimates. Slightly precise SAZED. cfd: Best signals strong polynomial trends. Also detects multiple concurrent periods. fft: Fastest, sensitive noise trends. acf: Simple effective clean periodic signals.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/reference/detect.period.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Seasonal Analysis Functions for Functional Data — detect.period","text":"","code":"# Generate seasonal data t <- seq(0, 20, length.out = 400) X <- matrix(sin(2 * pi * t / 2) + 0.1 * rnorm(400), nrow = 1) fd <- fdata(X, argvals = t)  # Default (SAZED) - most robust result <- detect.period(fd) print(result$period) #> [1] 2.003616  # Autoperiod with custom settings result <- detect.period(fd, method = \"autoperiod\", n_candidates = 10)  # CFDAutoperiod for trended data X_trend <- matrix(0.3 * t + sin(2 * pi * t / 2), nrow = 1) fd_trend <- fdata(X_trend, argvals = t) result <- detect.period(fd_trend, method = \"cfd\")  # Simple FFT for speed result <- detect.period(fd, method = \"fft\")"},{"path":"https://sipemu.github.io/fdars-r/reference/detect.periods.html","id":null,"dir":"Reference","previous_headings":"","what":"Detect Multiple Concurrent Periods — detect.periods","title":"Detect Multiple Concurrent Periods — detect.periods","text":"Detects multiple periodicities functional data using iterative residual subtraction. iteration, dominant period detected using FFT, sinusoidal component subtracted, process repeats residual stopping criteria met.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/detect.periods.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detect Multiple Concurrent Periods — detect.periods","text":"","code":"detect.periods(   fdataobj,   max_periods = 3,   min_confidence = 0.5,   min_strength = 0.2,   detrend_method = c(\"auto\", \"none\", \"linear\") )"},{"path":"https://sipemu.github.io/fdars-r/reference/detect.periods.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Detect Multiple Concurrent Periods — detect.periods","text":"fdataobj fdata object. max_periods Maximum number periods detect. Default: 3. min_confidence Minimum FFT confidence continue detection. Default: 0.5. min_strength Minimum seasonal strength continue detection. Default: 0.2. detrend_method Detrending method apply period detection: \"auto\" Automatic AIC-based selection detrending method (default) \"none\" detrending \"linear\" Remove linear trend","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/detect.periods.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Detect Multiple Concurrent Periods — detect.periods","text":"list components: periods Numeric vector detected periods confidence FFT confidence period strength Seasonal strength period amplitude Amplitude sinusoidal component phase Phase sinusoidal component (radians) n_periods Number periods detected","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/detect.periods.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Detect Multiple Concurrent Periods — detect.periods","text":"function uses two stopping criteria: FFT confidence: prominent dominant frequency Seasonal strength: much variance explained periodicity must exceed thresholds detection continue. Higher thresholds result fewer (reliable) detected periods. Periods detected order amplitude (FFT power), period length. weak yearly cycle detected strong weekly cycle. Trends can interfere period detection. default \"auto\" detrending automatically selects appropriate method remove trends.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/reference/detect.periods.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Detect Multiple Concurrent Periods — detect.periods","text":"","code":"# Signal with two periods: 2 and 7 t <- seq(0, 20, length.out = 400) X <- sin(2 * pi * t / 2) + 0.6 * sin(2 * pi * t / 7) fd <- fdata(matrix(X, nrow = 1), argvals = t)  # Detect multiple periods result <- detect.periods(fd, max_periods = 3) print(result$periods)  # Should find approximately 2 and 7 #> [1]  2.005013  6.683375 10.025063 print(result$n_periods)  # Should be 2 #> [1] 3"},{"path":"https://sipemu.github.io/fdars-r/reference/detect.seasonality.changes.auto.html","id":null,"dir":"Reference","previous_headings":"","what":"Detect Seasonality Changes with Automatic Threshold — detect.seasonality.changes.auto","title":"Detect Seasonality Changes with Automatic Threshold — detect.seasonality.changes.auto","text":"Detects points seasonality starts stops, using automatic threshold selection instead fixed value.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/detect.seasonality.changes.auto.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detect Seasonality Changes with Automatic Threshold — detect.seasonality.changes.auto","text":"","code":"detect.seasonality.changes.auto(   fdataobj,   period,   threshold_method = \"otsu\",   threshold_value = NULL,   window_size = NULL,   min_duration = NULL )"},{"path":"https://sipemu.github.io/fdars-r/reference/detect.seasonality.changes.auto.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Detect Seasonality Changes with Automatic Threshold — detect.seasonality.changes.auto","text":"fdataobj fdata object. period Known seasonal period. threshold_method Method threshold selection: \"fixed\" Use threshold_value fixed threshold \"percentile\" Use threshold_value percentile strength distribution \"otsu\" Use Otsu's method bimodal separation (default) threshold_value Value \"fixed\" \"percentile\" methods. window_size Width sliding window strength estimation. Default: 2 * period. min_duration Minimum duration confirm change. Default: period.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/detect.seasonality.changes.auto.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Detect Seasonality Changes with Automatic Threshold — detect.seasonality.changes.auto","text":"list components: change_points Data frame time, type, strength_before, strength_after strength_curve Time-varying seasonal strength used detection computed_threshold threshold computed/used","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/detect.seasonality.changes.auto.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Detect Seasonality Changes with Automatic Threshold — detect.seasonality.changes.auto","text":"Otsu's method automatically finds optimal threshold separating seasonal non-seasonal regions based strength distribution. particularly useful know appropriate threshold data.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/detect.seasonality.changes.auto.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Detect Seasonality Changes with Automatic Threshold — detect.seasonality.changes.auto","text":"","code":"# Signal that transitions from seasonal to non-seasonal t <- seq(0, 20, length.out = 400) X <- ifelse(t < 10, sin(2 * pi * t / 2), rnorm(sum(t >= 10), sd = 0.3)) X <- matrix(X, nrow = 1) fd <- fdata(X, argvals = t)  # Detect changes with Otsu threshold changes <- detect.seasonality.changes.auto(fd, period = 2) print(changes$computed_threshold) #> [1] 0.516327"},{"path":"https://sipemu.github.io/fdars-r/reference/detect.seasonality.changes.html","id":null,"dir":"Reference","previous_headings":"","what":"Detect Changes in Seasonality — detect.seasonality.changes","title":"Detect Changes in Seasonality — detect.seasonality.changes","text":"Detects points time seasonality starts (onset) stops (cessation) monitoring time-varying seasonal strength.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/detect.seasonality.changes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detect Changes in Seasonality — detect.seasonality.changes","text":"","code":"detect.seasonality.changes(   fdataobj,   period,   threshold = 0.3,   window_size = NULL,   min_duration = NULL )"},{"path":"https://sipemu.github.io/fdars-r/reference/detect.seasonality.changes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Detect Changes in Seasonality — detect.seasonality.changes","text":"fdataobj fdata object. period Known estimated period. threshold Seasonal strength threshold classification (0-1). threshold = seasonal, = non-seasonal. Default: 0.3. window_size Width sliding window strength estimation. Default: 2 * period. min_duration Minimum duration confirm change. Prevents detection spurious short-term fluctuations. Default: period.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/detect.seasonality.changes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Detect Changes in Seasonality — detect.seasonality.changes","text":"list components: change_points Data frame columns: time, type (\"onset\" \"cessation\"), strength_before, strength_after strength_curve Time-varying seasonal strength used detection","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/detect.seasonality.changes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Detect Changes in Seasonality — detect.seasonality.changes","text":"","code":"# Signal that starts non-seasonal, becomes seasonal, then stops t <- seq(0, 30, length.out = 600) X <- ifelse(t < 10, rnorm(sum(t < 10), sd = 0.3),             ifelse(t < 20, sin(2 * pi * t[t >= 10 & t < 20] / 2),                    rnorm(sum(t >= 20), sd = 0.3))) X <- matrix(X, nrow = 1) fd <- fdata(X, argvals = t)  # Detect changes changes <- detect.seasonality.changes(fd, period = 2) print(changes$change_points)  # Should show onset ~10, cessation ~20 #>        time      type strength_before strength_after #> 1  8.664441     onset       0.2830366      0.3494510 #> 2 20.183639 cessation       0.3052235      0.2953254"},{"path":"https://sipemu.github.io/fdars-r/reference/detect_amplitude_modulation.html","id":null,"dir":"Reference","previous_headings":"","what":"Detect Amplitude Modulation in Seasonal Time Series — detect_amplitude_modulation","title":"Detect Amplitude Modulation in Seasonal Time Series — detect_amplitude_modulation","text":"Detects whether amplitude seasonal pattern changes time (amplitude modulation). Uses either Hilbert transform wavelet analysis extract time-varying amplitude envelope.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/detect_amplitude_modulation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detect Amplitude Modulation in Seasonal Time Series — detect_amplitude_modulation","text":"","code":"detect_amplitude_modulation(   fdataobj,   period,   method = c(\"hilbert\", \"wavelet\"),   modulation_threshold = 0.15,   seasonality_threshold = 0.3 )"},{"path":"https://sipemu.github.io/fdars-r/reference/detect_amplitude_modulation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Detect Amplitude Modulation in Seasonal Time Series — detect_amplitude_modulation","text":"fdataobj fdata object. period Seasonal period argvals units. method Method amplitude extraction: \"hilbert\" (default) \"wavelet\". modulation_threshold Coefficient variation threshold detecting modulation. Default: 0.15 (.e., CV > 15% indicates modulation). seasonality_threshold Strength threshold seasonality detection. Default: 0.3.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/detect_amplitude_modulation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Detect Amplitude Modulation in Seasonal Time Series — detect_amplitude_modulation","text":"list components: is_seasonal Logical, whether seasonality detected seasonal_strength Overall seasonal strength (spectral method) has_modulation Logical, whether amplitude modulation detected modulation_type Character: \"stable\", \"emerging\", \"fading\", \"oscillating\", \"non_seasonal\" modulation_score Coefficient variation amplitude (0 = stable) amplitude_trend Trend amplitude (-1 1): negative = fading, positive = emerging amplitude_curve Time-varying amplitude (fdata object) time_points Time points amplitude curve","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/detect_amplitude_modulation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Detect Amplitude Modulation in Seasonal Time Series — detect_amplitude_modulation","text":"function first checks seasonality present using spectral method (robust amplitude modulation). seasonality detected, extracts amplitude envelope analyzes variation. Hilbert method: Uses Hilbert transform compute analytic signal extract instantaneous amplitude. Fast assumes narrowband signals. Wavelet method: Uses Morlet wavelet transform target period. robust noise non-stationarity. Modulation types: stable: Constant amplitude (modulation_score < threshold) emerging: Amplitude increases time (amplitude_trend > 0.3) fading: Amplitude decreases time (amplitude_trend < -0.3) oscillating: Amplitude varies clear trend non_seasonal: seasonality detected","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/detect_amplitude_modulation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Detect Amplitude Modulation in Seasonal Time Series — detect_amplitude_modulation","text":"","code":"# Generate data with emerging seasonality t <- seq(0, 1, length.out = 200) amplitude <- 0.2 + 0.8 * t  # Amplitude grows over time X <- matrix(amplitude * sin(2 * pi * t / 0.2), nrow = 1) fd <- fdata(X, argvals = t)  result <- detect_amplitude_modulation(fd, period = 0.2) print(result$modulation_type)  # \"emerging\" #> [1] \"emerging\" print(result$amplitude_trend)  # Positive value #> [1] 1  # Compare Hilbert vs Wavelet methods result_hilbert <- detect_amplitude_modulation(fd, period = 0.2, method = \"hilbert\") result_wavelet <- detect_amplitude_modulation(fd, period = 0.2, method = \"wavelet\")"},{"path":"https://sipemu.github.io/fdars-r/reference/detrend.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove Trend from Functional Data — detrend","title":"Remove Trend from Functional Data — detrend","text":"Removes trend functional data using various methods. useful preprocessing data seasonal analysis data significant trend component.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/detrend.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove Trend from Functional Data — detrend","text":"","code":"detrend(   fdataobj,   method = c(\"linear\", \"polynomial\", \"diff1\", \"diff2\", \"loess\", \"auto\"),   degree = 2,   bandwidth = 0.3,   return_trend = FALSE )"},{"path":"https://sipemu.github.io/fdars-r/reference/detrend.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove Trend from Functional Data — detrend","text":"fdataobj fdata object. method Detrending method: \"linear\" Least squares linear fit (default) \"polynomial\" Polynomial regression specified degree \"diff1\" First-order differencing \"diff2\" Second-order differencing \"loess\" Local polynomial regression (LOESS) \"auto\" Automatic selection via AIC degree Polynomial degree \"polynomial\" method. Default: 2. bandwidth Bandwidth fraction data range \"loess\" method. Default: 0.3. return_trend Logical. TRUE, return trend detrended data. Default: FALSE.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/detrend.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove Trend from Functional Data — detrend","text":"return_trend = FALSE, fdata object detrended data. return_trend = TRUE, list components: detrended fdata object detrended data trend fdata object estimated trend method Method used detrending rss Residual sum squares per curve","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/detrend.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Remove Trend from Functional Data — detrend","text":"series polynomial trends, \"linear\" \"polynomial\" methods appropriate. complex trends, \"loess\" provides flexibility. \"auto\" method compares linear, polynomial (degree 2 3), LOESS, selecting method lowest AIC. Differencing methods (\"diff1\", \"diff2\") reduce series length 1 2 points respectively. resulting fdata correspondingly shorter argvals.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/reference/detrend.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Remove Trend from Functional Data — detrend","text":"","code":"# Generate data with linear trend and seasonal component t <- seq(0, 10, length.out = 200) X <- matrix(2 + 0.5 * t + sin(2 * pi * t / 2), nrow = 1) fd <- fdata(X, argvals = t)  # Detrend with linear method fd_detrended <- detrend(fd, method = \"linear\")  # Now estimate period on detrended data period <- estimate.period(fd_detrended) print(period$period)  # Should be close to 2 #> [1] 2.01005  # Get both trend and detrended data result <- detrend(fd, method = \"linear\", return_trend = TRUE) # plot(result$trend)  # Shows the linear trend"},{"path":"https://sipemu.github.io/fdars-r/reference/df_to_fdata2d.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert DataFrame to 2D functional data — df_to_fdata2d","title":"Convert DataFrame to 2D functional data — df_to_fdata2d","text":"Converts data frame long format 2D fdata object (surfaces). expected format : one identifier column, one column s-dimension index, multiple columns t-dimension values.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/df_to_fdata2d.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert DataFrame to 2D functional data — df_to_fdata2d","text":"","code":"df_to_fdata2d(   df,   id_col = 1,   s_col = 2,   t_cols = NULL,   names = NULL,   metadata = NULL )"},{"path":"https://sipemu.github.io/fdars-r/reference/df_to_fdata2d.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert DataFrame to 2D functional data — df_to_fdata2d","text":"df data frame structure described . id_col Name index identifier column (default: 1). s_col Name index s-dimension column (default: 2). t_cols Names indices t-dimension value columns. NULL (default), uses columns s_col. names Optional list 'main', 'xlab', 'ylab', 'zlab' labels. metadata Optional data.frame additional covariates (one row per surface). metadata \"id\" column non-default row names, must match surface identifiers id_col.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/df_to_fdata2d.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert DataFrame to 2D functional data — df_to_fdata2d","text":"object class 'fdata' 2D functional data.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/df_to_fdata2d.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert DataFrame to 2D functional data — df_to_fdata2d","text":"expected data frame structure : Column 1 (id_col): Surface identifier (e.g., \"surface_1\", \"surface_2\") Column 2 (s_col): Index s-dimension (row index surface) Columns 3+ (t_cols): Values t-dimension point (columns surface) unique identifier represents one surface. surface, m1 rows (one per s-value), m2 t-columns, resulting m1 x m2 surface.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/df_to_fdata2d.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert DataFrame to 2D functional data — df_to_fdata2d","text":"","code":"# Create example data frame df <- data.frame(   id = rep(c(\"surf1\", \"surf2\"), each = 5),   s = rep(1:5, 2),   t1 = rnorm(10),   t2 = rnorm(10),   t3 = rnorm(10) ) fd <- df_to_fdata2d(df) print(fd) #> Functional data object #>   Type: 2D (surface)  #>   Number of observations: 2  #>   Grid dimensions: 5 x 3  #>   Range s: 1 - 5  #>   Range t: 1 - 3   # With metadata meta <- data.frame(group = c(\"A\", \"B\"), value = c(1.5, 2.3)) fd <- df_to_fdata2d(df, metadata = meta)"},{"path":"https://sipemu.github.io/fdars-r/reference/dot-onLoad.html","id":null,"dir":"Reference","previous_headings":"","what":"Package initialization — .onLoad","title":"Package initialization — .onLoad","text":"Package initialization","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/dot-onLoad.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Package initialization — .onLoad","text":"","code":".onLoad(libname, pkgname)"},{"path":"https://sipemu.github.io/fdars-r/reference/eFun.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Eigenfunction Basis — eFun","title":"Generate Eigenfunction Basis — eFun","text":"Evaluates orthonormal eigenfunction bases specified argument values. eigenfunctions can used Karhunen-Loeve simulation.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/eFun.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Eigenfunction Basis — eFun","text":"","code":"eFun(argvals, M, type = c(\"Fourier\", \"Poly\", \"PolyHigh\", \"Wiener\"))"},{"path":"https://sipemu.github.io/fdars-r/reference/eFun.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Eigenfunction Basis — eFun","text":"argvals Numeric vector evaluation points [0, 1]. M Number eigenfunctions generate. type Character. Type eigenfunction system: Fourier Fourier basis: 1, sqrt(2)sin(2pikt), sqrt(2)cos(2pikt) Poly Orthonormal Legendre polynomials degrees 0, 1, ..., M-1 PolyHigh Orthonormal Legendre polynomials starting degree 2 Wiener Wiener process eigenfunctions: sqrt(2)*sin((k-0.5)pit)","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/eFun.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Eigenfunction Basis — eFun","text":"matrix dimension length(argvals) x M containing eigenfunction values. column eigenfunction, normalized unit L2 norm [0, 1].","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/eFun.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Eigenfunction Basis — eFun","text":"eigenfunctions orthonormal respect L2 inner product: integral(phi_j * phi_k) = 1 j == k, 0 otherwise. Fourier Suitable periodic data. First function constant. Poly Orthonormalized Legendre polynomials. Good smooth data. PolyHigh Legendre polynomials starting degree 2, useful linear constant components handled separately. Wiener Eigenfunctions Brownian motion covariance. Eigenvalues decay 1/((k-0.5)*pi)^2.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/reference/eFun.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Eigenfunction Basis — eFun","text":"","code":"t <- seq(0, 1, length.out = 100)  # Generate Fourier basis phi_fourier <- eFun(t, M = 5, type = \"Fourier\") matplot(t, phi_fourier, type = \"l\", lty = 1,         main = \"Fourier Eigenfunctions\", ylab = expression(phi(t)))   # Generate Wiener eigenfunctions phi_wiener <- eFun(t, M = 5, type = \"Wiener\") matplot(t, phi_wiener, type = \"l\", lty = 1,         main = \"Wiener Eigenfunctions\", ylab = expression(phi(t)))   # Check orthonormality (should be identity matrix) dt <- diff(t)[1] gram <- t(phi_fourier) %*% phi_fourier * dt round(gram, 2) #>      [,1] [,2] [,3] [,4] [,5] #> [1,] 1.01    0 0.01    0 0.01 #> [2,] 0.00    1 0.00    0 0.00 #> [3,] 0.01    0 1.02    0 0.02 #> [4,] 0.00    0 0.00    1 0.00 #> [5,] 0.01    0 0.02    0 1.02"},{"path":"https://sipemu.github.io/fdars-r/reference/eVal.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Eigenvalue Sequence — eVal","title":"Generate Eigenvalue Sequence — eVal","text":"Generates eigenvalue sequences different decay patterns. control variance contribution mode Karhunen-Loeve simulation.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/eVal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Eigenvalue Sequence — eVal","text":"","code":"eVal(M, type = c(\"linear\", \"exponential\", \"wiener\"))"},{"path":"https://sipemu.github.io/fdars-r/reference/eVal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Eigenvalue Sequence — eVal","text":"M Number eigenvalues generate. type Character. Type eigenvalue decay: linear lambda_k = 1/k k = 1, ..., M exponential lambda_k = exp(-k) k = 1, ..., M wiener lambda_k = 1/((k - 0.5)*pi)^2, Wiener process eigenvalues","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/eVal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Eigenvalue Sequence — eVal","text":"numeric vector length M containing eigenvalues decreasing order.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/eVal.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Eigenvalue Sequence — eVal","text":"eigenvalues control much variance eigenfunction contributes simulated curves: linear Slow decay, higher modes contribute variation. Produces rougher curves. exponential Fast decay, higher modes contribute little. Produces smoother curves. wiener Specific decay matching Brownian motion. Use Wiener eigenfunctions true Brownian motion simulation.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/reference/eVal.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Eigenvalue Sequence — eVal","text":"","code":"# Compare decay patterns lambda_lin <- eVal(20, \"linear\") lambda_exp <- eVal(20, \"exponential\") lambda_wie <- eVal(20, \"wiener\")  plot(1:20, lambda_lin, type = \"b\", log = \"y\", ylim = c(1e-10, 1),      main = \"Eigenvalue Decay Patterns\", xlab = \"k\", ylab = expression(lambda[k])) lines(1:20, lambda_exp, col = \"red\", type = \"b\") lines(1:20, lambda_wie, col = \"blue\", type = \"b\") legend(\"topright\", c(\"Linear\", \"Exponential\", \"Wiener\"),        col = c(\"black\", \"red\", \"blue\"), lty = 1, pch = 1)"},{"path":"https://sipemu.github.io/fdars-r/reference/estimate.period.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate Seasonal Period using FFT — estimate.period","title":"Estimate Seasonal Period using FFT — estimate.period","text":"Estimates dominant period functional data using Fast Fourier Transform periodogram analysis.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/estimate.period.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate Seasonal Period using FFT — estimate.period","text":"","code":"estimate.period(   fdataobj,   method = c(\"fft\", \"acf\"),   max_lag = NULL,   detrend_method = c(\"none\", \"linear\", \"auto\") )"},{"path":"https://sipemu.github.io/fdars-r/reference/estimate.period.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate Seasonal Period using FFT — estimate.period","text":"fdataobj fdata object. method Method period estimation: \"fft\" (Fast Fourier Transform, default) \"acf\" (autocorrelation function). max_lag Maximum lag ACF method. Default: half series length. detrend_method Detrending method apply period estimation: \"none\" detrending (default) \"linear\" Remove linear trend \"auto\" Automatic AIC-based selection detrending method","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/estimate.period.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate Seasonal Period using FFT — estimate.period","text":"list components: period Estimated period frequency Dominant frequency (1/period) power Power dominant frequency confidence Confidence measure (ratio peak power mean power)","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/estimate.period.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Estimate Seasonal Period using FFT — estimate.period","text":"function computes periodogram mean curve finds frequency maximum power. confidence measure indicates pronounced dominant frequency relative background. data trends, detrend_method parameter can significantly improve period estimation accuracy. Strong trends can mask true seasonal period.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/estimate.period.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate Seasonal Period using FFT — estimate.period","text":"","code":"# Generate seasonal data with period = 2 t <- seq(0, 10, length.out = 200) X <- matrix(sin(2 * pi * t / 2) + rnorm(200, sd = 0.1), nrow = 1) fd <- fdata(X, argvals = t)  # Estimate period result <- estimate.period(fd, method = \"fft\") print(result$period)  # Should be close to 2 #> [1] 2.01005  # With trend - detrending improves estimation X_trend <- matrix(2 + 0.5 * t + sin(2 * pi * t / 2), nrow = 1) fd_trend <- fdata(X_trend, argvals = t) result <- estimate.period(fd_trend, detrend_method = \"linear\")"},{"path":"https://sipemu.github.io/fdars-r/reference/fdars-package.html","id":null,"dir":"Reference","previous_headings":"","what":"fdars: Functional Data Analysis in Rust — fdars-package","title":"fdars: Functional Data Analysis in Rust — fdars-package","text":"Functional data analysis tools high-performance Rust backend. Provides methods functional data manipulation, depth computation, distance metrics, regression, statistical testing. Supports 1D functional data (curves) 2D functional data (surfaces).","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/reference/fdars-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"fdars: Functional Data Analysis in Rust — fdars-package","text":"Maintainer: Simon Müller simon.mueller@muon-stat.com","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fdata.bootstrap.ci.html","id":null,"dir":"Reference","previous_headings":"","what":"Bootstrap Confidence Intervals for Functional Statistics — fdata.bootstrap.ci","title":"Bootstrap Confidence Intervals for Functional Statistics — fdata.bootstrap.ci","text":"Compute bootstrap confidence intervals functional statistics mean function, depth values, regression coefficients.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fdata.bootstrap.ci.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bootstrap Confidence Intervals for Functional Statistics — fdata.bootstrap.ci","text":"","code":"fdata.bootstrap.ci(   fdataobj,   statistic,   n.boot = 200,   alpha = 0.05,   method = c(\"percentile\", \"basic\", \"normal\"),   seed = NULL )"},{"path":"https://sipemu.github.io/fdars-r/reference/fdata.bootstrap.ci.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bootstrap Confidence Intervals for Functional Statistics — fdata.bootstrap.ci","text":"fdataobj object class 'fdata'. statistic function computes statistic interest. Must take fdata object return numeric vector. n.boot Number bootstrap replications (default 200). alpha Significance level confidence intervals (default 0.05 95 percent CI). method CI method: \"percentile\" simple percentile method, \"basic\" basic bootstrap, \"normal\" normal approximation (default \"percentile\"). seed Optional seed reproducibility.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fdata.bootstrap.ci.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bootstrap Confidence Intervals for Functional Statistics — fdata.bootstrap.ci","text":"list class 'fdata.bootstrap.ci' components: estimate statistic computed original data ci.lower Lower confidence bound ci.upper Upper confidence bound boot.stats Matrix bootstrap statistics (n.boot x length(statistic)) alpha significance level used method CI method used","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fdata.bootstrap.ci.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Bootstrap Confidence Intervals for Functional Statistics — fdata.bootstrap.ci","text":"","code":"# Create functional data t <- seq(0, 1, length.out = 50) X <- matrix(0, 20, 50) for (i in 1:20) X[i, ] <- sin(2*pi*t) + rnorm(50, sd = 0.1) fd <- fdata(X, argvals = t)  # Bootstrap CI for the mean function (returns numeric vector) ci_mean <- fdata.bootstrap.ci(fd,   statistic = function(x) as.numeric(mean(x)$data),   n.boot = 100)  # Bootstrap CI for depth values ci_depth <- fdata.bootstrap.ci(fd,   statistic = function(x) depth.FM(x),   n.boot = 100)"},{"path":"https://sipemu.github.io/fdars-r/reference/fdata.bootstrap.html","id":null,"dir":"Reference","previous_headings":"","what":"Bootstrap Functional Data — fdata.bootstrap","title":"Bootstrap Functional Data — fdata.bootstrap","text":"Generate bootstrap samples functional data. Supports naive bootstrap (resampling curves replacement) smooth bootstrap (adding noise based estimated covariance structure).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fdata.bootstrap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bootstrap Functional Data — fdata.bootstrap","text":"","code":"fdata.bootstrap(   fdataobj,   n.boot = 200,   method = c(\"naive\", \"smooth\"),   variance = NULL,   seed = NULL )"},{"path":"https://sipemu.github.io/fdars-r/reference/fdata.bootstrap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bootstrap Functional Data — fdata.bootstrap","text":"fdataobj object class 'fdata'. n.boot Number bootstrap replications (default 200). method Bootstrap method: \"naive\" resampling replacement, \"smooth\" adding Gaussian noise (default \"naive\"). variance method=\"smooth\", variance added noise. NULL, estimated data. seed Optional seed reproducibility.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fdata.bootstrap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bootstrap Functional Data — fdata.bootstrap","text":"list class 'fdata.bootstrap' components: boot.samples List n.boot fdata objects, bootstrap sample original original fdata object method bootstrap method used n.boot Number bootstrap replications","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fdata.bootstrap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Bootstrap Functional Data — fdata.bootstrap","text":"","code":"# Create functional data t <- seq(0, 1, length.out = 50) X <- matrix(0, 20, 50) for (i in 1:20) X[i, ] <- sin(2*pi*t) + rnorm(50, sd = 0.1) fd <- fdata(X, argvals = t)  # Naive bootstrap boot_naive <- fdata.bootstrap(fd, n.boot = 100, method = \"naive\")  # Smooth bootstrap boot_smooth <- fdata.bootstrap(fd, n.boot = 100, method = \"smooth\")"},{"path":"https://sipemu.github.io/fdars-r/reference/fdata.cen.html","id":null,"dir":"Reference","previous_headings":"","what":"Center functional data — fdata.cen","title":"Center functional data — fdata.cen","text":"Subtract mean function curve.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fdata.cen.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Center functional data — fdata.cen","text":"","code":"fdata.cen(fdataobj)"},{"path":"https://sipemu.github.io/fdars-r/reference/fdata.cen.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Center functional data — fdata.cen","text":"fdataobj object class 'fdata'.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fdata.cen.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Center functional data — fdata.cen","text":"centered 'fdata' object.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fdata.cen.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Center functional data — fdata.cen","text":"","code":"fd <- fdata(matrix(rnorm(100), 10, 10)) fd_centered <- fdata.cen(fd)"},{"path":"https://sipemu.github.io/fdars-r/reference/fdata.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a functional data object — fdata","title":"Create a functional data object — fdata","text":"Creates fdata object 1D functional data (curves) 2D functional data (surfaces). 2D data, internal storage uses flattened matrix format [n, m1*m2] row represents surface stored row-major order.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fdata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a functional data object — fdata","text":"","code":"fdata(   mdata,   argvals = NULL,   rangeval = NULL,   names = NULL,   fdata2d = FALSE,   id = NULL,   metadata = NULL )"},{"path":"https://sipemu.github.io/fdars-r/reference/fdata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a functional data object — fdata","text":"mdata Input data. Can : 1D: matrix [n, m] n number curves, m number evaluation points 2D: 3D array [n, m1, m2] n number surfaces, m1 x m2 grid size. Automatically detected converted flattened storage. 2D: matrix [n, m1*m2] (already flattened) argvals specifying grid dimensions 2D: single surface matrix [m1, m2] argvals specifying grid dimensions argvals Evaluation points. 1D: numeric vector. 2D: list two numeric vectors specifying s t coordinates. rangeval Range argument values. 1D: numeric vector length 2. 2D: list two numeric vectors length 2. names List components 'main', 'xlab', 'ylab' plot titles. 2D, also 'zlab' surface value label. fdata2d Logical. TRUE, create 2D functional data (surface). Automatically set TRUE mdata 3D array. id Optional character vector identifiers observation. NULL, uses row names mdata generates \"obs_1\", \"obs_2\", etc. metadata Optional data.frame additional covariates (one row per observation). metadata \"id\" column non-default row names, must match id parameter.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fdata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a functional data object — fdata","text":"object class 'fdata' containing: data data matrix. 2D: flattened [n, m1*m2] format argvals Evaluation points rangeval Range arguments names Plot labels fdata2d Logical indicating 2D dims 2D : c(m1, m2) grid dimensions id Character vector observation identifiers metadata Data frame additional covariates (NULL)","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fdata.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a functional data object — fdata","text":"2D functional data, surfaces stored internally flattened matrix row surface row-major order. extract single surface matrix, use subsetting drop = TRUE reshape manually:","code":"# Extract surface i as matrix surface_i <- fd[i, drop = TRUE] # Or manually: surface_i <- matrix(fd$data[i, ], nrow = fd$dims[1], ncol = fd$dims[2])"},{"path":"https://sipemu.github.io/fdars-r/reference/fdata.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a functional data object — fdata","text":"","code":"# Create 1D functional data (curves) x <- matrix(rnorm(100), nrow = 10, ncol = 10) fd <- fdata(x, argvals = seq(0, 1, length.out = 10))  # Create with identifiers and metadata meta <- data.frame(group = rep(c(\"A\", \"B\"), 5), endpoint = rnorm(10)) fd <- fdata(x, id = paste0(\"patient_\", 1:10), metadata = meta)  # Access metadata fd$id #>  [1] \"patient_1\"  \"patient_2\"  \"patient_3\"  \"patient_4\"  \"patient_5\"  #>  [6] \"patient_6\"  \"patient_7\"  \"patient_8\"  \"patient_9\"  \"patient_10\" fd$metadata$group #>  [1] \"A\" \"B\" \"A\" \"B\" \"A\" \"B\" \"A\" \"B\" \"A\" \"B\"  # Create 2D functional data from 3D array [n, m1, m2] surfaces <- array(rnorm(500), dim = c(5, 10, 10)) fd2d <- fdata(surfaces)  # Access individual surface as matrix surface_1 <- fd2d[1, drop = TRUE]"},{"path":"https://sipemu.github.io/fdars-r/reference/fdata2basis.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert Functional Data to Basis Coefficients — fdata2basis","title":"Convert Functional Data to Basis Coefficients — fdata2basis","text":"Project functional data onto basis system return coefficients. Supports B-spline Fourier basis. Works regular fdata irregular irregFdata objects.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fdata2basis.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert Functional Data to Basis Coefficients — fdata2basis","text":"","code":"fdata2basis(x, nbasis = 10, type = c(\"bspline\", \"fourier\"), ...)  # S3 method for class 'fdata' fdata2basis(x, nbasis = 10, type = c(\"bspline\", \"fourier\"), ...)  # S3 method for class 'irregFdata' fdata2basis(x, nbasis = 10, type = c(\"bspline\", \"fourier\"), ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/fdata2basis.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert Functional Data to Basis Coefficients — fdata2basis","text":"x object class 'fdata' 'irregFdata'. nbasis Number basis functions (default 10). type Type basis: \"bspline\" (default) \"fourier\". ... Additional arguments (currently unused).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fdata2basis.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert Functional Data to Basis Coefficients — fdata2basis","text":"matrix coefficients (n x nbasis).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fdata2basis.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert Functional Data to Basis Coefficients — fdata2basis","text":"regular fdata objects, curves projected onto basis evaluated common grid points. irregular irregFdata objects, curve individually fitted basis using least squares observation points. preferred approach sparse/irregularly sampled data avoids interpolation artifacts.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fdata2basis.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert Functional Data to Basis Coefficients — fdata2basis","text":"","code":"# Regular fdata t <- seq(0, 1, length.out = 50) X <- matrix(0, 20, 50) for (i in 1:20) X[i, ] <- sin(2*pi*t) + rnorm(50, sd = 0.1) fd <- fdata(X, argvals = t) coefs <- fdata2basis(fd, nbasis = 10, type = \"bspline\")  # Irregular fdata (sparsified) ifd <- sparsify(fd, minObs = 10, maxObs = 20, seed = 42) coefs_irreg <- fdata2basis(ifd, nbasis = 10, type = \"bspline\")"},{"path":"https://sipemu.github.io/fdars-r/reference/fdata2basis_2d.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert 2D Functional Data to Tensor Product Basis Coefficients — fdata2basis_2d","title":"Convert 2D Functional Data to Tensor Product Basis Coefficients — fdata2basis_2d","text":"Projects 2D functional data (surfaces) onto tensor product basis, Kronecker product two 1D bases.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fdata2basis_2d.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert 2D Functional Data to Tensor Product Basis Coefficients — fdata2basis_2d","text":"","code":"fdata2basis_2d(   fdataobj,   nbasis.s = 10,   nbasis.t = 10,   type = c(\"bspline\", \"fourier\") )"},{"path":"https://sipemu.github.io/fdars-r/reference/fdata2basis_2d.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert 2D Functional Data to Tensor Product Basis Coefficients — fdata2basis_2d","text":"fdataobj 2D fdata object (surfaces). nbasis.s Number basis functions s (first) direction. nbasis.t Number basis functions t (second) direction. type Basis type: \"bspline\" (default) \"fourier\".","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fdata2basis_2d.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert 2D Functional Data to Tensor Product Basis Coefficients — fdata2basis_2d","text":"matrix coefficients [n x (nbasis.s * nbasis.t)].","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fdata2basis_2d.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert 2D Functional Data to Tensor Product Basis Coefficients — fdata2basis_2d","text":"tensor product basis defined : $$B_{2d}(s, t) = B_s(s) \\otimes B_t(t)$$","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fdata2basis_2d.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert 2D Functional Data to Tensor Product Basis Coefficients — fdata2basis_2d","text":"","code":"# Create 2D surface data s <- seq(0, 1, length.out = 20) t <- seq(0, 1, length.out = 20) surface <- outer(sin(2*pi*s), cos(2*pi*t)) fd2d <- fdata(array(surface, dim = c(1, 20, 20)))  # Project to tensor product basis coefs <- fdata2basis_2d(fd2d, nbasis.s = 7, nbasis.t = 7, type = \"fourier\")"},{"path":"https://sipemu.github.io/fdars-r/reference/fdata2basis_cv.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-Validation for Basis Function Number Selection — fdata2basis_cv","title":"Cross-Validation for Basis Function Number Selection — fdata2basis_cv","text":"Selects optimal number basis functions using k-fold cross-validation generalized cross-validation.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fdata2basis_cv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-Validation for Basis Function Number Selection — fdata2basis_cv","text":"","code":"fdata2basis_cv(   fdataobj,   nbasis.range = 4:20,   type = c(\"bspline\", \"fourier\"),   criterion = c(\"GCV\", \"CV\", \"AIC\", \"BIC\"),   kfold = 10,   lambda = 0 )"},{"path":"https://sipemu.github.io/fdars-r/reference/fdata2basis_cv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-Validation for Basis Function Number Selection — fdata2basis_cv","text":"fdataobj fdata object. nbasis.range Vector nbasis values evaluate (default: 4:20). type Basis type: \"bspline\" (default) \"fourier\". criterion Selection criterion: \"GCV\" (default), \"CV\", \"AIC\", \"BIC\". kfold Number folds k-fold CV (default 10). Ignored criterion \"GCV\", \"AIC\", \"BIC\". lambda Smoothing parameter (default 0).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fdata2basis_cv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-Validation for Basis Function Number Selection — fdata2basis_cv","text":"list : optimal.nbasis Optimal number basis functions scores Score nbasis value nbasis.range tested nbasis values criterion criterion used fitted fdata object fitted optimal nbasis","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fdata2basis_cv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-Validation for Basis Function Number Selection — fdata2basis_cv","text":"","code":"set.seed(42) t <- seq(0, 1, length.out = 50) X <- matrix(0, 20, 50) for (i in 1:20) X[i, ] <- sin(4 * pi * t) + rnorm(50, sd = 0.1) fd <- fdata(X, argvals = t)  # Find optimal nbasis cv_result <- fdata2basis_cv(fd, nbasis.range = 5:15, type = \"fourier\") print(cv_result$optimal.nbasis) #> [1] 5"},{"path":"https://sipemu.github.io/fdars-r/reference/fdata2fd.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert Functional Data to fd class — fdata2fd","title":"Convert Functional Data to fd class — fdata2fd","text":"Converts fdata object fd object fda package. Requires fda package installed.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fdata2fd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert Functional Data to fd class — fdata2fd","text":"","code":"fdata2fd(fdataobj, nbasis = 10, type = c(\"bspline\", \"fourier\"))"},{"path":"https://sipemu.github.io/fdars-r/reference/fdata2fd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert Functional Data to fd class — fdata2fd","text":"fdataobj object class 'fdata'. nbasis Number basis functions (default 10). type Type basis: \"bspline\" (default) \"fourier\".","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fdata2fd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert Functional Data to fd class — fdata2fd","text":"object class 'fd' fda package.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fdata2fd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert Functional Data to fd class — fdata2fd","text":"","code":"# \\donttest{ t <- seq(0, 1, length.out = 50) X <- matrix(0, 20, 50) for (i in 1:20) X[i, ] <- sin(2*pi*t) + rnorm(50, sd = 0.1) fd <- fdata(X, argvals = t) fd_obj <- fdata2fd(fd, nbasis = 10) # }"},{"path":"https://sipemu.github.io/fdars-r/reference/fdata2pc.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert Functional Data to Principal Component Scores — fdata2pc","title":"Convert Functional Data to Principal Component Scores — fdata2pc","text":"Performs functional PCA returns principal component scores functional data. Uses SVD centered data.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fdata2pc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert Functional Data to Principal Component Scores — fdata2pc","text":"","code":"fdata2pc(fdataobj, ncomp = 2, lambda = 0, norm = TRUE)"},{"path":"https://sipemu.github.io/fdars-r/reference/fdata2pc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert Functional Data to Principal Component Scores — fdata2pc","text":"fdataobj object class 'fdata'. ncomp Number principal components extract (default 2). lambda Regularization parameter (default 0, currently used). norm Logical. TRUE (default), normalize scores.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fdata2pc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert Functional Data to Principal Component Scores — fdata2pc","text":"list components: d Singular values (proportional sqrt eigenvalues) rotation fdata object containing PC loadings x Matrix PC scores (n x ncomp) mean Mean function (numeric vector) fdataobj.cen Centered fdata object call function call","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fdata2pc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert Functional Data to Principal Component Scores — fdata2pc","text":"","code":"t <- seq(0, 1, length.out = 50) X <- matrix(0, 20, 50) for (i in 1:20) X[i, ] <- sin(2*pi*t) + rnorm(50, sd = 0.1) fd <- fdata(X, argvals = t) pc <- fdata2pc(fd, ncomp = 3)"},{"path":"https://sipemu.github.io/fdars-r/reference/fdata2pls.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert Functional Data to PLS Scores — fdata2pls","title":"Convert Functional Data to PLS Scores — fdata2pls","text":"Performs Partial Least Squares regression returns component scores functional data using NIPALS algorithm.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fdata2pls.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert Functional Data to PLS Scores — fdata2pls","text":"","code":"fdata2pls(fdataobj, y, ncomp = 2, lambda = 0, norm = TRUE)"},{"path":"https://sipemu.github.io/fdars-r/reference/fdata2pls.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert Functional Data to PLS Scores — fdata2pls","text":"fdataobj object class 'fdata'. y Response vector (numeric). ncomp Number PLS components extract (default 2). lambda Regularization parameter (default 0, currently used). norm Logical. TRUE (default), normalize scores.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fdata2pls.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert Functional Data to PLS Scores — fdata2pls","text":"list components: weights Matrix PLS weights (m x ncomp) scores Matrix PLS scores (n x ncomp) loadings Matrix PLS loadings (m x ncomp) call function call","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fdata2pls.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert Functional Data to PLS Scores — fdata2pls","text":"","code":"t <- seq(0, 1, length.out = 50) X <- matrix(0, 20, 50) for (i in 1:20) X[i, ] <- sin(2*pi*t) + rnorm(50, sd = 0.1) y <- rowMeans(X) + rnorm(20, sd = 0.1) fd <- fdata(X, argvals = t) pls <- fdata2pls(fd, y, ncomp = 3)"},{"path":"https://sipemu.github.io/fdars-r/reference/flm.test.html","id":null,"dir":"Reference","previous_headings":"","what":"Statistical Tests for Functional Data — flm.test","title":"Statistical Tests for Functional Data — flm.test","text":"Functions hypothesis testing functional data. Test Functional Linear Model","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/flm.test.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Statistical Tests for Functional Data — flm.test","text":"","code":"flm.test(fdataobj, y, B = 500, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/flm.test.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Statistical Tests for Functional Data — flm.test","text":"fdataobj object class 'fdata' (functional covariate). y Response vector. B Number bootstrap samples p-value computation. ... Additional arguments.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/flm.test.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Statistical Tests for Functional Data — flm.test","text":"list class 'htest' components: statistic test statistic p.value Bootstrap p-value method Name test","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/flm.test.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Statistical Tests for Functional Data — flm.test","text":"Tests goodness--fit functional linear model using projected Cramer-von Mises statistic.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/flm.test.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Statistical Tests for Functional Data — flm.test","text":"","code":"fd <- fdata(matrix(rnorm(200), 20, 10)) y <- rnorm(20) # test_result <- flm.test(fd, y, B = 100)"},{"path":"https://sipemu.github.io/fdars-r/reference/fmean.test.fdata.html","id":null,"dir":"Reference","previous_headings":"","what":"Test for Equality of Functional Means — fmean.test.fdata","title":"Test for Equality of Functional Means — fmean.test.fdata","text":"Tests whether mean function equals specified value.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fmean.test.fdata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test for Equality of Functional Means — fmean.test.fdata","text":"","code":"fmean.test.fdata(fdataobj, mu0 = NULL, B = 500, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/fmean.test.fdata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test for Equality of Functional Means — fmean.test.fdata","text":"fdataobj object class 'fdata'. mu0 Hypothesized mean function (vector). NULL, tests zero. B Number bootstrap samples p-value computation. ... Additional arguments.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fmean.test.fdata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test for Equality of Functional Means — fmean.test.fdata","text":"list class 'htest' components: statistic test statistic p.value Bootstrap p-value method Name test","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fmean.test.fdata.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test for Equality of Functional Means — fmean.test.fdata","text":"","code":"fd <- fdata(matrix(rnorm(200), 20, 10)) # test_result <- fmean.test.fdata(fd, B = 100)"},{"path":"https://sipemu.github.io/fdars-r/reference/fregre.basis.cv.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-Validation for Functional Basis Regression — fregre.basis.cv","title":"Cross-Validation for Functional Basis Regression — fregre.basis.cv","text":"Performs k-fold cross-validation select optimal regularization parameter (lambda) functional basis regression.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fregre.basis.cv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-Validation for Functional Basis Regression — fregre.basis.cv","text":"","code":"fregre.basis.cv(fdataobj, y, kfold = 10, lambda.range = NULL, seed = NULL, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/fregre.basis.cv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-Validation for Functional Basis Regression — fregre.basis.cv","text":"fdataobj object class 'fdata' (functional covariate). y Response vector. kfold Number folds cross-validation (default 10). lambda.range Range lambda values try. Default 10^seq(-4, 4, length.= 20). seed Random seed fold assignment. ... Additional arguments passed fregre.basis.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fregre.basis.cv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-Validation for Functional Basis Regression — fregre.basis.cv","text":"list components: optimal.lambda Optimal regularization parameter cv.errors Mean squared prediction error lambda cv.se Standard error cv.errors model Fitted model optimal lambda","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fregre.basis.html","id":null,"dir":"Reference","previous_headings":"","what":"Functional Basis Regression — fregre.basis","title":"Functional Basis Regression — fregre.basis","text":"Fits functional linear model using basis expansion (ridge regression). Uses anofox-regression Rust backend efficient L2-regularized regression.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fregre.basis.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functional Basis Regression — fregre.basis","text":"","code":"fregre.basis(fdataobj, y, basis.x = NULL, basis.b = NULL, lambda = 0, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/fregre.basis.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functional Basis Regression — fregre.basis","text":"fdataobj object class 'fdata' (functional covariate). y Response vector. basis.x Basis functional covariate (currently ignored). basis.b Basis coefficient function (currently ignored). lambda Smoothing/regularization parameter (L2 penalty). ... Additional arguments.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fregre.basis.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Functional Basis Regression — fregre.basis","text":"fitted regression object class 'fregre.fd' components: coefficients Beta coefficient function values intercept Intercept term fitted.values Fitted values residuals Residuals lambda Regularization parameter used r.squared R-squared (coefficient determination) mean.X Mean functional covariate (prediction) mean.y Mean response (prediction) sr2 Residual variance fdataobj Original functional data y Response vector call function call","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fregre.np.cv.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-Validation for Nonparametric Functional Regression — fregre.np.cv","title":"Cross-Validation for Nonparametric Functional Regression — fregre.np.cv","text":"Performs k-fold cross-validation select optimal bandwidth parameter (h) nonparametric functional regression.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fregre.np.cv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-Validation for Nonparametric Functional Regression — fregre.np.cv","text":"","code":"fregre.np.cv(   fdataobj,   y,   kfold = 10,   h.range = NULL,   metric = metric.lp,   seed = NULL,   ... )"},{"path":"https://sipemu.github.io/fdars-r/reference/fregre.np.cv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-Validation for Nonparametric Functional Regression — fregre.np.cv","text":"fdataobj object class 'fdata' (functional covariate). y Response vector. kfold Number folds cross-validation (default 10). h.range Range bandwidth values try. NULL, automatically determined distance matrix. metric Distance metric function. Default metric.lp. seed Random seed fold assignment. ... Additional arguments passed metric function.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fregre.np.cv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-Validation for Nonparametric Functional Regression — fregre.np.cv","text":"list components: optimal.h Optimal bandwidth parameter cv.errors Mean squared prediction error h cv.se Standard error cv.errors model Fitted model optimal h","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fregre.np.html","id":null,"dir":"Reference","previous_headings":"","what":"Nonparametric Functional Regression — fregre.np","title":"Nonparametric Functional Regression — fregre.np","text":"Fits functional regression model using kernel smoothing (Nadaraya-Watson). Supports fixed bandwidth (h), k-nearest neighbors global (kNN.gCV) local (kNN.lCV) cross-validation.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fregre.np.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Nonparametric Functional Regression — fregre.np","text":"","code":"fregre.np(   fdataobj,   y,   h = NULL,   knn = NULL,   type.S = c(\"S.NW\", \"kNN.gCV\", \"kNN.lCV\"),   Ker = \"norm\",   metric = metric.lp,   ... )"},{"path":"https://sipemu.github.io/fdars-r/reference/fregre.np.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nonparametric Functional Regression — fregre.np","text":"fdataobj object class 'fdata' (functional covariate). y Response vector. h Bandwidth parameter. NULL knn NULL, computed automatically. knn Number nearest neighbors consider bandwidth selection. used type.S \"kNN.gCV\" \"kNN.lCV\". type.S Type smoother: \"S.NW\" Nadaraya-Watson fixed h (default), \"kNN.gCV\" k-NN global CV (single k observations), \"kNN.lCV\" k-NN local CV (different k per observation). Ker Kernel type smoothing. Default \"norm\" (Gaussian). metric Distance metric function. Default metric.lp. ... Additional arguments passed metric function.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fregre.np.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Nonparametric Functional Regression — fregre.np","text":"fitted regression object class 'fregre.np' components: fitted.values Fitted values residuals Residuals h.opt Optimal/used bandwidth (type.S = \"S.NW\") knn Number neighbors used (kNN methods) k.opt Optimal k value(s) - scalar global, vector local type.S Type smoother used Ker Kernel type used fdataobj Original functional data y Response vector mdist Distance matrix sr2 Residual variance metric Metric function used call function call","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fregre.np.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Nonparametric Functional Regression — fregre.np","text":"Three smoothing approaches available: Fixed bandwidth (type.S = \"S.NW\"): Uses single bandwidth h predictions. h provided, set median non-zero pairwise distances. k-NN Global CV (type.S = \"kNN.gCV\"): Selects single optimal k observations using leave-one-cross-validation. bandwidth point set include k neighbors. k-NN Local CV (type.S = \"kNN.lCV\"): Selects optimal k_i observation , allowing adaptive smoothing. Useful data varying density across functional space.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fregre.np.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Nonparametric Functional Regression — fregre.np","text":"","code":"# Create functional data t <- seq(0, 1, length.out = 50) n <- 50 X <- matrix(0, n, 50) for (i in 1:n) X[i, ] <- sin(2*pi*t) * i/n + rnorm(50, sd = 0.1) y <- rowMeans(X) + rnorm(n, sd = 0.1) fd <- fdata(X, argvals = t)  # Fixed bandwidth fit1 <- fregre.np(fd, y, h = 0.5)  # k-NN with global CV fit2 <- fregre.np(fd, y, type.S = \"kNN.gCV\", knn = 20)  # k-NN with local CV fit3 <- fregre.np(fd, y, type.S = \"kNN.lCV\", knn = 20)"},{"path":"https://sipemu.github.io/fdars-r/reference/fregre.np.multi.html","id":null,"dir":"Reference","previous_headings":"","what":"Nonparametric Regression with Multiple Functional Predictors — fregre.np.multi","title":"Nonparametric Regression with Multiple Functional Predictors — fregre.np.multi","text":"Fits nonparametric regression model multiple functional predictors using weighted combination distance matrices.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fregre.np.multi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Nonparametric Regression with Multiple Functional Predictors — fregre.np.multi","text":"","code":"fregre.np.multi(   fdataobj.list,   y,   weights = NULL,   h = NULL,   knn = NULL,   type.S = c(\"S.NW\", \"kNN.gCV\", \"kNN.lCV\"),   Ker = \"norm\",   metric = metric.lp,   cv.grid = NULL,   cv.folds = 5,   ... )"},{"path":"https://sipemu.github.io/fdars-r/reference/fregre.np.multi.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nonparametric Regression with Multiple Functional Predictors — fregre.np.multi","text":"fdataobj.list list fdata objects (functional predictors). must number observations. y Response vector (scalar). weights Weights combining distances. Can : NULL: Equal weights (1/p predictor) Numeric vector: Fixed weights (normalized sum 1) \"cv\": Cross-validate find optimal weights h Bandwidth Nadaraya-Watson kernel (optional). knn Maximum k k-NN methods. type.S Smoother type: \"S.NW\", \"kNN.gCV\", \"kNN.lCV\". Ker Kernel type (default \"norm\" Gaussian). metric Distance metric function (default metric.lp). cv.grid Grid weight values CV (used weights = \"cv\"). Default seq(0, 1, = 0.1) 2 predictors. cv.folds Number folds weight CV (default 5). ... Additional arguments passed metric function.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fregre.np.multi.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Nonparametric Regression with Multiple Functional Predictors — fregre.np.multi","text":"object class 'fregre.np.multi' containing: fdataobj.list List functional predictors y Response vector weights Weights used (optimized) weights.cv CV results weights = \"cv\" fitted.values Fitted values residuals Residuals D.list List distance matrices D.combined Combined distance matrix","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fregre.np.multi.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Nonparametric Regression with Multiple Functional Predictors — fregre.np.multi","text":"","code":"# Create two functional predictors set.seed(42) n <- 50 m <- 30 t_grid <- seq(0, 1, length.out = m)  X1 <- matrix(0, n, m) X2 <- matrix(0, n, m) for (i in 1:n) {   X1[i, ] <- sin(2 * pi * t_grid) * i/n + rnorm(m, sd = 0.1)   X2[i, ] <- cos(2 * pi * t_grid) * i/n + rnorm(m, sd = 0.1) } y <- rowMeans(X1) + 0.5 * rowMeans(X2) + rnorm(n, sd = 0.1)  fd1 <- fdata(X1, argvals = t_grid) fd2 <- fdata(X2, argvals = t_grid)  # Fit with equal weights fit1 <- fregre.np.multi(list(fd1, fd2), y)  # Fit with cross-validated weights fit2 <- fregre.np.multi(list(fd1, fd2), y, weights = \"cv\")"},{"path":"https://sipemu.github.io/fdars-r/reference/fregre.pc.cv.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-Validation for Functional PC Regression — fregre.pc.cv","title":"Cross-Validation for Functional PC Regression — fregre.pc.cv","text":"Performs k-fold cross-validation select optimal number principal components functional PC regression.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fregre.pc.cv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-Validation for Functional PC Regression — fregre.pc.cv","text":"","code":"fregre.pc.cv(fdataobj, y, kfold = 10, ncomp.range = NULL, seed = NULL, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/fregre.pc.cv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-Validation for Functional PC Regression — fregre.pc.cv","text":"fdataobj object class 'fdata' (functional covariate). y Response vector. kfold Number folds cross-validation (default 10). ncomp.range Range number components try. Default 1 min(n-1, ncol(data)). seed Random seed fold assignment. ... Additional arguments passed fregre.pc.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fregre.pc.cv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-Validation for Functional PC Regression — fregre.pc.cv","text":"list components: optimal.ncomp Optimal number components cv.errors Mean squared prediction error ncomp cv.se Standard error cv.errors model Fitted model optimal ncomp","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fregre.pc.cv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-Validation for Functional PC Regression — fregre.pc.cv","text":"","code":"# Create functional data with a linear relationship set.seed(42) t <- seq(0, 1, length.out = 50) X <- matrix(0, 100, 50) for (i in 1:100) X[i, ] <- sin(2*pi*t) * i/100 + rnorm(50, sd = 0.1) beta_true <- cos(2*pi*t) y <- X %*% beta_true + rnorm(100, sd = 0.5) fd <- fdata(X, argvals = t)  # Cross-validate to find optimal number of PCs cv_result <- fregre.pc.cv(fd, y, ncomp.range = 1:10)"},{"path":"https://sipemu.github.io/fdars-r/reference/fregre.pc.html","id":null,"dir":"Reference","previous_headings":"","what":"Functional Regression — fregre.pc","title":"Functional Regression — fregre.pc","text":"Functions functional regression models. Functional Principal Component Regression","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fregre.pc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functional Regression — fregre.pc","text":"","code":"fregre.pc(fdataobj, y, ncomp = NULL, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/fregre.pc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functional Regression — fregre.pc","text":"fdataobj object class 'fdata' (functional covariate). y Response vector. ncomp Number principal components use. ... Additional arguments.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fregre.pc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Functional Regression — fregre.pc","text":"fitted regression object class 'fregre.fd' components: coefficients Beta coefficient function values intercept Intercept term fitted.values Fitted values residuals Residuals ncomp Number components used mean.X Mean functional covariate (prediction) mean.y Mean response (prediction) rotation PC loadings (prediction) l Indices selected components lm Underlying linear model sr2 Residual variance fdataobj Original functional data y Response vector call function call","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/fregre.pc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Functional Regression — fregre.pc","text":"Fits functional linear model using principal component regression.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/gmed.html","id":null,"dir":"Reference","previous_headings":"","what":"Geometric Median of Functional Data — gmed","title":"Geometric Median of Functional Data — gmed","text":"Computes geometric median (L1 median) functional data using Weiszfeld's iterative algorithm. geometric median minimizes sum L2 distances curves/surfaces, making robust outliers.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/gmed.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Geometric Median of Functional Data — gmed","text":"","code":"gmed(fdataobj, max.iter = 100, tol = 1e-06)"},{"path":"https://sipemu.github.io/fdars-r/reference/gmed.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Geometric Median of Functional Data — gmed","text":"fdataobj object class 'fdata'. max.iter Maximum number iterations (default 100). tol Convergence tolerance (default 1e-6).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/gmed.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Geometric Median of Functional Data — gmed","text":"fdata object containing geometric median function (1D 2D).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/gmed.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Geometric Median of Functional Data — gmed","text":"geometric median y minimizes: $$\\sum_{=1}^n ||X_i - y||_{L2}$$ Unlike mean (L2 center), geometric median robust outliers extreme values bounded influence (influence function bounded). Weiszfeld algorithm iteratively reweighted least squares method converges geometric median.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/reference/gmed.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Geometric Median of Functional Data — gmed","text":"","code":"# Create functional data with an outlier t <- seq(0, 1, length.out = 50) X <- matrix(0, 20, 50) for (i in 1:19) X[i, ] <- sin(2*pi*t) + rnorm(50, sd = 0.1) X[20, ] <- sin(2*pi*t) + 5  # Large outlier fd <- fdata(X, argvals = t)  # Compare mean vs geometric median mean_curve <- mean(fd) gmed_curve <- gmed(fd)  # The geometric median is less affected by the outlier"},{"path":"https://sipemu.github.io/fdars-r/reference/group.distance.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Distance/Similarity Between Groups of Functional Data — group.distance","title":"Compute Distance/Similarity Between Groups of Functional Data — group.distance","text":"Computes various distance similarity measures pre-defined groups functional curves.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/group.distance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Distance/Similarity Between Groups of Functional Data — group.distance","text":"","code":"group.distance(   fdataobj,   groups,   method = c(\"centroid\", \"hausdorff\", \"depth\", \"all\"),   metric = \"lp\",   p = 2,   depth.method = \"FM\",   ... )"},{"path":"https://sipemu.github.io/fdars-r/reference/group.distance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Distance/Similarity Between Groups of Functional Data — group.distance","text":"fdataobj object class 'fdata'. groups factor character vector specifying group membership curve. Must length equal number curves. method Distance/similarity method: \"centroid\": L2 distance group mean curves \"hausdorff\": Hausdorff-style distance groups \"depth\": Depth-based overlap (similarity, distance) \"\": Compute methods metric Distance metric centroid method (default \"lp\"). p Power Lp metric (default 2 L2). depth.method Depth method depth-based overlap (default \"FM\"). ... Additional arguments passed metric functions.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/group.distance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Distance/Similarity Between Groups of Functional Data — group.distance","text":"object class 'group.distance' containing: centroid Centroid distance matrix (method includes centroid) hausdorff Hausdorff distance matrix (method includes hausdorff) depth Depth-based similarity matrix (method includes depth) groups Unique group labels group.sizes Number curves per group method Methods used","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/group.distance.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Distance/Similarity Between Groups of Functional Data — group.distance","text":"","code":"# Create grouped functional data set.seed(42) n <- 30 m <- 50 t_grid <- seq(0, 1, length.out = m) X <- matrix(0, n, m) for (i in 1:15) X[i, ] <- sin(2 * pi * t_grid) + rnorm(m, sd = 0.1) for (i in 16:30) X[i, ] <- cos(2 * pi * t_grid) + rnorm(m, sd = 0.1) fd <- fdata(X, argvals = t_grid) groups <- factor(rep(c(\"A\", \"B\"), each = 15))  # Compute all distance measures gd <- group.distance(fd, groups, method = \"all\") print(gd) #> Group Distance Analysis #> ======================= #> Groups: A, B  #> Group sizes: A=15, B=15  #>  #> Centroid Distance (L2 between group means): #>       A     B #> A 0.000 1.002 #> B 1.002 0.000 #>  #> Hausdorff Distance (worst-case between groups): #>       A     B #> A 0.000 1.018 #> B 1.018 0.000 #>  #> Depth Overlap (similarity, higher = more similar): #>       A     B #> A 1.000 0.029 #> B 0.027 1.000 #>"},{"path":"https://sipemu.github.io/fdars-r/reference/group.test.html","id":null,"dir":"Reference","previous_headings":"","what":"Permutation Test for Group Differences — group.test","title":"Permutation Test for Group Differences — group.test","text":"Tests whether groups functional data significantly different using permutation testing.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/group.test.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Permutation Test for Group Differences — group.test","text":"","code":"group.test(   fdataobj,   groups,   n.perm = 1000,   statistic = c(\"centroid\", \"ratio\"),   ... )"},{"path":"https://sipemu.github.io/fdars-r/reference/group.test.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Permutation Test for Group Differences — group.test","text":"fdataobj object class 'fdata'. groups factor character vector specifying group membership. n.perm Number permutations (default 1000). statistic Test statistic: \"centroid\" (distance group means) \"ratio\" (/within group variance ratio). ... Additional arguments passed distance functions.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/group.test.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Permutation Test for Group Differences — group.test","text":"object class 'group.test' containing: statistic Observed test statistic p.value Permutation p-value perm.dist Permutation distribution test statistic n.perm Number permutations used","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/group.test.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Permutation Test for Group Differences — group.test","text":"Null Hypothesis (H0): groups come distribution. , group labels exchangeable systematic difference functional curves different groups. Alternative Hypothesis (H1): least one group differs others terms location (mean function) dispersion. test works : Computing test statistic observed data Repeatedly permuting group labels recomputing statistic Calculating p-value proportion permuted statistics >= observed Two test statistics available: \"centroid\": Sum pairwise L2 distances group mean functions. Sensitive differences group locations (means). \"ratio\": Ratio -group within-group variance, similar F-statistic. Sensitive location dispersion. small p-value (e.g., < 0.05) indicates evidence H0, suggesting groups significantly different.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/group.test.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Permutation Test for Group Differences — group.test","text":"","code":"# \\donttest{ set.seed(42) n <- 30 m <- 50 t_grid <- seq(0, 1, length.out = m) X <- matrix(0, n, m) for (i in 1:15) X[i, ] <- sin(2 * pi * t_grid) + rnorm(m, sd = 0.1) for (i in 16:30) X[i, ] <- cos(2 * pi * t_grid) + rnorm(m, sd = 0.1) fd <- fdata(X, argvals = t_grid) groups <- factor(rep(c(\"A\", \"B\"), each = 15))  # Test for significant difference gt <- group.test(fd, groups, n.perm = 500) print(gt) #> Permutation Test for Group Differences #> ====================================== #> Test statistic type: centroid  #> Observed statistic: 1.0025  #> Number of permutations: 500  #> P-value: <2e-16 *** # }"},{"path":"https://sipemu.github.io/fdars-r/reference/h.default.html","id":null,"dir":"Reference","previous_headings":"","what":"Default Bandwidth — h.default","title":"Default Bandwidth — h.default","text":"Compute default bandwidth 15th percentile pairwise distances.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/h.default.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Default Bandwidth — h.default","text":"","code":"h.default(fdataobj, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/h.default.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Default Bandwidth — h.default","text":"fdataobj object class 'fdata', numeric vector evaluation points. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/h.default.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Default Bandwidth — h.default","text":"scalar bandwidth value.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/h.default.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Default Bandwidth — h.default","text":"","code":"tt <- seq(0, 1, length.out = 50) h <- h.default(tt)"},{"path":"https://sipemu.github.io/fdars-r/reference/inprod.fdata.html","id":null,"dir":"Reference","previous_headings":"","what":"Inner Product of Functional Data — inprod.fdata","title":"Inner Product of Functional Data — inprod.fdata","text":"Compute inner product two functional data objects. <f, g> = integral(f(t) * g(t) dt)","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/inprod.fdata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Inner Product of Functional Data — inprod.fdata","text":"","code":"inprod.fdata(fdata1, fdata2 = NULL)"},{"path":"https://sipemu.github.io/fdars-r/reference/inprod.fdata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Inner Product of Functional Data — inprod.fdata","text":"fdata1 First functional data object. fdata2 Second functional data object. NULL, computes inner products fdata1 .","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/inprod.fdata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Inner Product of Functional Data — inprod.fdata","text":"matrix inner products. fdata1 n1 curves fdata2 n2 curves, returns n1 x n2 matrix.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/inprod.fdata.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Inner Product of Functional Data — inprod.fdata","text":"","code":"t <- seq(0, 1, length.out = 100) X1 <- matrix(sin(2*pi*t), nrow = 1) X2 <- matrix(cos(2*pi*t), nrow = 1) fd1 <- fdata(X1, argvals = t) fd2 <- fdata(X2, argvals = t) # Inner product of sin and cos over [0,1] should be 0 inprod.fdata(fd1, fd2) #>              [,1] #> [1,] 2.218175e-17"},{"path":"https://sipemu.github.io/fdars-r/reference/instantaneous.period.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate Instantaneous Period — instantaneous.period","title":"Estimate Instantaneous Period — instantaneous.period","text":"signals time-varying frequency (drifting period), estimates instantaneous period time point using Hilbert transform.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/instantaneous.period.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate Instantaneous Period — instantaneous.period","text":"","code":"instantaneous.period(fdataobj)"},{"path":"https://sipemu.github.io/fdars-r/reference/instantaneous.period.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate Instantaneous Period — instantaneous.period","text":"fdataobj fdata object.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/instantaneous.period.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate Instantaneous Period — instantaneous.period","text":"list fdata objects: period Instantaneous period time point frequency Instantaneous frequency time point amplitude Instantaneous amplitude (envelope) time point","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/instantaneous.period.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Estimate Instantaneous Period — instantaneous.period","text":"Hilbert transform used compute analytic signal, instantaneous phase extracted. derivative phase gives instantaneous frequency, 1/frequency gives period. particularly useful signals period constant, circadian rhythms drift frequency-modulated signals.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/instantaneous.period.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate Instantaneous Period — instantaneous.period","text":"","code":"# Chirp signal with increasing frequency t <- seq(0, 10, length.out = 500) freq <- 0.5 + 0.1 * t  # Frequency increases from 0.5 to 1.5 X <- matrix(sin(2 * pi * cumsum(freq) * diff(c(0, t))), nrow = 1) fd <- fdata(X, argvals = t)  # Estimate instantaneous period inst <- instantaneous.period(fd) # plot(inst$period)  # Shows decreasing period over time"},{"path":"https://sipemu.github.io/fdars-r/reference/int.simpson.html","id":null,"dir":"Reference","previous_headings":"","what":"Utility Functions for Functional Data Analysis — int.simpson.irregFdata","title":"Utility Functions for Functional Data Analysis — int.simpson.irregFdata","text":"Various utility functions including integration, inner products, random process generation, prediction metrics. Simpson's Rule Integration","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/int.simpson.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Utility Functions for Functional Data Analysis — int.simpson.irregFdata","text":"","code":"# S3 method for class 'irregFdata' int.simpson(x, ...)  int.simpson(x, ...)  # S3 method for class 'fdata' int.simpson(x, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/int.simpson.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Utility Functions for Functional Data Analysis — int.simpson.irregFdata","text":"x functional data object (fdata irregFdata). ... Additional arguments passed methods.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/int.simpson.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Utility Functions for Functional Data Analysis — int.simpson.irregFdata","text":"numeric vector integrals, one per curve.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/int.simpson.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Utility Functions for Functional Data Analysis — int.simpson.irregFdata","text":"Integrate functional data domain using Simpson's rule (composite trapezoidal rule non-uniform grids). Works regular fdata irregular irregFdata objects.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/int.simpson.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Utility Functions for Functional Data Analysis — int.simpson.irregFdata","text":"","code":"t <- seq(0, 1, length.out = 100) X <- matrix(0, 10, 100) for (i in 1:10) X[i, ] <- sin(2*pi*t) fd <- fdata(X, argvals = t) integrals <- int.simpson(fd)  # Should be approximately 0  # Also works with irregular data ifd <- sparsify(fd, minObs = 20, maxObs = 50, seed = 123) integrals_irreg <- int.simpson(ifd)"},{"path":"https://sipemu.github.io/fdars-r/reference/irregFdata.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an Irregular Functional Data Object — irregFdata","title":"Create an Irregular Functional Data Object — irregFdata","text":"Creates irregFdata object functional data observation sampled potentially different points. common longitudinal studies, sparse sampling, sensor data missing values.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/irregFdata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an Irregular Functional Data Object — irregFdata","text":"","code":"irregFdata(   argvals,   X,   rangeval = NULL,   names = NULL,   id = NULL,   metadata = NULL )"},{"path":"https://sipemu.github.io/fdars-r/reference/irregFdata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an Irregular Functional Data Object — irregFdata","text":"argvals list numeric vectors, argvals[[]] contains observation times -th curve. X list numeric vectors, X[[]] contains observed values -th curve. Must lengths corresponding argvals[[]]. rangeval Optional numeric vector length 2 specifying domain range. NULL, computed union observation points. names List components main, xlab, ylab plot titles. id Optional character vector identifiers observation. metadata Optional data.frame additional covariates (one row per observation).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/irregFdata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create an Irregular Functional Data Object — irregFdata","text":"object class irregFdata containing: argvals List observation time vectors X List value vectors n Number observations rangeval Domain range names Plot labels id Observation identifiers metadata Additional covariates","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/reference/irregFdata.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create an Irregular Functional Data Object — irregFdata","text":"","code":"# Create irregular functional data directly argvals <- list(   c(0.0, 0.3, 0.7, 1.0),   c(0.0, 0.2, 0.5, 0.8, 1.0),   c(0.1, 0.4, 0.9) ) X <- list(   c(0.1, 0.5, 0.3, 0.2),   c(0.0, 0.4, 0.6, 0.4, 0.1),   c(0.3, 0.7, 0.2) ) ifd <- irregFdata(argvals, X) print(ifd) #> Irregular Functional Data Object #> ================================= #>   Number of observations: 3  #>   Points per curve: #>     Min: 3  #>     Median: 4  #>     Max: 5  #>     Total: 12  #>   Domain: [ 0 , 1 ] plot(ifd)"},{"path":"https://sipemu.github.io/fdars-r/reference/is.irregular.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if an Object is Irregular Functional Data — is.irregular","title":"Check if an Object is Irregular Functional Data — is.irregular","text":"Check Object Irregular Functional Data","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/is.irregular.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if an Object is Irregular Functional Data — is.irregular","text":"","code":"is.irregular(x)"},{"path":"https://sipemu.github.io/fdars-r/reference/is.irregular.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if an Object is Irregular Functional Data — is.irregular","text":"x R object.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/is.irregular.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if an Object is Irregular Functional Data — is.irregular","text":"TRUE x class irregFdata, FALSE otherwise.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/is.irregular.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if an Object is Irregular Functional Data — is.irregular","text":"","code":"fd <- fdata(matrix(rnorm(100), 10, 10)) is.irregular(fd)  # FALSE #> [1] FALSE  ifd <- sparsify(fd, minObs = 3, maxObs = 7) is.irregular(ifd)  # TRUE #> [1] TRUE"},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.add.html","id":null,"dir":"Reference","previous_headings":"","what":"Add Covariance Functions — kernel.add","title":"Add Covariance Functions — kernel.add","text":"Combines two covariance functions addition.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.add.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add Covariance Functions — kernel.add","text":"","code":"kernel.add(kernel1, kernel2)"},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.add.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add Covariance Functions — kernel.add","text":"kernel1 First covariance function. kernel2 Second covariance function.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.add.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add Covariance Functions — kernel.add","text":"combined covariance function.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.add.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add Covariance Functions — kernel.add","text":"","code":"# Combine Gaussian with white noise k_signal <- kernel.gaussian(variance = 1, length_scale = 0.2) k_noise <- kernel.whitenoise(variance = 0.1) k_total <- kernel.add(k_signal, k_noise)  t <- seq(0, 1, length.out = 50) fd <- make.gaussian.process(n = 5, t = t, cov = k_total)"},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.brownian.html","id":null,"dir":"Reference","previous_headings":"","what":"Brownian Motion Covariance Function — kernel.brownian","title":"Brownian Motion Covariance Function — kernel.brownian","text":"Computes Brownian motion (Wiener process) covariance function: $$k(s, t) = \\sigma^2 \\min(s, t)$$","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.brownian.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Brownian Motion Covariance Function — kernel.brownian","text":"","code":"kernel.brownian(variance = 1)"},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.brownian.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Brownian Motion Covariance Function — kernel.brownian","text":"variance Variance parameter \\(\\sigma^2\\) (default 1).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.brownian.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Brownian Motion Covariance Function — kernel.brownian","text":"covariance function object class 'kernel_brownian'.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.brownian.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Brownian Motion Covariance Function — kernel.brownian","text":"Brownian motion covariance produces sample paths start 0 independent increments. covariance two points equals variance times minimum positions. covariance defined 1D domains starting 0.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.brownian.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Brownian Motion Covariance Function — kernel.brownian","text":"","code":"# Generate Brownian motion paths cov_func <- kernel.brownian(variance = 1) t <- seq(0, 1, length.out = 100) fd <- make.gaussian.process(n = 10, t = t, cov = cov_func) plot(fd)"},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.exponential.html","id":null,"dir":"Reference","previous_headings":"","what":"Exponential Covariance Function — kernel.exponential","title":"Exponential Covariance Function — kernel.exponential","text":"Computes exponential covariance function: $$k(s, t) = \\sigma^2 \\exp\\left(-\\frac{|s-t|}{\\ell}\\right)$$","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.exponential.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Exponential Covariance Function — kernel.exponential","text":"","code":"kernel.exponential(variance = 1, length_scale = 1)"},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.exponential.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Exponential Covariance Function — kernel.exponential","text":"variance Variance parameter \\(\\sigma^2\\) (default 1). length_scale Length scale parameter \\(\\ell\\) (default 1).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.exponential.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Exponential Covariance Function — kernel.exponential","text":"covariance function object class 'kernel_exponential'.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.exponential.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Exponential Covariance Function — kernel.exponential","text":"equivalent Matern covariance \\(\\nu = 0.5\\). Sample paths continuous differentiable (rough). exponential covariance function produces sample paths continuous nowhere differentiable, resulting rough-looking curves. special case Matern family \\(\\nu = 0.5\\).","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.exponential.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Exponential Covariance Function — kernel.exponential","text":"","code":"# Create an exponential covariance function cov_func <- kernel.exponential(variance = 1, length_scale = 0.2)  # Evaluate covariance matrix t <- seq(0, 1, length.out = 50) K <- cov_func(t)  # Generate rough GP samples fd <- make.gaussian.process(n = 10, t = t, cov = cov_func) plot(fd)"},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.gaussian.html","id":null,"dir":"Reference","previous_headings":"","what":"Gaussian (Squared Exponential) Covariance Function — kernel.gaussian","title":"Gaussian (Squared Exponential) Covariance Function — kernel.gaussian","text":"Computes Gaussian (RBF/squared exponential) covariance function: $$k(s, t) = \\sigma^2 \\exp\\left(-\\frac{(s-t)^2}{2\\ell^2}\\right)$$","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.gaussian.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gaussian (Squared Exponential) Covariance Function — kernel.gaussian","text":"","code":"kernel.gaussian(variance = 1, length_scale = 1)"},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.gaussian.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Gaussian (Squared Exponential) Covariance Function — kernel.gaussian","text":"variance Variance parameter \\(\\sigma^2\\) (default 1). length_scale Length scale parameter \\(\\ell\\) (default 1).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.gaussian.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Gaussian (Squared Exponential) Covariance Function — kernel.gaussian","text":"covariance function object class 'kernel_gaussian'.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.gaussian.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Gaussian (Squared Exponential) Covariance Function — kernel.gaussian","text":"kernel produces infinitely differentiable (smooth) sample paths. Gaussian covariance function, also known squared exponential radial basis function (RBF) kernel, one commonly used covariance functions. produces smooth sample paths infinitely differentiable. length scale parameter controls quickly correlation decays distance. Larger values produce smoother, slowly varying functions.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.gaussian.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Gaussian (Squared Exponential) Covariance Function — kernel.gaussian","text":"","code":"# Create a Gaussian covariance function cov_func <- kernel.gaussian(variance = 1, length_scale = 0.2)  # Evaluate covariance matrix on a grid t <- seq(0, 1, length.out = 50) K <- cov_func(t) image(K, main = \"Gaussian Covariance Matrix\")   # Generate Gaussian process samples fd <- make.gaussian.process(n = 10, t = t, cov = cov_func) plot(fd)"},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.linear.html","id":null,"dir":"Reference","previous_headings":"","what":"Linear Covariance Function — kernel.linear","title":"Linear Covariance Function — kernel.linear","text":"Computes linear covariance function: $$k(s, t) = \\sigma^2 (s - c)(t - c)$$","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.linear.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Linear Covariance Function — kernel.linear","text":"","code":"kernel.linear(variance = 1, offset = 0)"},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.linear.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Linear Covariance Function — kernel.linear","text":"variance Variance parameter \\(\\sigma^2\\) (default 1). offset Offset parameter \\(c\\) (default 0).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.linear.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Linear Covariance Function — kernel.linear","text":"covariance function object class 'kernel_linear'.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.linear.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Linear Covariance Function — kernel.linear","text":"linear covariance function produces sample paths linear functions. useful underlying process expected linear trend.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.linear.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Linear Covariance Function — kernel.linear","text":"","code":"# Generate linear function samples cov_func <- kernel.linear(variance = 1) t <- seq(0, 1, length.out = 50) fd <- make.gaussian.process(n = 10, t = t, cov = cov_func) plot(fd)"},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.matern.html","id":null,"dir":"Reference","previous_headings":"","what":"Matern Covariance Function — kernel.matern","title":"Matern Covariance Function — kernel.matern","text":"Computes Matern covariance function smoothness parameter \\(\\nu\\): $$k(s, t) = \\sigma^2 \\frac{2^{1-\\nu}}{\\Gamma(\\nu)} \\left(\\sqrt{2\\nu}\\frac{|s-t|}{\\ell}\\right)^\\nu K_\\nu\\left(\\sqrt{2\\nu}\\frac{|s-t|}{\\ell}\\right)$$","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.matern.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Matern Covariance Function — kernel.matern","text":"","code":"kernel.matern(variance = 1, length_scale = 1, nu = 1.5)"},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.matern.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Matern Covariance Function — kernel.matern","text":"variance Variance parameter \\(\\sigma^2\\) (default 1). length_scale Length scale parameter \\(\\ell\\) (default 1). nu Smoothness parameter \\(\\nu\\) (default 1.5). Common values: nu = 0.5: Exponential (continuous, differentiable) nu = 1.5: differentiable nu = 2.5: Twice differentiable nu = Inf: Gaussian/squared exponential (infinitely differentiable)","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.matern.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Matern Covariance Function — kernel.matern","text":"covariance function object class 'kernel_matern'.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.matern.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Matern Covariance Function — kernel.matern","text":"\\(K_\\nu\\) modified Bessel function second kind. Matern family covariance functions provides flexible control smoothness sample paths \\(\\nu\\) parameter. \\(\\nu\\) increases, sample paths become smoother. Matern family includes exponential (\\(\\nu = 0.5\\)) approaches Gaussian kernel \\(\\nu \\\\infty\\). computational efficiency, special cases \\(\\nu \\\\{0.5, 1.5, 2.5, \\infty\\}\\) use simplified closed-form expressions.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.matern.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Matern Covariance Function — kernel.matern","text":"","code":"# Create Matern covariance functions with different smoothness cov_rough <- kernel.matern(nu = 0.5)    # Equivalent to exponential cov_smooth <- kernel.matern(nu = 2.5)   # Twice differentiable  t <- seq(0, 1, length.out = 50)  # Compare sample paths fd_rough <- make.gaussian.process(n = 5, t = t, cov = cov_rough, seed = 42) fd_smooth <- make.gaussian.process(n = 5, t = t, cov = cov_smooth, seed = 42)"},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.mult.html","id":null,"dir":"Reference","previous_headings":"","what":"Multiply Covariance Functions — kernel.mult","title":"Multiply Covariance Functions — kernel.mult","text":"Combines two covariance functions multiplication.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.mult.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multiply Covariance Functions — kernel.mult","text":"","code":"kernel.mult(kernel1, kernel2)"},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.mult.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multiply Covariance Functions — kernel.mult","text":"kernel1 First covariance function. kernel2 Second covariance function.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.mult.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Multiply Covariance Functions — kernel.mult","text":"combined covariance function.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.mult.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Multiply Covariance Functions — kernel.mult","text":"","code":"# Multiply periodic with Gaussian for locally periodic behavior k_periodic <- kernel.periodic(period = 0.3) k_gaussian <- kernel.gaussian(length_scale = 0.5) k_prod <- kernel.mult(k_periodic, k_gaussian)"},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.periodic.html","id":null,"dir":"Reference","previous_headings":"","what":"Periodic Covariance Function — kernel.periodic","title":"Periodic Covariance Function — kernel.periodic","text":"Computes periodic covariance function: $$k(s, t) = \\sigma^2 \\exp\\left(-\\frac{2\\sin^2(\\pi|s-t|/p)}{\\ell^2}\\right)$$","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.periodic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Periodic Covariance Function — kernel.periodic","text":"","code":"kernel.periodic(variance = 1, length_scale = 1, period = 1)"},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.periodic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Periodic Covariance Function — kernel.periodic","text":"variance Variance parameter \\(\\sigma^2\\) (default 1). length_scale Length scale parameter \\(\\ell\\) (default 1). period Period parameter \\(p\\) (default 1).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.periodic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Periodic Covariance Function — kernel.periodic","text":"covariance function object class 'kernel_periodic'.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.periodic.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Periodic Covariance Function — kernel.periodic","text":"periodic covariance function produces sample paths periodic specified period. useful modeling seasonal cyclical patterns functional data.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.periodic.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Periodic Covariance Function — kernel.periodic","text":"","code":"# Generate periodic function samples cov_func <- kernel.periodic(period = 0.5, length_scale = 0.5) t <- seq(0, 2, length.out = 100) fd <- make.gaussian.process(n = 5, t = t, cov = cov_func) plot(fd)"},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.polynomial.html","id":null,"dir":"Reference","previous_headings":"","what":"Polynomial Covariance Function — kernel.polynomial","title":"Polynomial Covariance Function — kernel.polynomial","text":"Computes polynomial covariance function: $$k(s, t) = \\sigma^2 (s \\cdot t + c)^p$$","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.polynomial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Polynomial Covariance Function — kernel.polynomial","text":"","code":"kernel.polynomial(variance = 1, offset = 0, degree = 2)"},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.polynomial.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Polynomial Covariance Function — kernel.polynomial","text":"variance Variance parameter \\(\\sigma^2\\) (default 1). offset Offset parameter \\(c\\) (default 0). degree Polynomial degree \\(p\\) (default 2).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.polynomial.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Polynomial Covariance Function — kernel.polynomial","text":"covariance function object class 'kernel_polynomial'.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.polynomial.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Polynomial Covariance Function — kernel.polynomial","text":"polynomial covariance function produces sample paths polynomial functions degree degree. Setting degree = 1 offset = 0 gives linear kernel.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.polynomial.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Polynomial Covariance Function — kernel.polynomial","text":"","code":"# Generate quadratic function samples cov_func <- kernel.polynomial(degree = 2, offset = 1) t <- seq(0, 1, length.out = 50) fd <- make.gaussian.process(n = 10, t = t, cov = cov_func) plot(fd)"},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.whitenoise.html","id":null,"dir":"Reference","previous_headings":"","what":"White Noise Covariance Function — kernel.whitenoise","title":"White Noise Covariance Function — kernel.whitenoise","text":"Computes white noise covariance function: $$k(s, t) = \\sigma^2 \\mathbf{1}_{s = t}$$","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.whitenoise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"White Noise Covariance Function — kernel.whitenoise","text":"","code":"kernel.whitenoise(variance = 1)"},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.whitenoise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"White Noise Covariance Function — kernel.whitenoise","text":"variance Variance (noise level) parameter \\(\\sigma^2\\) (default 1).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.whitenoise.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"White Noise Covariance Function — kernel.whitenoise","text":"covariance function object class 'kernel_whitenoise'.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.whitenoise.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"White Noise Covariance Function — kernel.whitenoise","text":"\\(\\mathbf{1}_{s = t}\\) 1 \\(s = t\\) 0 otherwise. white noise covariance function represents independent noise point. can added covariance functions model observation noise.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/reference/kernel.whitenoise.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"White Noise Covariance Function — kernel.whitenoise","text":"","code":"# White noise covariance produces independent samples at each point cov_func <- kernel.whitenoise(variance = 0.1) t <- seq(0, 1, length.out = 50) K <- cov_func(t) # K is diagonal"},{"path":"https://sipemu.github.io/fdars-r/reference/kernels.html","id":null,"dir":"Reference","previous_headings":"","what":"Covariance Kernel Functions for Gaussian Processes — kernels","title":"Covariance Kernel Functions for Gaussian Processes — kernels","text":"Parametric covariance functions (kernels) used define covariance structure Gaussian processes. can used make_gaussian_process generate synthetic functional data.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/kernels.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Covariance Kernel Functions for Gaussian Processes — kernels","text":"return value. page documents family kernel functions.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/localavg.fdata.html","id":null,"dir":"Reference","previous_headings":"","what":"Local Averages Feature Extraction — localavg.fdata","title":"Local Averages Feature Extraction — localavg.fdata","text":"Extracts features functional data computing local averages specified intervals. simple effective dimension reduction technique functional data.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/localavg.fdata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Local Averages Feature Extraction — localavg.fdata","text":"","code":"localavg.fdata(fdataobj, n.intervals = 10, intervals = NULL)"},{"path":"https://sipemu.github.io/fdars-r/reference/localavg.fdata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Local Averages Feature Extraction — localavg.fdata","text":"fdataobj object class 'fdata'. n.intervals Number equal-width intervals (default 10). intervals Optional matrix custom intervals (2 columns: start, end). provided, n.intervals ignored.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/localavg.fdata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Local Averages Feature Extraction — localavg.fdata","text":"matrix n rows (curves) one column per interval, containing local average curve interval.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/localavg.fdata.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Local Averages Feature Extraction — localavg.fdata","text":"Local averages provide simple way convert functional data multivariate data preserving local structure. curve summarized average value interval. can useful preprocessing step classification clustering methods require fixed-dimensional input.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/localavg.fdata.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Local Averages Feature Extraction — localavg.fdata","text":"","code":"# Create functional data t <- seq(0, 1, length.out = 100) X <- matrix(0, 20, 100) for (i in 1:20) X[i, ] <- sin(2*pi*t) + rnorm(100, sd = 0.1) fd <- fdata(X, argvals = t)  # Extract 5 local average features features <- localavg.fdata(fd, n.intervals = 5) dim(features)  # 20 x 5 #> [1] 20  5  # Use custom intervals intervals <- cbind(c(0, 0.25, 0.5), c(0.25, 0.5, 1)) features2 <- localavg.fdata(fd, intervals = intervals)"},{"path":"https://sipemu.github.io/fdars-r/reference/lomb.scargle.html","id":null,"dir":"Reference","previous_headings":"","what":"Lomb-Scargle Periodogram — lomb.scargle","title":"Lomb-Scargle Periodogram — lomb.scargle","text":"Computes Lomb-Scargle periodogram period detection unevenly-sampled data. Lomb-Scargle method designed irregularly spaced observations reduces standard periodogram evenly-spaced data.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/lomb.scargle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lomb-Scargle Periodogram — lomb.scargle","text":"","code":"lomb.scargle(fdataobj, oversampling = 4, nyquist_factor = 1)"},{"path":"https://sipemu.github.io/fdars-r/reference/lomb.scargle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Lomb-Scargle Periodogram — lomb.scargle","text":"fdataobj fdata object. Can regular irregular sampling. oversampling Oversampling factor frequency grid. Higher values give finer frequency resolution. Default: 4. nyquist_factor Maximum frequency multiple pseudo-Nyquist frequency. Default: 1.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/lomb.scargle.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Lomb-Scargle Periodogram — lomb.scargle","text":"list class \"lomb_scargle_result\" components: frequencies Vector evaluated frequencies periods Corresponding periods (1/frequency) power Normalized Lomb-Scargle power frequency peak_period Period highest power peak_frequency Frequency highest power peak_power Maximum power value false_alarm_probability False alarm probability peak significance Significance level (1 - FAP)","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/lomb.scargle.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Lomb-Scargle Periodogram — lomb.scargle","text":"Lomb-Scargle periodogram particularly useful : Data gaps missing observations Sampling uniform (e.g., astronomical observations) Working irregular functional data algorithm follows Scargle (1982) significance estimation Horne & Baliunas (1986). test frequency, computes: $$P(\\omega) = \\frac{1}{2\\sigma^2} \\left[   \\frac{(\\sum_j (y_j - \\bar{y}) \\cos\\omega(t_j - \\tau))^2}{\\sum_j \\cos^2\\omega(t_j - \\tau)} +   \\frac{(\\sum_j (y_j - \\bar{y}) \\sin\\omega(t_j - \\tau))^2}{\\sum_j \\sin^2\\omega(t_j - \\tau)} \\right]$$ \\(\\tau\\) phase shift chosen make sine cosine terms orthogonal.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/lomb.scargle.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Lomb-Scargle Periodogram — lomb.scargle","text":"Scargle, J.D. (1982). Studies astronomical time series analysis. II. Statistical aspects spectral analysis unevenly spaced data. Astrophysical Journal, 263, 835-853. Horne, J.H., & Baliunas, S.L. (1986). prescription period analysis unevenly sampled time series. Astrophysical Journal, 302, 757-763.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/reference/lomb.scargle.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Lomb-Scargle Periodogram — lomb.scargle","text":"","code":"# Regular sampling t <- seq(0, 10, length.out = 200) X <- matrix(sin(2 * pi * t / 2), nrow = 1) fd <- fdata(X, argvals = t) result <- lomb.scargle(fd) print(result) #> Lomb-Scargle Periodogram #> ------------------------ #> Peak period:    2.0000 #> Peak frequency: 0.5000 #> Peak power:     99.5000 #> FAP:            0.0000e+00 #> Significance:   1.0000 #>  #> Frequency grid: 395 points (0.1000 to 9.9500)  # Irregular sampling (simulated) set.seed(42) t_irreg <- sort(runif(100, 0, 10)) X_irreg <- matrix(sin(2 * pi * t_irreg / 2), nrow = 1) fd_irreg <- fdata(X_irreg, argvals = t_irreg) result_irreg <- lomb.scargle(fd_irreg)"},{"path":"https://sipemu.github.io/fdars-r/reference/magnitudeshape.html","id":null,"dir":"Reference","previous_headings":"","what":"Magnitude-Shape Outlier Detection for Functional Data — magnitudeshape","title":"Magnitude-Shape Outlier Detection for Functional Data — magnitudeshape","text":"Performs Magnitude-Shape (MS) outlier detection functional data. curve represented point 2D space x-axis represents magnitude outlyingness y-axis represents shape outlyingness.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/magnitudeshape.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Magnitude-Shape Outlier Detection for Functional Data — magnitudeshape","text":"","code":"magnitudeshape(   fdataobj,   depth.func = depth.MBD,   cutoff.quantile = 0.993,   col.normal = \"black\",   col.outliers = \"red\",   label = \"index\",   label_all = FALSE,   ... )"},{"path":"https://sipemu.github.io/fdars-r/reference/magnitudeshape.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Magnitude-Shape Outlier Detection for Functional Data — magnitudeshape","text":"fdataobj object class 'fdata'. depth.func Depth function use computing outlyingness. Default depth.MBD. cutoff.quantile Quantile outlier cutoff (default 0.993). col.normal Color normal curves (default \"black\"). col.outliers Color outlier curves (default \"red\"). label use labeling outlier points. Options: \"index\": Use numeric indices (default) \"id\": Use observation IDs fdata object column name fdata metadata (e.g., \"patient_id\") NULL: labels label_all Logical. TRUE, label points, just outliers. Default FALSE. ... Additional arguments passed depth function.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/magnitudeshape.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Magnitude-Shape Outlier Detection for Functional Data — magnitudeshape","text":"list class 'magnitudeshape' components: MO Magnitude outlyingness values VO Shape (variability) outlyingness values outliers Indices detected outliers cutoff Chi-squared cutoff value used plot ggplot object","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/magnitudeshape.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Magnitude-Shape Outlier Detection for Functional Data — magnitudeshape","text":"MS plot (Dai & Genton, 2019) decomposes functional outlyingness : Magnitude Outlyingness (MO): Based pointwise median directional outlyingness - captures shift outliers Shape Outlyingness (VO): Based variability directional outlyingness - captures shape outliers Outliers detected using chi-squared distribution cutoff specified quantile.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/magnitudeshape.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Magnitude-Shape Outlier Detection for Functional Data — magnitudeshape","text":"Dai, W. Genton, M.G. (2019). Directional outlyingness multivariate functional data. Computational Statistics & Data Analysis, 131, 50-65.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/magnitudeshape.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Magnitude-Shape Outlier Detection for Functional Data — magnitudeshape","text":"","code":"# Create functional data with outliers set.seed(42) t <- seq(0, 1, length.out = 50) X <- matrix(0, 30, 50) for (i in 1:28) X[i, ] <- sin(2*pi*t) + rnorm(50, sd = 0.2) X[29, ] <- sin(2*pi*t) + 2  # Magnitude outlier X[30, ] <- sin(4*pi*t)       # Shape outlier fd <- fdata(X, argvals = t)  # Create MS plot ms <- magnitudeshape(fd)  # With IDs and metadata fd <- fdata(X, argvals = t, id = paste0(\"curve_\", 1:30)) ms <- magnitudeshape(fd, label = \"id\")"},{"path":"https://sipemu.github.io/fdars-r/reference/make.gaussian.process.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Gaussian Process Samples — make.gaussian.process","title":"Generate Gaussian Process Samples — make.gaussian.process","text":"Generates functional data samples Gaussian process specified mean covariance functions.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/make.gaussian.process.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Gaussian Process Samples — make.gaussian.process","text":"","code":"make.gaussian.process(n, t, cov = kernel.gaussian(), mean = 0, seed = NULL)"},{"path":"https://sipemu.github.io/fdars-r/reference/make.gaussian.process.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Gaussian Process Samples — make.gaussian.process","text":"n Number samples generate. t Evaluation points (vector 1D, list two vectors 2D). cov Covariance function (kernel.gaussian, kernel.matern, etc.). mean Mean function. Can scalar (default 0), vector length equal number evaluation points, function. seed Optional random seed reproducibility.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/make.gaussian.process.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Gaussian Process Samples — make.gaussian.process","text":"fdata object containing generated samples.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/make.gaussian.process.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Gaussian Process Samples — make.gaussian.process","text":"function generates samples Gaussian process specified covariance structure. samples generated computing Cholesky decomposition covariance matrix multiplying standard normal random variables. 2D functional data, pass t list two vectors representing grid dimension.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/reference/make.gaussian.process.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Gaussian Process Samples — make.gaussian.process","text":"","code":"# Generate smooth GP samples with Gaussian covariance t <- seq(0, 1, length.out = 100) fd <- make.gaussian.process(n = 20, t = t,                             cov = kernel.gaussian(length_scale = 0.2),                             seed = 42) plot(fd)   # Generate rough GP samples with exponential covariance fd_rough <- make.gaussian.process(n = 20, t = t,                                   cov = kernel.exponential(length_scale = 0.1),                                   seed = 42) plot(fd_rough)   # Generate 2D GP samples (surfaces) s <- seq(0, 1, length.out = 20) t2 <- seq(0, 1, length.out = 20) fd2d <- make.gaussian.process(n = 5, t = list(s, t2),                               cov = kernel.gaussian(length_scale = 0.3),                               seed = 42) plot(fd2d)   # Generate GP with non-zero mean mean_func <- function(t) sin(2 * pi * t) fd_mean <- make.gaussian.process(n = 10, t = t,                                  cov = kernel.gaussian(variance = 0.1),                                  mean = mean_func, seed = 42) plot(fd_mean)"},{"path":"https://sipemu.github.io/fdars-r/reference/matrix.profile.html","id":null,"dir":"Reference","previous_headings":"","what":"Matrix Profile for Motif Discovery and Period Detection — matrix.profile","title":"Matrix Profile for Motif Discovery and Period Detection — matrix.profile","text":"Computes Matrix Profile using STOMP (Scalable Time series Ordered-search Matrix Profile) algorithm. Matrix Profile stores z-normalized Euclidean distance subsequence nearest neighbor, enabling efficient motif discovery period detection non-sinusoidal patterns.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/matrix.profile.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Matrix Profile for Motif Discovery and Period Detection — matrix.profile","text":"","code":"matrix.profile(fdataobj, subsequence_length = NULL, exclusion_zone = 0.5)"},{"path":"https://sipemu.github.io/fdars-r/reference/matrix.profile.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Matrix Profile for Motif Discovery and Period Detection — matrix.profile","text":"fdataobj fdata object. subsequence_length Length subsequences compare. NULL, automatically determined approximately 1/4 series length. exclusion_zone Fraction subsequence length exclude around position prevent trivial self-matches. Default: 0.5.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/matrix.profile.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Matrix Profile for Motif Discovery and Period Detection — matrix.profile","text":"list class \"matrix_profile_result\" components: profile Numeric vector minimum z-normalized distances position profile_index Integer vector nearest neighbor indices (1-based) subsequence_length Subsequence length used detected_periods Candidate periods detected arc analysis (top 5) arc_counts Arc counts index distance (diagnostics) primary_period prominent detected period confidence Confidence score (0-1) based arc prominence","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/matrix.profile.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Matrix Profile for Motif Discovery and Period Detection — matrix.profile","text":"Matrix Profile algorithm (Yeh et al., 2016; Zhu et al., 2016) particularly suited : Non-sinusoidal repeating patterns (unlike FFT/spectral methods) Motif discovery (finding repeated subsequences) Anomaly detection (subsequences good match) STOMP variant uses O(n^2) time complexity highly cache-efficient. long series (>10000 points), consider downsampling. Period detection based \"arc analysis\": counting often nearest neighbor fixed distance away. Peaks arc counts indicate periodicity.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/matrix.profile.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Matrix Profile for Motif Discovery and Period Detection — matrix.profile","text":"Yeh, C. C. M., et al. (2016). Matrix profile : pairs similarity joins time series: unifying view includes motifs, discords shapelets. ICDM 2016. Zhu, Y., et al. (2016). Matrix profile II: Exploiting novel algorithm GPUs break one hundred million barrier time series motifs joins. ICDM 2016.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/reference/matrix.profile.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Matrix Profile for Motif Discovery and Period Detection — matrix.profile","text":"","code":"# Periodic sawtooth wave (non-sinusoidal) t <- seq(0, 10, length.out = 200) period <- 2 X <- matrix((t %% period) / period, nrow = 1) fd <- fdata(X, argvals = t)  # Compute Matrix Profile result <- matrix.profile(fd, subsequence_length = 30) print(result) #> Matrix Profile (STOMP) #> ---------------------- #> Subsequence length: 30 #> Profile length:     171 #> Primary period:     40.00 #> Confidence:         0.4678 #>  #> Top detected periods: 40, 80, 120, 44, 82 #>  #> Profile statistics: #>   Min:  0.0000 #>   Mean: 0.0000 #>   Max:  0.0000 plot(result)   # Sine wave for comparison X_sine <- matrix(sin(2 * pi * t / period), nrow = 1) fd_sine <- fdata(X_sine, argvals = t) result_sine <- matrix.profile(fd_sine, subsequence_length = 30)"},{"path":"https://sipemu.github.io/fdars-r/reference/mean.fdata.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute functional mean — mean.fdata","title":"Compute functional mean — mean.fdata","text":"Computes pointwise mean function across observations. S3 method generic mean function.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/mean.fdata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute functional mean — mean.fdata","text":"","code":"# S3 method for class 'fdata' mean(x, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/mean.fdata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute functional mean — mean.fdata","text":"x object class 'fdata'. ... Additional arguments (currently ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/mean.fdata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute functional mean — mean.fdata","text":"1D fdata: numeric vector containing mean function values. 2D fdata: fdata object containing mean surface.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/mean.fdata.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute functional mean — mean.fdata","text":"","code":"# 1D functional data fd <- fdata(matrix(rnorm(100), 10, 10)) fm <- mean(fd)  # 2D functional data X <- array(rnorm(500), dim = c(5, 10, 10)) fd2d <- fdata(X, argvals = list(1:10, 1:10), fdata2d = TRUE) fm2d <- mean(fd2d)"},{"path":"https://sipemu.github.io/fdars-r/reference/mean.irregFdata.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate Mean Function for Irregular Data — mean.irregFdata","title":"Estimate Mean Function for Irregular Data — mean.irregFdata","text":"Estimates mean function irregularly sampled functional data.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/mean.irregFdata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate Mean Function for Irregular Data — mean.irregFdata","text":"","code":"# S3 method for class 'irregFdata' mean(   x,   argvals = NULL,   method = c(\"basis\", \"kernel\"),   nbasis = 15,   type = c(\"bspline\", \"fourier\"),   bandwidth = NULL,   kernel = c(\"epanechnikov\", \"gaussian\"),   ... )"},{"path":"https://sipemu.github.io/fdars-r/reference/mean.irregFdata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate Mean Function for Irregular Data — mean.irregFdata","text":"x object class irregFdata. argvals Target grid mean estimation. NULL, uses regular grid 100 points. method Estimation method: \"basis\" (default, recommended) fits basis functions curve averages; \"kernel\" uses Nadaraya-Watson kernel smoothing. nbasis Number basis functions method = \"basis\" (default 15). type Basis type method = \"basis\": \"bspline\" (default) \"fourier\". bandwidth Kernel bandwidth method = \"kernel\". NULL, uses range/10. kernel Kernel type method = \"kernel\": \"epanechnikov\" (default) \"gaussian\". ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/mean.irregFdata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate Mean Function for Irregular Data — mean.irregFdata","text":"fdata object containing estimated mean function.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/mean.irregFdata.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Estimate Mean Function for Irregular Data — mean.irregFdata","text":"\"basis\" method (default) works : Fitting basis functions curve via least squares Reconstructing curve target grid Averaging reconstructed curves approach preserves functional structure typically gives accurate estimates kernel smoothing. \"kernel\" method uses Nadaraya-Watson estimation, pooling observations across curves. faster may less accurate structured functional data.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/mean.irregFdata.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate Mean Function for Irregular Data — mean.irregFdata","text":"","code":"t <- seq(0, 1, length.out = 100) fd <- simFunData(n = 50, argvals = t, M = 5, seed = 42) ifd <- sparsify(fd, minObs = 10, maxObs = 30, seed = 123)  # Recommended: basis method mean_fd <- mean(ifd) plot(mean_fd, main = \"Estimated Mean Function\")   # Alternative: kernel method mean_kernel <- mean(ifd, method = \"kernel\", bandwidth = 0.1)"},{"path":"https://sipemu.github.io/fdars-r/reference/median.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Functional Median — median","title":"Compute Functional Median — median","text":"Returns curve maximum depth using specified depth method.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/median.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Functional Median — median","text":"","code":"median(   fdataobj,   method = c(\"FM\", \"mode\", \"RP\", \"RT\", \"BD\", \"MBD\", \"FSD\", \"KFSD\", \"RPD\"),   ... )"},{"path":"https://sipemu.github.io/fdars-r/reference/median.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Functional Median — median","text":"fdataobj object class 'fdata'. method Depth method use. One \"FM\", \"mode\", \"RP\", \"RT\", \"BD\", \"MBD\", \"FSD\", \"KFSD\", \"RPD\". Default \"FM\". ... Additional arguments passed depth function.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/median.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Functional Median — median","text":"curve (fdata object) maximum depth.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/median.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Functional Median — median","text":"","code":"fd <- fdata(matrix(rnorm(100), 10, 10)) med <- median(fd) med_mode <- median(fd, method = \"mode\")"},{"path":"https://sipemu.github.io/fdars-r/reference/metric.DTW.html","id":null,"dir":"Reference","previous_headings":"","what":"Dynamic Time Warping for Functional Data — metric.DTW","title":"Dynamic Time Warping for Functional Data — metric.DTW","text":"Computes Dynamic Time Warping distance functional data. DTW allows non-linear alignment curves.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/metric.DTW.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dynamic Time Warping for Functional Data — metric.DTW","text":"","code":"metric.DTW(fdataobj, fdataref = NULL, p = 2, w = NULL, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/metric.DTW.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Dynamic Time Warping for Functional Data — metric.DTW","text":"fdataobj object class 'fdata'. fdataref object class 'fdata'. NULL, computes self-distances. p p Lp distance (default 2 L2/Euclidean). w Sakoe-Chiba window constraint. Default min(ncol(fdataobj), ncol(fdataref)). Use -1 window constraint. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/metric.DTW.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Dynamic Time Warping for Functional Data — metric.DTW","text":"distance matrix.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/metric.DTW.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Dynamic Time Warping for Functional Data — metric.DTW","text":"","code":"fd <- fdata(matrix(rnorm(100), 10, 10)) D <- metric.DTW(fd)"},{"path":"https://sipemu.github.io/fdars-r/reference/metric.hausdorff.html","id":null,"dir":"Reference","previous_headings":"","what":"Hausdorff Metric for Functional Data — metric.hausdorff","title":"Hausdorff Metric for Functional Data — metric.hausdorff","text":"Computes Hausdorff distance functional data objects. Hausdorff distance treats curve set points (t, f(t)) 2D space computes maximum minimum distances.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/metric.hausdorff.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hausdorff Metric for Functional Data — metric.hausdorff","text":"","code":"metric.hausdorff(fdataobj, fdataref = NULL, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/metric.hausdorff.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hausdorff Metric for Functional Data — metric.hausdorff","text":"fdataobj object class 'fdata'. fdataref object class 'fdata'. NULL, uses fdataobj. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/metric.hausdorff.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hausdorff Metric for Functional Data — metric.hausdorff","text":"distance matrix.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/metric.hausdorff.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hausdorff Metric for Functional Data — metric.hausdorff","text":"","code":"fd <- fdata(matrix(rnorm(100), 10, 10)) D <- metric.hausdorff(fd)"},{"path":"https://sipemu.github.io/fdars-r/reference/metric.html","id":null,"dir":"Reference","previous_headings":"","what":"Distance Metrics for Functional Data — metric","title":"Distance Metrics for Functional Data — metric","text":"Functions computing various distance metrics functional data. Compute Distance Metric Functional Data","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/metric.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Distance Metrics for Functional Data — metric","text":"","code":"metric(fdataobj, fdataref = NULL, method = \"lp\", ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/metric.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Distance Metrics for Functional Data — metric","text":"fdataobj object class 'fdata'. fdataref object class 'fdata'. NULL, computes self-distances. method Distance method use. One : \"lp\" - Lp metric (default) \"hausdorff\" - Hausdorff distance \"dtw\" - Dynamic Time Warping \"pca\" - Semi-metric based PCA scores \"deriv\" - Semi-metric based derivatives \"basis\" - Semi-metric based basis coefficients \"fourier\" - Semi-metric based FFT coefficients \"hshift\" - Semi-metric horizontal shift \"kl\" - Symmetric Kullback-Leibler divergence ... Additional arguments passed specific distance function.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/metric.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Distance Metrics for Functional Data — metric","text":"distance matrix.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/metric.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Distance Metrics for Functional Data — metric","text":"Unified interface computing various distance metrics functional data objects. function dispatches appropriate specialized distance function based method parameter. function provides convenient unified interface distance computations fdars. additional arguments ... passed underlying distance function: lp: lp, w hausdorff: (none) dtw: p, w pca: ncomp deriv: nderiv, lp basis: nbasis, basis, nderiv fourier: nfreq hshift: max_shift kl: eps, normalize","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/metric.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Distance Metrics for Functional Data — metric","text":"","code":"fd <- fdata(matrix(rnorm(200), 20, 10))  # Using different distance methods D_lp <- metric(fd, method = \"lp\") D_hausdorff <- metric(fd, method = \"hausdorff\") D_pca <- metric(fd, method = \"pca\", ncomp = 3)  # Cross-distances fd2 <- fdata(matrix(rnorm(100), 10, 10)) D_cross <- metric(fd, fd2, method = \"lp\")"},{"path":"https://sipemu.github.io/fdars-r/reference/metric.kl.html","id":null,"dir":"Reference","previous_headings":"","what":"Kullback-Leibler Divergence Metric for Functional Data — metric.kl","title":"Kullback-Leibler Divergence Metric for Functional Data — metric.kl","text":"Computes symmetric Kullback-Leibler divergence functional data treated probability distributions. Curves first normalized valid probability density functions.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/metric.kl.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Kullback-Leibler Divergence Metric for Functional Data — metric.kl","text":"","code":"metric.kl(fdataobj, fdataref = NULL, eps = 1e-10, normalize = TRUE, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/metric.kl.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Kullback-Leibler Divergence Metric for Functional Data — metric.kl","text":"fdataobj object class 'fdata'. fdataref object class 'fdata'. NULL, computes self-distances. eps Small value numerical stability (default 1e-10). normalize Logical. TRUE (default), curves shifted non-negative normalized integrate 1. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/metric.kl.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Kullback-Leibler Divergence Metric for Functional Data — metric.kl","text":"distance matrix based symmetric KL divergence.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/metric.kl.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Kullback-Leibler Divergence Metric for Functional Data — metric.kl","text":"symmetric KL divergence computed : $$D_{KL}(f, g) = \\frac{1}{2}[KL(f||g) + KL(g||f)]$$ $$KL(f||g) = \\int f(t) \\log\\frac{f(t)}{g(t)} dt$$ normalize = TRUE, curves first shifted non-negative (subtracting minimum adding eps), normalized integrate 1. makes valid probability density functions. symmetric KL divergence always non-negative equals zero two distributions identical. However, satisfy triangle inequality.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/metric.kl.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Kullback-Leibler Divergence Metric for Functional Data — metric.kl","text":"","code":"# Create curves that look like probability densities t <- seq(0, 1, length.out = 100) X <- matrix(0, 10, 100) for (i in 1:10) {   # Shifted Gaussian-like curves   X[i, ] <- exp(-(t - 0.3 - i/50)^2 / 0.02) + rnorm(100, sd = 0.01) } fd <- fdata(X, argvals = t)  # Compute KL divergence D <- metric.kl(fd)"},{"path":"https://sipemu.github.io/fdars-r/reference/metric.lp.html","id":null,"dir":"Reference","previous_headings":"","what":"Lp Metric for Functional Data — metric.lp.irregFdata","title":"Lp Metric for Functional Data — metric.lp.irregFdata","text":"Computes Lp distance functional data objects using numerical integration (Simpson's rule). Works regular fdata irregular irregFdata objects.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/metric.lp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lp Metric for Functional Data — metric.lp.irregFdata","text":"","code":"# S3 method for class 'irregFdata' metric.lp(x, p = 2, ...)  metric.lp(x, ...)  # S3 method for class 'fdata' metric.lp(x, y = NULL, p = 2, w = 1, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/metric.lp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Lp Metric for Functional Data — metric.lp.irregFdata","text":"x functional data object (fdata irregFdata). p order Lp metric (default 2 L2 distance). ... Additional arguments passed methods. y object class 'fdata'. NULL, computes self-distances x (efficient symmetric computation). supported fdata. w Optional weight vector length equal number evaluation points. Default uniform weighting. supported fdata.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/metric.lp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Lp Metric for Functional Data — metric.lp.irregFdata","text":"distance matrix.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/metric.lp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Lp Metric for Functional Data — metric.lp.irregFdata","text":"","code":"# Regular fdata fd <- fdata(matrix(rnorm(100), 10, 10)) D <- metric.lp(fd)  # Self-distances  # Irregular fdata ifd <- sparsify(fd, minObs = 3, maxObs = 7, seed = 42) D_irreg <- metric.lp(ifd)"},{"path":"https://sipemu.github.io/fdars-r/reference/norm.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Lp Norm of Functional Data — norm","title":"Compute Lp Norm of Functional Data — norm","text":"Generic function compute Lp norms functional data objects. Works regular fdata irregular irregFdata objects.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/norm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Lp Norm of Functional Data — norm","text":"","code":"norm(x, p = 2, ...)  # S3 method for class 'fdata' norm(x, p = 2, ...)  # S3 method for class 'irregFdata' norm(x, p = 2, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/norm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Lp Norm of Functional Data — norm","text":"x functional data object (fdata irregFdata). p order norm (default 2 L2 norm). ... Additional arguments passed methods.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/norm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Lp Norm of Functional Data — norm","text":"numeric vector norms, one per curve.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/norm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Lp Norm of Functional Data — norm","text":"","code":"# Regular fdata fd <- fdata(matrix(rnorm(100), 10, 10)) norms <- norm(fd)  # Irregular fdata ifd <- sparsify(fd, minObs = 3, maxObs = 7, seed = 42) norms_irreg <- norm(ifd)"},{"path":"https://sipemu.github.io/fdars-r/reference/normalize.html","id":null,"dir":"Reference","previous_headings":"","what":"Normalize functional data — normalize","title":"Normalize functional data — normalize","text":"Scales curve Lp norm equal 1.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/normalize.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Normalize functional data — normalize","text":"","code":"normalize(fdataobj, p = 2)"},{"path":"https://sipemu.github.io/fdars-r/reference/normalize.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Normalize functional data — normalize","text":"fdataobj object class 'fdata'. p order norm (default 2 L2 norm).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/normalize.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Normalize functional data — normalize","text":"normalized 'fdata' object curve unit norm.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/normalize.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Normalize functional data — normalize","text":"","code":"fd <- fdata(matrix(rnorm(100), 10, 10), argvals = seq(0, 1, length.out = 10)) fd_norm <- normalize(fd) norm(fd_norm)  # All values should be 1 #>  [1] 1 1 1 1 1 1 1 1 1 1"},{"path":"https://sipemu.github.io/fdars-r/reference/optim.np.html","id":null,"dir":"Reference","previous_headings":"","what":"Optimize Bandwidth Using Cross-Validation — optim.np","title":"Optimize Bandwidth Using Cross-Validation — optim.np","text":"Find optimal bandwidth minimizing CV GCV criterion.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/optim.np.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimize Bandwidth Using Cross-Validation — optim.np","text":"","code":"optim.np(   fdataobj,   S.type,   h.range = NULL,   criterion = \"GCV\",   Ker = \"norm\",   ... )"},{"path":"https://sipemu.github.io/fdars-r/reference/optim.np.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Optimize Bandwidth Using Cross-Validation — optim.np","text":"fdataobj fdata object. S.type Smoother function (S.NW, S.LLR, etc.). h.range Range bandwidths search (default: data-driven). criterion \"CV\" \"GCV\". Ker Kernel type. ... Additional arguments passed optimizer.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/optim.np.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Optimize Bandwidth Using Cross-Validation — optim.np","text":"list optimal bandwidth CV/GCV score.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/optim.np.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Optimize Bandwidth Using Cross-Validation — optim.np","text":"","code":"tt <- seq(0, 1, length.out = 50) y <- sin(2 * pi * tt) + rnorm(50, sd = 0.1) fd <- fdata(matrix(y, nrow = 1), argvals = tt) result <- optim.np(fd, S.NW)"},{"path":"https://sipemu.github.io/fdars-r/reference/outliergram.html","id":null,"dir":"Reference","previous_headings":"","what":"Outliergram for Functional Data — outliergram","title":"Outliergram for Functional Data — outliergram","text":"Creates outliergram plot displays MEI (Modified Epigraph Index) versus MBD (Modified Band Depth) outlier detection. Points parabolic boundary identified outliers, outlier classified type.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/outliergram.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Outliergram for Functional Data — outliergram","text":"","code":"outliergram(fdataobj, factor = 1.5, mei_threshold = 0.25, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/outliergram.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Outliergram for Functional Data — outliergram","text":"fdataobj object class 'fdata'. factor Factor adjust outlier detection threshold. Higher values make detection less sensitive. Default 1.5. mei_threshold Threshold classifying magnitude outliers based MEI. Curves MEI < mei_threshold MEI > (1 - mei_threshold) considered extreme magnitude. Default 0.25. ... Additional arguments (currently ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/outliergram.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Outliergram for Functional Data — outliergram","text":"object class 'outliergram' components: fdataobj input functional data mei MEI values curve mbd MBD values curve outliers Indices detected outliers outlier_type Character vector outlier types detected outlier: \"shape\", \"magnitude_high\", \"magnitude_low\", \"mixed\" n_outliers Number outliers detected factor factor used threshold adjustment parabola Coefficients parabolic boundary (a0, a1, a2)","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/outliergram.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Outliergram for Functional Data — outliergram","text":"outliergram plots MEI x-axis versus MBD y-axis. standard functional data, values lie near parabola. theoretical relationship uniformly distributed data : $$MBD = a_0 + a_1 \\cdot MEI + a_2 \\cdot MEI^2$$ Points fall significantly parabola identified outliers. factor parameter controls sensitivity: lower values detect outliers. Outlier Type Classification: shape: Curves unusual shape typical magnitude (moderate MEI, low MBD). curves cross curves frequently. magnitude_high: Curves shifted upward (high MEI, typically curves). magnitude_low: Curves shifted downward (low MEI, typically curves). mixed: Curves unusual shape extreme magnitude (extreme MEI low MBD).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/outliergram.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Outliergram for Functional Data — outliergram","text":"Arribas-Gil, . Romo, J. (2014). Shape outlier detection visualization functional data: outliergram. Biostatistics, 15(4), 603-619.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/reference/outliergram.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Outliergram for Functional Data — outliergram","text":"","code":"# Create functional data with different outlier types set.seed(42) t <- seq(0, 1, length.out = 50) X <- matrix(0, 32, 50) for (i in 1:29) X[i, ] <- sin(2 * pi * t) + rnorm(50, sd = 0.2) X[30, ] <- sin(2 * pi * t) + 2       # magnitude outlier (high) X[31, ] <- sin(2 * pi * t) - 2       # magnitude outlier (low) X[32, ] <- sin(4 * pi * t)           # shape outlier fd <- fdata(X, argvals = t)  # Create outliergram og <- outliergram(fd) print(og) #> Outliergram #> =========== #> Number of curves: 32  #> Outliers detected: 6  #>  #> Outlier types: #>   Shape:           4  #>   Magnitude (high): 1  #>   Magnitude (low):  1  #>  #> Outlier details: #>   Index 11 : shape  #>   Index 19 : shape  #>   Index 20 : shape  #>   Index 30 : magnitude_high  #>   Index 31 : magnitude_low  #>   Index 32 : shape  #>  #> Parameters: #>   Factor: 1.5  #>   MEI threshold: 0.25  plot(og, color_by_type = TRUE)"},{"path":"https://sipemu.github.io/fdars-r/reference/outliers.boxplot.html","id":null,"dir":"Reference","previous_headings":"","what":"Outlier Detection using Functional Boxplot — outliers.boxplot","title":"Outlier Detection using Functional Boxplot — outliers.boxplot","text":"Detects outliers based functional boxplot method. Curves exceed fence (1.5 times central envelope width) point flagged outliers.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/outliers.boxplot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Outlier Detection using Functional Boxplot — outliers.boxplot","text":"","code":"outliers.boxplot(   fdataobj,   prob = 0.5,   factor = 1.5,   depth.func = depth.MBD,   ... )"},{"path":"https://sipemu.github.io/fdars-r/reference/outliers.boxplot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Outlier Detection using Functional Boxplot — outliers.boxplot","text":"fdataobj object class 'fdata'. prob Proportion curves central region (default 0.5). factor Factor fence calculation (default 1.5). depth.func Depth function use. Default depth.MBD. ... Additional arguments passed depth function.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/outliers.boxplot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Outlier Detection using Functional Boxplot — outliers.boxplot","text":"list class 'outliers.fdata' components: outliers Indices detected outliers depths Depth values curves cutoff used (compatibility) fdataobj Original fdata object","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/reference/outliers.boxplot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Outlier Detection using Functional Boxplot — outliers.boxplot","text":"","code":"# Create functional data with outliers set.seed(42) t <- seq(0, 1, length.out = 50) X <- matrix(0, 30, 50) for (i in 1:28) X[i, ] <- sin(2*pi*t) + rnorm(50, sd = 0.2) X[29, ] <- sin(2*pi*t) + 2  # Magnitude outlier X[30, ] <- cos(2*pi*t)       # Shape outlier fd <- fdata(X, argvals = t)  # Detect outliers out <- outliers.boxplot(fd) print(out) #> Functional data outlier detection #>   Number of observations: 30  #>   Number of outliers: 2  #>   Outlier indices: 29 30"},{"path":"https://sipemu.github.io/fdars-r/reference/outliers.depth.pond.html","id":null,"dir":"Reference","previous_headings":"","what":"Outlier Detection for Functional Data — outliers.depth.pond","title":"Outlier Detection for Functional Data — outliers.depth.pond","text":"Functions detecting outliers functional data using depth measures. Outlier Detection using Weighted Depth","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/outliers.depth.pond.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Outlier Detection for Functional Data — outliers.depth.pond","text":"","code":"outliers.depth.pond(   fdataobj,   nb = 200,   dfunc = depth.mode,   threshold_method = c(\"quantile\", \"mad\", \"iqr\"),   quan = 0.05,   k = NULL,   ... )"},{"path":"https://sipemu.github.io/fdars-r/reference/outliers.depth.pond.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Outlier Detection for Functional Data — outliers.depth.pond","text":"fdataobj object class 'fdata'. nb Number bootstrap samples. Default 200. dfunc Depth function use. Default depth.mode. threshold_method Method computing outlier threshold. Options: \"quantile\" Use quantile weighted depths (default). Curves depth quantile flagged outliers. \"mad\" Use median - k * MAD weighted depths. robust existing outliers data. \"iqr\" Use Q1 - k * IQR, similar boxplot whiskers. quan Quantile outlier cutoff threshold_method = \"quantile\". Default 0.05, meaning curves depth bottom 5% flagged (95th percentile threshold). Lower values detect fewer outliers. k Multiplier MAD IQR methods. Default 2.5 MAD 1.5 IQR. Higher values detect fewer outliers. ... Additional arguments passed depth function.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/outliers.depth.pond.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Outlier Detection for Functional Data — outliers.depth.pond","text":"list class 'outliers.fdata' components: outliers Indices detected outliers depths Depth values curves weighted_depths Bootstrap-weighted depth values cutoff Depth cutoff used threshold_method Method used threshold computation fdataobj Original fdata object","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/outliers.depth.pond.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Outlier Detection for Functional Data — outliers.depth.pond","text":"Detects outliers based depth bootstrap resampling. threshold outlier detection can computed using different methods. function first computes depth values curves, uses bootstrap resampling obtain weighted depths robust sampling variability. Threshold Methods: quantile: Flags curves depth specified quantile. quan = 0.1, approximately 10% curves flagged null hypothesis outliers. Suitable expect specific proportion outliers. mad: Uses median(depths) - k * MAD(depths) threshold. robust MAD influenced extreme values. k = 2.5, corresponds roughly 1-2% false positive rate normality. iqr: Uses Q1 - k * IQR threshold, similar boxplot outlier detection. k = 1.5, corresponds standard boxplot fence.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/outliers.depth.pond.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Outlier Detection for Functional Data — outliers.depth.pond","text":"","code":"# Create data with outliers set.seed(42) t <- seq(0, 1, length.out = 50) X <- matrix(0, 30, 50) for (i in 1:28) X[i, ] <- sin(2*pi*t) + rnorm(50, sd = 0.2) X[29, ] <- sin(2*pi*t) + 3  # outlier X[30, ] <- -sin(2*pi*t)     # outlier fd <- fdata(X, argvals = t)  # Default: quantile method with 95th percentile (bottom 5%) out1 <- outliers.depth.pond(fd, nb = 50)  # More permissive: bottom 10% out1b <- outliers.depth.pond(fd, nb = 50, quan = 0.1)  # MAD method (more robust) out2 <- outliers.depth.pond(fd, nb = 50, threshold_method = \"mad\", k = 2.5)  # IQR method (boxplot-like) out3 <- outliers.depth.pond(fd, nb = 50, threshold_method = \"iqr\", k = 1.5)"},{"path":"https://sipemu.github.io/fdars-r/reference/outliers.depth.trim.html","id":null,"dir":"Reference","previous_headings":"","what":"Outlier Detection using Trimmed Depth — outliers.depth.trim","title":"Outlier Detection using Trimmed Depth — outliers.depth.trim","text":"Detects outliers based depth trimming.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/outliers.depth.trim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Outlier Detection using Trimmed Depth — outliers.depth.trim","text":"","code":"outliers.depth.trim(fdataobj, trim = 0.1, dfunc = depth.mode, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/outliers.depth.trim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Outlier Detection using Trimmed Depth — outliers.depth.trim","text":"fdataobj object class 'fdata'. trim Proportion curves consider potential outliers. Default 0.1 (curves depth bottom 10%). dfunc Depth function use. Default depth.mode. ... Additional arguments passed depth function.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/outliers.depth.trim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Outlier Detection using Trimmed Depth — outliers.depth.trim","text":"list class 'outliers.fdata' components: outliers Indices detected outliers depths Depth values curves cutoff Depth cutoff used","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/outliers.depth.trim.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Outlier Detection using Trimmed Depth — outliers.depth.trim","text":"","code":"fd <- fdata(matrix(rnorm(200), 20, 10)) out <- outliers.depth.trim(fd, trim = 0.1)"},{"path":"https://sipemu.github.io/fdars-r/reference/outliers.lrt.html","id":null,"dir":"Reference","previous_headings":"","what":"LRT-based Outlier Detection for Functional Data — outliers.lrt","title":"LRT-based Outlier Detection for Functional Data — outliers.lrt","text":"Detects outliers using Likelihood Ratio Test approach based Febrero-Bande et al. Uses bootstrap estimate threshold iteratively removes curves exceeding threshold. Implemented Rust high performance parallelized bootstrap.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/outliers.lrt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"LRT-based Outlier Detection for Functional Data — outliers.lrt","text":"","code":"outliers.lrt(   fdataobj,   nb = 200,   smo = 0.05,   trim = 0.1,   seed = NULL,   percentile = 0.99 )"},{"path":"https://sipemu.github.io/fdars-r/reference/outliers.lrt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"LRT-based Outlier Detection for Functional Data — outliers.lrt","text":"fdataobj object class 'fdata'. nb Number bootstrap replications threshold estimation (default 200). smo Smoothing parameter bootstrap noise (default 0.05). trim Proportion curves trim robust estimation (default 0.1). seed Random seed reproducibility. percentile Percentile bootstrap distribution use threshold (default 0.99, meaning 99th percentile). Lower values make detection sensitive (detect outliers).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/outliers.lrt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"LRT-based Outlier Detection for Functional Data — outliers.lrt","text":"list class 'outliers.fdata' components: outliers Indices detected outliers distances Normalized distances curves threshold Bootstrap threshold used percentile Percentile used threshold fdataobj Original fdata object","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/outliers.lrt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"LRT-based Outlier Detection for Functional Data — outliers.lrt","text":"","code":"t <- seq(0, 1, length.out = 50) X <- matrix(0, 30, 50) for (i in 1:30) X[i, ] <- sin(2*pi*t) + rnorm(50, sd = 0.1) # Add an outlier X[1, ] <- X[1, ] + 3 fd <- fdata(X, argvals = t) out <- outliers.lrt(fd, nb = 100)  # More sensitive detection out_sensitive <- outliers.lrt(fd, nb = 100, percentile = 0.95)"},{"path":"https://sipemu.github.io/fdars-r/reference/outliers.thres.lrt.html","id":null,"dir":"Reference","previous_headings":"","what":"LRT Outlier Detection Threshold — outliers.thres.lrt","title":"LRT Outlier Detection Threshold — outliers.thres.lrt","text":"Computes bootstrap threshold LRT-based outlier detection. highly parallelized Rust implementation providing significant speedup pure R implementations.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/outliers.thres.lrt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"LRT Outlier Detection Threshold — outliers.thres.lrt","text":"","code":"outliers.thres.lrt(   fdataobj,   nb = 200,   smo = 0.05,   trim = 0.1,   seed = NULL,   percentile = 0.99 )"},{"path":"https://sipemu.github.io/fdars-r/reference/outliers.thres.lrt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"LRT Outlier Detection Threshold — outliers.thres.lrt","text":"fdataobj object class 'fdata'. nb Number bootstrap replications (default 200). smo Smoothing parameter bootstrap noise (default 0.05). trim Proportion curves trim robust estimation (default 0.1). seed Random seed reproducibility. percentile Percentile bootstrap distribution use threshold (default 0.99, meaning 99th percentile). Lower values make detection sensitive (detect outliers).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/outliers.thres.lrt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"LRT Outlier Detection Threshold — outliers.thres.lrt","text":"threshold value specified percentile.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/outliers.thres.lrt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"LRT Outlier Detection Threshold — outliers.thres.lrt","text":"","code":"t <- seq(0, 1, length.out = 50) X <- matrix(0, 30, 50) for (i in 1:30) X[i, ] <- sin(2*pi*t) + rnorm(50, sd = 0.1) fd <- fdata(X, argvals = t) thresh <- outliers.thres.lrt(fd, nb = 100)  # More sensitive detection (95th percentile) thresh_sensitive <- outliers.thres.lrt(fd, nb = 100, percentile = 0.95)"},{"path":"https://sipemu.github.io/fdars-r/reference/plot.amplitude_modulation.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot method for amplitude_modulation objects — plot.amplitude_modulation","title":"Plot method for amplitude_modulation objects — plot.amplitude_modulation","text":"Plot method amplitude_modulation objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.amplitude_modulation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot method for amplitude_modulation objects — plot.amplitude_modulation","text":"","code":"# S3 method for class 'amplitude_modulation' plot(x, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/plot.amplitude_modulation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot method for amplitude_modulation objects — plot.amplitude_modulation","text":"x amplitude_modulation object. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.amplitude_modulation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot method for amplitude_modulation objects — plot.amplitude_modulation","text":"Invisibly returns input object x.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.basis.auto.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot method for basis.auto objects — plot.basis.auto","title":"Plot method for basis.auto objects — plot.basis.auto","text":"Plot method basis.auto objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.basis.auto.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot method for basis.auto objects — plot.basis.auto","text":"","code":"# S3 method for class 'basis.auto' plot(   x,   which = c(\"all\", \"fourier\", \"pspline\"),   show.original = TRUE,   max.curves = 20,   ... )"},{"path":"https://sipemu.github.io/fdars-r/reference/plot.basis.auto.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot method for basis.auto objects — plot.basis.auto","text":"x basis.auto object. curves plot: \"\" (default), \"fourier\", \"pspline\". show.original Logical. TRUE (default), overlay original data. max.curves Maximum number curves plot (default 20). ... Additional arguments passed ggplot.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.basis.auto.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot method for basis.auto objects — plot.basis.auto","text":"ggplot object (invisibly).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.basis.cv.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot method for basis.cv objects — plot.basis.cv","title":"Plot method for basis.cv objects — plot.basis.cv","text":"Plot method basis.cv objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.basis.cv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot method for basis.cv objects — plot.basis.cv","text":"","code":"# S3 method for class 'basis.cv' plot(x, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/plot.basis.cv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot method for basis.cv objects — plot.basis.cv","text":"x basis.cv object. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.basis.cv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot method for basis.cv objects — plot.basis.cv","text":"ggplot object (invisibly).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.cluster.fcm.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Method for cluster.fcm Objects — plot.cluster.fcm","title":"Plot Method for cluster.fcm Objects — plot.cluster.fcm","text":"Plot Method cluster.fcm Objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.cluster.fcm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Method for cluster.fcm Objects — plot.cluster.fcm","text":"","code":"# S3 method for class 'cluster.fcm' plot(x, type = c(\"curves\", \"membership\"), ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/plot.cluster.fcm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Method for cluster.fcm Objects — plot.cluster.fcm","text":"x object class 'cluster.fcm'. type Type plot: \"curves\" (default) \"membership\". ... Additional arguments (currently ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.cluster.fcm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Method for cluster.fcm Objects — plot.cluster.fcm","text":"ggplot object.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.cluster.kmeans.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Method for cluster.kmeans Objects — plot.cluster.kmeans","title":"Plot Method for cluster.kmeans Objects — plot.cluster.kmeans","text":"Plot Method cluster.kmeans Objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.cluster.kmeans.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Method for cluster.kmeans Objects — plot.cluster.kmeans","text":"","code":"# S3 method for class 'cluster.kmeans' plot(x, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/plot.cluster.kmeans.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Method for cluster.kmeans Objects — plot.cluster.kmeans","text":"x object class 'cluster.kmeans'. ... Additional arguments (currently ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.cluster.kmeans.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Method for cluster.kmeans Objects — plot.cluster.kmeans","text":"ggplot object.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.cluster.optim.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Method for cluster.optim Objects — plot.cluster.optim","title":"Plot Method for cluster.optim Objects — plot.cluster.optim","text":"Plot Method cluster.optim Objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.cluster.optim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Method for cluster.optim Objects — plot.cluster.optim","text":"","code":"# S3 method for class 'cluster.optim' plot(x, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/plot.cluster.optim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Method for cluster.optim Objects — plot.cluster.optim","text":"x object class 'cluster.optim'. ... Additional arguments (currently ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.cluster.optim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Method for cluster.optim Objects — plot.cluster.optim","text":"ggplot object.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.fdata.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot method for fdata objects — plot.fdata","title":"Plot method for fdata objects — plot.fdata","text":"Displays plot functional data. 1D functional data, plots curves lines optional coloring. 2D functional data, plots surfaces heatmaps contour lines.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.fdata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot method for fdata objects — plot.fdata","text":"","code":"# S3 method for class 'fdata' plot(   x,   color = NULL,   alpha = NULL,   show.mean = FALSE,   show.ci = FALSE,   ci.level = 0.9,   palette = NULL,   ... )"},{"path":"https://sipemu.github.io/fdars-r/reference/plot.fdata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot method for fdata objects — plot.fdata","text":"x object class 'fdata'. color Optional vector coloring curves. Can : Numeric vector: curves colored continuous scale (viridis) Factor/character: curves colored discrete groups Must length equal number curves. alpha Transparency individual curve lines. Default 0.7 basic plots, automatically reduced 0.3 show.mean = TRUE show.ci = TRUE reduce visual clutter allow mean curves stand . Can explicitly set override default. show.mean Logical. TRUE color categorical, overlay group mean curves thicker lines (default FALSE). show.ci Logical. TRUE color categorical, show pointwise confidence interval ribbons per group (default FALSE). ci.level Confidence level CI ribbons (default 0.90 90 percent). palette Optional named vector colors categorical coloring, e.g., c(\"\" = \"blue\", \"B\" = \"red\"). ... Additional arguments (currently ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.fdata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot method for fdata objects — plot.fdata","text":"ggplot object (invisibly).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.fdata.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot method for fdata objects — plot.fdata","text":"function displays plot immediately. get ggplot object without displaying (e.g., customization), use autoplot.fdata.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.fdata.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot method for fdata objects — plot.fdata","text":"","code":"library(ggplot2) # Display plot immediately fd <- fdata(matrix(rnorm(200), 20, 10)) plot(fd)   # To get ggplot object without displaying, use autoplot: p <- autoplot(fd)"},{"path":"https://sipemu.github.io/fdars-r/reference/plot.fdata2pc.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot FPCA Results — plot.fdata2pc","title":"Plot FPCA Results — plot.fdata2pc","text":"Visualize functional principal component analysis results multiple plot types: component perturbation plots, variance explained (scree plot), score plots.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.fdata2pc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot FPCA Results — plot.fdata2pc","text":"","code":"# S3 method for class 'fdata2pc' plot(   x,   type = c(\"components\", \"variance\", \"scores\"),   ncomp = 3,   multiple = 2,   show_both_directions = TRUE,   ... )"},{"path":"https://sipemu.github.io/fdars-r/reference/plot.fdata2pc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot FPCA Results — plot.fdata2pc","text":"x object class 'fdata2pc' fdata2pc. type Type plot: \"components\" (default) shows mean +/- scaled PC loadings, \"variance\" shows scree plot variance explained, \"scores\" shows PC1 vs PC2 scatter plot observations. ncomp Number components display (default 3 fewer available). multiple Factor scaling PC perturbations. Default 2 (shows +/- 2*sqrt(eigenvalue)*PC). show_both_directions Logical. TRUE (default), show positive negative perturbations (mean + PC mean - PC). FALSE, show positive perturbation. curves solid lines differentiated color. ... Additional arguments passed plotting functions.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.fdata2pc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot FPCA Results — plot.fdata2pc","text":"ggplot object (invisibly).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.fdata2pc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot FPCA Results — plot.fdata2pc","text":"\"components\" plot shows mean function (black) perturbations direction principal component. perturbation computed : mean +/- multiple * sqrt(variance_explained) * PC_loading. lines solid differentiated color . \"variance\" plot shows scree plot proportion variance explained component bar chart. \"scores\" plot shows scatter plot observations PC space, typically PC1 vs PC2.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/reference/plot.fdata2pc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot FPCA Results — plot.fdata2pc","text":"","code":"t <- seq(0, 1, length.out = 50) X <- matrix(0, 30, 50) for (i in 1:30) X[i, ] <- sin(2*pi*t + runif(1, 0, pi)) + rnorm(50, sd = 0.1) fd <- fdata(X, argvals = t) pc <- fdata2pc(fd, ncomp = 3)  # Plot PC components (mean +/- perturbations) plot(pc, type = \"components\")   # Scree plot plot(pc, type = \"variance\")   # Score plot plot(pc, type = \"scores\")"},{"path":"https://sipemu.github.io/fdars-r/reference/plot.group.distance.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot method for group.distance — plot.group.distance","title":"Plot method for group.distance — plot.group.distance","text":"Plot method group.distance","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.group.distance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot method for group.distance — plot.group.distance","text":"","code":"# S3 method for class 'group.distance' plot(x, type = c(\"heatmap\", \"dendrogram\"), which = NULL, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/plot.group.distance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot method for group.distance — plot.group.distance","text":"x object class 'group.distance'. type Plot type: \"heatmap\" \"dendrogram\". distance matrix plot. NULL (default), uses first available matrix group.distance object. ... Additional arguments.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.group.distance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot method for group.distance — plot.group.distance","text":"ggplot object (heatmap) NULL (dendrogram, uses base graphics).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.irregFdata.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot method for irregFdata objects — plot.irregFdata","title":"Plot method for irregFdata objects — plot.irregFdata","text":"Plot method irregFdata objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.irregFdata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot method for irregFdata objects — plot.irregFdata","text":"","code":"# S3 method for class 'irregFdata' plot(   x,   ...,   col = NULL,   lty = 1,   lwd = 1,   main = NULL,   xlab = NULL,   ylab = NULL,   add = FALSE,   alpha = 0.7 )"},{"path":"https://sipemu.github.io/fdars-r/reference/plot.irregFdata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot method for irregFdata objects — plot.irregFdata","text":"x irregFdata object. ... Additional arguments passed plot. col Colors curves. lty Line type. lwd Line width. main Plot title. xlab X-axis label. ylab Y-axis label. add Logical. TRUE, add existing plot. alpha Transparency many curves.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.irregFdata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot method for irregFdata objects — plot.irregFdata","text":"Invisibly returns input object x.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.lomb_scargle_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot method for lomb_scargle_result objects — plot.lomb_scargle_result","title":"Plot method for lomb_scargle_result objects — plot.lomb_scargle_result","text":"Plot method lomb_scargle_result objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.lomb_scargle_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot method for lomb_scargle_result objects — plot.lomb_scargle_result","text":"","code":"# S3 method for class 'lomb_scargle_result' plot(x, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/plot.lomb_scargle_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot method for lomb_scargle_result objects — plot.lomb_scargle_result","text":"x lomb_scargle_result object. ... Additional arguments passed plot.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.lomb_scargle_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot method for lomb_scargle_result objects — plot.lomb_scargle_result","text":"Invisibly returns NULL.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.magnitudeshape.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Method for magnitudeshape Objects — plot.magnitudeshape","title":"Plot Method for magnitudeshape Objects — plot.magnitudeshape","text":"Plot Method magnitudeshape Objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.magnitudeshape.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Method for magnitudeshape Objects — plot.magnitudeshape","text":"","code":"# S3 method for class 'magnitudeshape' plot(x, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/plot.magnitudeshape.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Method for magnitudeshape Objects — plot.magnitudeshape","text":"x object class 'magnitudeshape'. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.magnitudeshape.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Method for magnitudeshape Objects — plot.magnitudeshape","text":"ggplot object (invisibly).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.matrix_profile_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot method for matrix_profile_result objects — plot.matrix_profile_result","title":"Plot method for matrix_profile_result objects — plot.matrix_profile_result","text":"Plot method matrix_profile_result objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.matrix_profile_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot method for matrix_profile_result objects — plot.matrix_profile_result","text":"","code":"# S3 method for class 'matrix_profile_result' plot(x, type = c(\"profile\", \"arcs\", \"both\"), ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/plot.matrix_profile_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot method for matrix_profile_result objects — plot.matrix_profile_result","text":"x matrix_profile_result object. type Plot type: \"profile\", \"arcs\", \"\". ... Additional arguments passed plot.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.matrix_profile_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot method for matrix_profile_result objects — plot.matrix_profile_result","text":"Invisibly returns NULL.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.outliergram.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Method for Outliergram Objects — plot.outliergram","title":"Plot Method for Outliergram Objects — plot.outliergram","text":"Creates scatter plot MEI vs MBD parabolic boundary identified outliers highlighted.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.outliergram.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Method for Outliergram Objects — plot.outliergram","text":"","code":"# S3 method for class 'outliergram' plot(   x,   col_normal = \"gray60\",   col_outlier = \"red\",   color_by_type = FALSE,   show_parabola = TRUE,   show_threshold = TRUE,   label = \"index\",   label_all = FALSE,   ... )"},{"path":"https://sipemu.github.io/fdars-r/reference/plot.outliergram.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Method for Outliergram Objects — plot.outliergram","text":"x object class 'outliergram'. col_normal Color normal observations. Default \"gray60\". col_outlier Color outliers (used color_by_type = FALSE). Default \"red\". color_by_type Logical. TRUE, color outliers type (shape, magnitude_high, magnitude_low, mixed). Default FALSE. show_parabola Logical. TRUE, draw theoretical parabola. Default TRUE. show_threshold Logical. TRUE, draw adjusted threshold parabola. Default TRUE. label use labeling outlier points. Options: \"index\": Use numeric indices (default) \"id\": Use observation IDs fdata object column name fdata metadata (e.g., \"patient_id\") label_all Logical. TRUE, label points, just outliers. Default FALSE. ... Additional arguments passed plotting functions.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.outliergram.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Method for Outliergram Objects — plot.outliergram","text":"ggplot object (invisibly).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.outliers.fdata.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot method for outliers.fdata objects — plot.outliers.fdata","title":"Plot method for outliers.fdata objects — plot.outliers.fdata","text":"Plot method outliers.fdata objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.outliers.fdata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot method for outliers.fdata objects — plot.outliers.fdata","text":"","code":"# S3 method for class 'outliers.fdata' plot(x, col.outliers = \"red\", ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/plot.outliers.fdata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot method for outliers.fdata objects — plot.outliers.fdata","text":"x object class 'outliers.fdata'. col.outliers Color outlier curves (default \"red\"). ... Additional arguments (currently ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.outliers.fdata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot method for outliers.fdata objects — plot.outliers.fdata","text":"ggplot object.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.pspline.2d.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot method for pspline.2d objects — plot.pspline.2d","title":"Plot method for pspline.2d objects — plot.pspline.2d","text":"Plot method pspline.2d objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.pspline.2d.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot method for pspline.2d objects — plot.pspline.2d","text":"","code":"# S3 method for class 'pspline.2d' plot(x, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/plot.pspline.2d.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot method for pspline.2d objects — plot.pspline.2d","text":"x pspline.2d object. ... Additional arguments passed plot.fdata.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.pspline.2d.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot method for pspline.2d objects — plot.pspline.2d","text":"ggplot object (invisibly).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.pspline.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot method for pspline objects — plot.pspline","title":"Plot method for pspline objects — plot.pspline","text":"Plot method pspline objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.pspline.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot method for pspline objects — plot.pspline","text":"","code":"# S3 method for class 'pspline' plot(x, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/plot.pspline.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot method for pspline objects — plot.pspline","text":"x pspline object. ... Additional arguments passed plot.fdata.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.pspline.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot method for pspline objects — plot.pspline","text":"ggplot object (invisibly).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.register.fd.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Method for register.fd Objects — plot.register.fd","title":"Plot Method for register.fd Objects — plot.register.fd","text":"Plot Method register.fd Objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.register.fd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Method for register.fd Objects — plot.register.fd","text":"","code":"# S3 method for class 'register.fd' plot(x, type = c(\"registered\", \"original\", \"both\"), ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/plot.register.fd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Method for register.fd Objects — plot.register.fd","text":"x object class 'register.fd'. type Type plot: \"registered\" (default), \"original\", \"\". ... Additional arguments (currently ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.register.fd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Method for register.fd Objects — plot.register.fd","text":"ggplot object.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.ssa_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot method for ssa_result objects — plot.ssa_result","title":"Plot method for ssa_result objects — plot.ssa_result","text":"Plot method ssa_result objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.ssa_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot method for ssa_result objects — plot.ssa_result","text":"","code":"# S3 method for class 'ssa_result' plot(x, type = c(\"decomposition\", \"spectrum\"), curves = 1, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/plot.ssa_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot method for ssa_result objects — plot.ssa_result","text":"x ssa_result object. type Plot type: \"decomposition\" \"spectrum\". curves Indices curves plot. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.ssa_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot method for ssa_result objects — plot.ssa_result","text":"Invisibly returns NULL.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.stl_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot method for stl_result objects — plot.stl_result","title":"Plot method for stl_result objects — plot.stl_result","text":"Plot method stl_result objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.stl_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot method for stl_result objects — plot.stl_result","text":"","code":"# S3 method for class 'stl_result' plot(x, curves = 1, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/plot.stl_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot method for stl_result objects — plot.stl_result","text":"x stl_result object. curves Indices curves plot. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/plot.stl_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot method for stl_result objects — plot.stl_result","text":"Invisibly returns NULL.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/pred.MAE.html","id":null,"dir":"Reference","previous_headings":"","what":"Mean Absolute Error — pred.MAE","title":"Mean Absolute Error — pred.MAE","text":"Compute Mean Absolute Error predicted actual values.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/pred.MAE.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mean Absolute Error — pred.MAE","text":"","code":"pred.MAE(y_true, y_pred)"},{"path":"https://sipemu.github.io/fdars-r/reference/pred.MAE.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mean Absolute Error — pred.MAE","text":"y_true Actual values. y_pred Predicted values.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/pred.MAE.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mean Absolute Error — pred.MAE","text":"mean absolute error.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/pred.MAE.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Mean Absolute Error — pred.MAE","text":"","code":"y_true <- c(1, 2, 3, 4, 5) y_pred <- c(1.1, 2.2, 2.9, 4.1, 4.8) pred.MAE(y_true, y_pred) #> [1] 0.14"},{"path":"https://sipemu.github.io/fdars-r/reference/pred.MSE.html","id":null,"dir":"Reference","previous_headings":"","what":"Mean Squared Error — pred.MSE","title":"Mean Squared Error — pred.MSE","text":"Compute Mean Squared Error predicted actual values.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/pred.MSE.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mean Squared Error — pred.MSE","text":"","code":"pred.MSE(y_true, y_pred)"},{"path":"https://sipemu.github.io/fdars-r/reference/pred.MSE.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mean Squared Error — pred.MSE","text":"y_true Actual values. y_pred Predicted values.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/pred.MSE.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mean Squared Error — pred.MSE","text":"mean squared error.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/pred.MSE.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Mean Squared Error — pred.MSE","text":"","code":"y_true <- c(1, 2, 3, 4, 5) y_pred <- c(1.1, 2.2, 2.9, 4.1, 4.8) pred.MSE(y_true, y_pred) #> [1] 0.022"},{"path":"https://sipemu.github.io/fdars-r/reference/pred.R2.html","id":null,"dir":"Reference","previous_headings":"","what":"R-Squared (Coefficient of Determination) — pred.R2","title":"R-Squared (Coefficient of Determination) — pred.R2","text":"Compute R-squared value predicted actual values.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/pred.R2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"R-Squared (Coefficient of Determination) — pred.R2","text":"","code":"pred.R2(y_true, y_pred)"},{"path":"https://sipemu.github.io/fdars-r/reference/pred.R2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"R-Squared (Coefficient of Determination) — pred.R2","text":"y_true Actual values. y_pred Predicted values.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/pred.R2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"R-Squared (Coefficient of Determination) — pred.R2","text":"R-squared value.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/pred.R2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"R-Squared (Coefficient of Determination) — pred.R2","text":"","code":"y_true <- c(1, 2, 3, 4, 5) y_pred <- c(1.1, 2.2, 2.9, 4.1, 4.8) pred.R2(y_true, y_pred) #> [1] 0.989"},{"path":"https://sipemu.github.io/fdars-r/reference/pred.RMSE.html","id":null,"dir":"Reference","previous_headings":"","what":"Root Mean Squared Error — pred.RMSE","title":"Root Mean Squared Error — pred.RMSE","text":"Compute Root Mean Squared Error predicted actual values.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/pred.RMSE.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Root Mean Squared Error — pred.RMSE","text":"","code":"pred.RMSE(y_true, y_pred)"},{"path":"https://sipemu.github.io/fdars-r/reference/pred.RMSE.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Root Mean Squared Error — pred.RMSE","text":"y_true Actual values. y_pred Predicted values.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/pred.RMSE.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Root Mean Squared Error — pred.RMSE","text":"root mean squared error.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/pred.RMSE.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Root Mean Squared Error — pred.RMSE","text":"","code":"y_true <- c(1, 2, 3, 4, 5) y_pred <- c(1.1, 2.2, 2.9, 4.1, 4.8) pred.RMSE(y_true, y_pred) #> [1] 0.148324"},{"path":"https://sipemu.github.io/fdars-r/reference/predict.fregre.fd.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict Method for Functional Regression (fregre.fd) — predict.fregre.fd","title":"Predict Method for Functional Regression (fregre.fd) — predict.fregre.fd","text":"Predictions fitted functional regression model (fregre.pc fregre.basis).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/predict.fregre.fd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict Method for Functional Regression (fregre.fd) — predict.fregre.fd","text":"","code":"# S3 method for class 'fregre.fd' predict(object, newdata = NULL, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/predict.fregre.fd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict Method for Functional Regression (fregre.fd) — predict.fregre.fd","text":"object fitted model object class 'fregre.fd'. newdata fdata object containing new functional data prediction. NULL, returns fitted values training data. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/predict.fregre.fd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict Method for Functional Regression (fregre.fd) — predict.fregre.fd","text":"numeric vector predicted values.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/predict.fregre.fd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predict Method for Functional Regression (fregre.fd) — predict.fregre.fd","text":"","code":"# Create functional data t <- seq(0, 1, length.out = 50) X <- matrix(0, 30, 50) for (i in 1:30) X[i, ] <- sin(2*pi*t) * i/30 + rnorm(50, sd = 0.1) y <- rowMeans(X) + rnorm(30, sd = 0.1) fd <- fdata(X, argvals = t)  # Fit model fit <- fregre.pc(fd, y, ncomp = 3)  # Predict on new data X_new <- matrix(sin(2*pi*t) * 0.5, nrow = 1) fd_new <- fdata(X_new, argvals = t) predict(fit, fd_new) #> [1] 0.008787298"},{"path":"https://sipemu.github.io/fdars-r/reference/predict.fregre.np.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict Method for Nonparametric Functional Regression (fregre.np) — predict.fregre.np","title":"Predict Method for Nonparametric Functional Regression (fregre.np) — predict.fregre.np","text":"Predictions fitted nonparametric functional regression model.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/predict.fregre.np.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict Method for Nonparametric Functional Regression (fregre.np) — predict.fregre.np","text":"","code":"# S3 method for class 'fregre.np' predict(object, newdata = NULL, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/predict.fregre.np.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict Method for Nonparametric Functional Regression (fregre.np) — predict.fregre.np","text":"object fitted model object class 'fregre.np'. newdata fdata object containing new functional data prediction. NULL, returns fitted values training data. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/predict.fregre.np.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict Method for Nonparametric Functional Regression (fregre.np) — predict.fregre.np","text":"numeric vector predicted values.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/predict.fregre.np.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predict Method for Nonparametric Functional Regression (fregre.np) — predict.fregre.np","text":"","code":"# Create functional data t <- seq(0, 1, length.out = 50) X <- matrix(0, 30, 50) for (i in 1:30) X[i, ] <- sin(2*pi*t) * i/30 + rnorm(50, sd = 0.1) y <- rowMeans(X) + rnorm(30, sd = 0.1) fd <- fdata(X, argvals = t)  # Fit model fit <- fregre.np(fd, y)  # Predict on new data X_new <- matrix(sin(2*pi*t) * 0.5, nrow = 1) fd_new <- fdata(X_new, argvals = t) predict(fit, fd_new) #> [1] -0.005759715"},{"path":"https://sipemu.github.io/fdars-r/reference/predict.fregre.np.multi.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict method for fregre.np.multi — predict.fregre.np.multi","title":"Predict method for fregre.np.multi — predict.fregre.np.multi","text":"Predict method fregre.np.multi","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/predict.fregre.np.multi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict method for fregre.np.multi — predict.fregre.np.multi","text":"","code":"# S3 method for class 'fregre.np.multi' predict(object, newdata.list = NULL, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/predict.fregre.np.multi.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict method for fregre.np.multi — predict.fregre.np.multi","text":"object Fitted fregre.np.multi object. newdata.list List new fdata objects (length original). ... Additional arguments.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/predict.fregre.np.multi.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict method for fregre.np.multi — predict.fregre.np.multi","text":"Predicted values.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.amplitude_modulation.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for amplitude_modulation objects — print.amplitude_modulation","title":"Print method for amplitude_modulation objects — print.amplitude_modulation","text":"Print method amplitude_modulation objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.amplitude_modulation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for amplitude_modulation objects — print.amplitude_modulation","text":"","code":"# S3 method for class 'amplitude_modulation' print(x, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/print.amplitude_modulation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for amplitude_modulation objects — print.amplitude_modulation","text":"x amplitude_modulation object. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.amplitude_modulation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for amplitude_modulation objects — print.amplitude_modulation","text":"Invisibly returns input object x.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.autoperiod_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for autoperiod_result objects — print.autoperiod_result","title":"Print method for autoperiod_result objects — print.autoperiod_result","text":"Print method autoperiod_result objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.autoperiod_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for autoperiod_result objects — print.autoperiod_result","text":"","code":"# S3 method for class 'autoperiod_result' print(x, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/print.autoperiod_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for autoperiod_result objects — print.autoperiod_result","text":"x autoperiod_result object. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.autoperiod_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for autoperiod_result objects — print.autoperiod_result","text":"Invisibly returns input object x.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.basis.auto.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for basis.auto objects — print.basis.auto","title":"Print method for basis.auto objects — print.basis.auto","text":"Print method basis.auto objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.basis.auto.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for basis.auto objects — print.basis.auto","text":"","code":"# S3 method for class 'basis.auto' print(x, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/print.basis.auto.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for basis.auto objects — print.basis.auto","text":"x basis.auto object. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.basis.auto.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for basis.auto objects — print.basis.auto","text":"Invisibly returns input object x.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.basis.cv.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for basis.cv objects — print.basis.cv","title":"Print method for basis.cv objects — print.basis.cv","text":"Print method basis.cv objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.basis.cv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for basis.cv objects — print.basis.cv","text":"","code":"# S3 method for class 'basis.cv' print(x, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/print.basis.cv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for basis.cv objects — print.basis.cv","text":"x basis.cv object. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.basis.cv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for basis.cv objects — print.basis.cv","text":"Invisibly returns input object x.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.cfd_autoperiod_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for cfd_autoperiod_result objects — print.cfd_autoperiod_result","title":"Print method for cfd_autoperiod_result objects — print.cfd_autoperiod_result","text":"Print method cfd_autoperiod_result objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.cfd_autoperiod_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for cfd_autoperiod_result objects — print.cfd_autoperiod_result","text":"","code":"# S3 method for class 'cfd_autoperiod_result' print(x, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/print.cfd_autoperiod_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for cfd_autoperiod_result objects — print.cfd_autoperiod_result","text":"x cfd_autoperiod_result object. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.cfd_autoperiod_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for cfd_autoperiod_result objects — print.cfd_autoperiod_result","text":"Invisibly returns input object x.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.cluster.fcm.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Method for cluster.fcm Objects — print.cluster.fcm","title":"Print Method for cluster.fcm Objects — print.cluster.fcm","text":"Print Method cluster.fcm Objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.cluster.fcm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Method for cluster.fcm Objects — print.cluster.fcm","text":"","code":"# S3 method for class 'cluster.fcm' print(x, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/print.cluster.fcm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Method for cluster.fcm Objects — print.cluster.fcm","text":"x object class 'cluster.fcm'. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.cluster.fcm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print Method for cluster.fcm Objects — print.cluster.fcm","text":"Invisibly returns input object x.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.cluster.kmeans.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Method for cluster.kmeans Objects — print.cluster.kmeans","title":"Print Method for cluster.kmeans Objects — print.cluster.kmeans","text":"Print Method cluster.kmeans Objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.cluster.kmeans.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Method for cluster.kmeans Objects — print.cluster.kmeans","text":"","code":"# S3 method for class 'cluster.kmeans' print(x, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/print.cluster.kmeans.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Method for cluster.kmeans Objects — print.cluster.kmeans","text":"x object class 'cluster.kmeans'. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.cluster.kmeans.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print Method for cluster.kmeans Objects — print.cluster.kmeans","text":"Invisibly returns input object x.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.cluster.optim.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Method for cluster.optim Objects — print.cluster.optim","title":"Print Method for cluster.optim Objects — print.cluster.optim","text":"Print Method cluster.optim Objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.cluster.optim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Method for cluster.optim Objects — print.cluster.optim","text":"","code":"# S3 method for class 'cluster.optim' print(x, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/print.cluster.optim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Method for cluster.optim Objects — print.cluster.optim","text":"x object class 'cluster.optim'. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.cluster.optim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print Method for cluster.optim Objects — print.cluster.optim","text":"Invisibly returns input object x.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.decomposition.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for decomposition objects — print.decomposition","title":"Print method for decomposition objects — print.decomposition","text":"Print method decomposition objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.decomposition.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for decomposition objects — print.decomposition","text":"","code":"# S3 method for class 'decomposition' print(x, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/print.decomposition.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for decomposition objects — print.decomposition","text":"x decomposition object. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.decomposition.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for decomposition objects — print.decomposition","text":"Invisibly returns input object x.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.fbplot.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Method for fbplot Objects — print.fbplot","title":"Print Method for fbplot Objects — print.fbplot","text":"Print Method fbplot Objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.fbplot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Method for fbplot Objects — print.fbplot","text":"","code":"# S3 method for class 'fbplot' print(x, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/print.fbplot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Method for fbplot Objects — print.fbplot","text":"x object class 'fbplot'. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.fbplot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print Method for fbplot Objects — print.fbplot","text":"Invisibly returns input object x.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.fdata.bootstrap.ci.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for bootstrap CI — print.fdata.bootstrap.ci","title":"Print method for bootstrap CI — print.fdata.bootstrap.ci","text":"Print method bootstrap CI","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.fdata.bootstrap.ci.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for bootstrap CI — print.fdata.bootstrap.ci","text":"","code":"# S3 method for class 'fdata.bootstrap.ci' print(x, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/print.fdata.bootstrap.ci.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for bootstrap CI — print.fdata.bootstrap.ci","text":"x fdata.bootstrap.ci object. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.fdata.bootstrap.ci.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for bootstrap CI — print.fdata.bootstrap.ci","text":"Invisibly returns input object x.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.fdata.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for fdata objects — print.fdata","title":"Print method for fdata objects — print.fdata","text":"Print method fdata objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.fdata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for fdata objects — print.fdata","text":"","code":"# S3 method for class 'fdata' print(x, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/print.fdata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for fdata objects — print.fdata","text":"x object class 'fdata'. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.fdata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for fdata objects — print.fdata","text":"Invisibly returns input object x.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.fdata2pc.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Method for FPCA Results — print.fdata2pc","title":"Print Method for FPCA Results — print.fdata2pc","text":"Print Method FPCA Results","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.fdata2pc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Method for FPCA Results — print.fdata2pc","text":"","code":"# S3 method for class 'fdata2pc' print(x, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/print.fdata2pc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Method for FPCA Results — print.fdata2pc","text":"x object class 'fdata2pc'. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.fdata2pc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print Method for FPCA Results — print.fdata2pc","text":"Invisibly returns input object x.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.fregre.fd.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for fregre objects — print.fregre.fd","title":"Print method for fregre objects — print.fregre.fd","text":"Print method fregre objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.fregre.fd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for fregre objects — print.fregre.fd","text":"","code":"# S3 method for class 'fregre.fd' print(x, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/print.fregre.fd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for fregre objects — print.fregre.fd","text":"x fregre.fd object. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.fregre.fd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for fregre objects — print.fregre.fd","text":"Invisibly returns input object x.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.fregre.np.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for fregre.np objects — print.fregre.np","title":"Print method for fregre.np objects — print.fregre.np","text":"Print method fregre.np objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.fregre.np.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for fregre.np objects — print.fregre.np","text":"","code":"# S3 method for class 'fregre.np' print(x, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/print.fregre.np.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for fregre.np objects — print.fregre.np","text":"x fregre.np object. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.fregre.np.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for fregre.np objects — print.fregre.np","text":"Invisibly returns input object x.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.fregre.np.multi.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for fregre.np.multi — print.fregre.np.multi","title":"Print method for fregre.np.multi — print.fregre.np.multi","text":"Print method fregre.np.multi","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.fregre.np.multi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for fregre.np.multi — print.fregre.np.multi","text":"","code":"# S3 method for class 'fregre.np.multi' print(x, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/print.fregre.np.multi.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for fregre.np.multi — print.fregre.np.multi","text":"x fregre.np.multi object. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.fregre.np.multi.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for fregre.np.multi — print.fregre.np.multi","text":"Invisibly returns input object x.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.group.distance.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for group.distance — print.group.distance","title":"Print method for group.distance — print.group.distance","text":"Print method group.distance","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.group.distance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for group.distance — print.group.distance","text":"","code":"# S3 method for class 'group.distance' print(x, digits = 3, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/print.group.distance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for group.distance — print.group.distance","text":"x group.distance object. digits Number digits printing (default 3). ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.group.distance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for group.distance — print.group.distance","text":"Invisibly returns input object x.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.group.test.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for group.test — print.group.test","title":"Print method for group.test — print.group.test","text":"Print method group.test","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.group.test.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for group.test — print.group.test","text":"","code":"# S3 method for class 'group.test' print(x, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/print.group.test.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for group.test — print.group.test","text":"x group.test object. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.group.test.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for group.test — print.group.test","text":"Invisibly returns input object x.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.irregFdata.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for irregFdata objects — print.irregFdata","title":"Print method for irregFdata objects — print.irregFdata","text":"Print method irregFdata objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.irregFdata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for irregFdata objects — print.irregFdata","text":"","code":"# S3 method for class 'irregFdata' print(x, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/print.irregFdata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for irregFdata objects — print.irregFdata","text":"x irregFdata object. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.irregFdata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for irregFdata objects — print.irregFdata","text":"Invisibly returns input object x.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.kernel.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Method for Covariance Functions — print.kernel","title":"Print Method for Covariance Functions — print.kernel","text":"Print Method Covariance Functions","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.kernel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Method for Covariance Functions — print.kernel","text":"","code":"# S3 method for class 'kernel' print(x, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/print.kernel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Method for Covariance Functions — print.kernel","text":"x covariance function object. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.kernel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print Method for Covariance Functions — print.kernel","text":"Invisibly returns input object x.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.lomb_scargle_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for lomb_scargle_result objects — print.lomb_scargle_result","title":"Print method for lomb_scargle_result objects — print.lomb_scargle_result","text":"Print method lomb_scargle_result objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.lomb_scargle_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for lomb_scargle_result objects — print.lomb_scargle_result","text":"","code":"# S3 method for class 'lomb_scargle_result' print(x, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/print.lomb_scargle_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for lomb_scargle_result objects — print.lomb_scargle_result","text":"x lomb_scargle_result object. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.lomb_scargle_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for lomb_scargle_result objects — print.lomb_scargle_result","text":"Invisibly returns input object x.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.magnitudeshape.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Method for magnitudeshape Objects — print.magnitudeshape","title":"Print Method for magnitudeshape Objects — print.magnitudeshape","text":"Print Method magnitudeshape Objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.magnitudeshape.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Method for magnitudeshape Objects — print.magnitudeshape","text":"","code":"# S3 method for class 'magnitudeshape' print(x, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/print.magnitudeshape.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Method for magnitudeshape Objects — print.magnitudeshape","text":"x object class 'magnitudeshape'. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.magnitudeshape.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print Method for magnitudeshape Objects — print.magnitudeshape","text":"Invisibly returns input object x.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.matrix_profile_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for matrix_profile_result objects — print.matrix_profile_result","title":"Print method for matrix_profile_result objects — print.matrix_profile_result","text":"Print method matrix_profile_result objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.matrix_profile_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for matrix_profile_result objects — print.matrix_profile_result","text":"","code":"# S3 method for class 'matrix_profile_result' print(x, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/print.matrix_profile_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for matrix_profile_result objects — print.matrix_profile_result","text":"x matrix_profile_result object. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.matrix_profile_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for matrix_profile_result objects — print.matrix_profile_result","text":"Invisibly returns input object x.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.multiFunData.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for multiFunData objects — print.multiFunData","title":"Print method for multiFunData objects — print.multiFunData","text":"Print method multiFunData objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.multiFunData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for multiFunData objects — print.multiFunData","text":"","code":"# S3 method for class 'multiFunData' print(x, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/print.multiFunData.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for multiFunData objects — print.multiFunData","text":"x multiFunData object. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.multiFunData.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for multiFunData objects — print.multiFunData","text":"Invisibly returns input object x.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.multiple_periods.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for multiple_periods objects — print.multiple_periods","title":"Print method for multiple_periods objects — print.multiple_periods","text":"Print method multiple_periods objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.multiple_periods.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for multiple_periods objects — print.multiple_periods","text":"","code":"# S3 method for class 'multiple_periods' print(x, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/print.multiple_periods.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for multiple_periods objects — print.multiple_periods","text":"x multiple_periods object. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.multiple_periods.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for multiple_periods objects — print.multiple_periods","text":"Invisibly returns input object x.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.outliergram.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Method for Outliergram Objects — print.outliergram","title":"Print Method for Outliergram Objects — print.outliergram","text":"Print Method Outliergram Objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.outliergram.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Method for Outliergram Objects — print.outliergram","text":"","code":"# S3 method for class 'outliergram' print(x, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/print.outliergram.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Method for Outliergram Objects — print.outliergram","text":"x object class 'outliergram'. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.outliergram.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print Method for Outliergram Objects — print.outliergram","text":"Invisibly returns input object x.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.outliers.fdata.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for outliers.fdata objects — print.outliers.fdata","title":"Print method for outliers.fdata objects — print.outliers.fdata","text":"Print method outliers.fdata objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.outliers.fdata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for outliers.fdata objects — print.outliers.fdata","text":"","code":"# S3 method for class 'outliers.fdata' print(x, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/print.outliers.fdata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for outliers.fdata objects — print.outliers.fdata","text":"x outliers.fdata object. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.outliers.fdata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for outliers.fdata objects — print.outliers.fdata","text":"Invisibly returns input object x.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.peak_detection.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for peak_detection objects — print.peak_detection","title":"Print method for peak_detection objects — print.peak_detection","text":"Print method peak_detection objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.peak_detection.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for peak_detection objects — print.peak_detection","text":"","code":"# S3 method for class 'peak_detection' print(x, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/print.peak_detection.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for peak_detection objects — print.peak_detection","text":"x peak_detection object. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.peak_detection.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for peak_detection objects — print.peak_detection","text":"Invisibly returns input object x.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.peak_timing.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for peak_timing objects — print.peak_timing","title":"Print method for peak_timing objects — print.peak_timing","text":"Print method peak_timing objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.peak_timing.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for peak_timing objects — print.peak_timing","text":"","code":"# S3 method for class 'peak_timing' print(x, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/print.peak_timing.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for peak_timing objects — print.peak_timing","text":"x peak_timing object. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.peak_timing.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for peak_timing objects — print.peak_timing","text":"Invisibly returns input object x.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.period_estimate.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for period_estimate objects — print.period_estimate","title":"Print method for period_estimate objects — print.period_estimate","text":"Print method period_estimate objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.period_estimate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for period_estimate objects — print.period_estimate","text":"","code":"# S3 method for class 'period_estimate' print(x, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/print.period_estimate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for period_estimate objects — print.period_estimate","text":"x period_estimate object. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.period_estimate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for period_estimate objects — print.period_estimate","text":"Invisibly returns input object x.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.pspline.2d.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for pspline.2d objects — print.pspline.2d","title":"Print method for pspline.2d objects — print.pspline.2d","text":"Print method pspline.2d objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.pspline.2d.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for pspline.2d objects — print.pspline.2d","text":"","code":"# S3 method for class 'pspline.2d' print(x, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/print.pspline.2d.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for pspline.2d objects — print.pspline.2d","text":"x pspline.2d object. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.pspline.2d.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for pspline.2d objects — print.pspline.2d","text":"Invisibly returns input object x.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.pspline.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for pspline objects — print.pspline","title":"Print method for pspline objects — print.pspline","text":"Print method pspline objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.pspline.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for pspline objects — print.pspline","text":"","code":"# S3 method for class 'pspline' print(x, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/print.pspline.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for pspline objects — print.pspline","text":"x pspline object. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.pspline.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for pspline objects — print.pspline","text":"Invisibly returns input object x.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.register.fd.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Method for register.fd Objects — print.register.fd","title":"Print Method for register.fd Objects — print.register.fd","text":"Print Method register.fd Objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.register.fd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Method for register.fd Objects — print.register.fd","text":"","code":"# S3 method for class 'register.fd' print(x, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/print.register.fd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Method for register.fd Objects — print.register.fd","text":"x object class 'register.fd'. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.register.fd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print Method for register.fd Objects — print.register.fd","text":"Invisibly returns input object x.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.sazed_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for sazed_result objects — print.sazed_result","title":"Print method for sazed_result objects — print.sazed_result","text":"Print method sazed_result objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.sazed_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for sazed_result objects — print.sazed_result","text":"","code":"# S3 method for class 'sazed_result' print(x, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/print.sazed_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for sazed_result objects — print.sazed_result","text":"x sazed_result object. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.sazed_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for sazed_result objects — print.sazed_result","text":"Invisibly returns input object x.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.seasonality_changes.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for seasonality_changes objects — print.seasonality_changes","title":"Print method for seasonality_changes objects — print.seasonality_changes","text":"Print method seasonality_changes objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.seasonality_changes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for seasonality_changes objects — print.seasonality_changes","text":"","code":"# S3 method for class 'seasonality_changes' print(x, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/print.seasonality_changes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for seasonality_changes objects — print.seasonality_changes","text":"x seasonality_changes object. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.seasonality_changes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for seasonality_changes objects — print.seasonality_changes","text":"Invisibly returns input object x.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.seasonality_changes_auto.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for seasonality_changes_auto objects — print.seasonality_changes_auto","title":"Print method for seasonality_changes_auto objects — print.seasonality_changes_auto","text":"Print method seasonality_changes_auto objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.seasonality_changes_auto.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for seasonality_changes_auto objects — print.seasonality_changes_auto","text":"","code":"# S3 method for class 'seasonality_changes_auto' print(x, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/print.seasonality_changes_auto.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for seasonality_changes_auto objects — print.seasonality_changes_auto","text":"x seasonality_changes_auto object. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.seasonality_changes_auto.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for seasonality_changes_auto objects — print.seasonality_changes_auto","text":"Invisibly returns input object x.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.seasonality_classification.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for seasonality_classification objects — print.seasonality_classification","title":"Print method for seasonality_classification objects — print.seasonality_classification","text":"Print method seasonality_classification objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.seasonality_classification.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for seasonality_classification objects — print.seasonality_classification","text":"","code":"# S3 method for class 'seasonality_classification' print(x, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/print.seasonality_classification.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for seasonality_classification objects — print.seasonality_classification","text":"x seasonality_classification object. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.seasonality_classification.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for seasonality_classification objects — print.seasonality_classification","text":"Invisibly returns input object x.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.ssa_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for ssa_result objects — print.ssa_result","title":"Print method for ssa_result objects — print.ssa_result","text":"Print method ssa_result objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.ssa_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for ssa_result objects — print.ssa_result","text":"","code":"# S3 method for class 'ssa_result' print(x, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/print.ssa_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for ssa_result objects — print.ssa_result","text":"x ssa_result object. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.ssa_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for ssa_result objects — print.ssa_result","text":"Invisibly returns input object x.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.stl_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for stl_result objects — print.stl_result","title":"Print method for stl_result objects — print.stl_result","text":"Print method stl_result objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.stl_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for stl_result objects — print.stl_result","text":"","code":"# S3 method for class 'stl_result' print(x, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/print.stl_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for stl_result objects — print.stl_result","text":"x stl_result object. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/print.stl_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for stl_result objects — print.stl_result","text":"Invisibly returns input object x.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/pspline.2d.html","id":null,"dir":"Reference","previous_headings":"","what":"P-spline Smoothing for 2D Functional Data — pspline.2d","title":"P-spline Smoothing for 2D Functional Data — pspline.2d","text":"Fits 2D P-splines anisotropic penalties directions.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/pspline.2d.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"P-spline Smoothing for 2D Functional Data — pspline.2d","text":"","code":"pspline.2d(   fdataobj,   nbasis.s = 10,   nbasis.t = 10,   lambda.s = 1,   lambda.t = 1,   order = 2,   lambda.select = FALSE,   criterion = c(\"GCV\", \"AIC\", \"BIC\") )"},{"path":"https://sipemu.github.io/fdars-r/reference/pspline.2d.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"P-spline Smoothing for 2D Functional Data — pspline.2d","text":"fdataobj 2D fdata object. nbasis.s Number B-spline basis functions s direction. nbasis.t Number B-spline basis functions t direction. lambda.s Smoothing parameter s direction. lambda.t Smoothing parameter t direction. order Order difference penalty (default 2). lambda.select Logical. TRUE, select lambdas automatically. criterion Criterion selection: \"GCV\", \"AIC\", \"BIC\".","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/pspline.2d.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"P-spline Smoothing for 2D Functional Data — pspline.2d","text":"list class \"pspline.2d\" similar pspline().","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/pspline.2d.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"P-spline Smoothing for 2D Functional Data — pspline.2d","text":"2D penalty uses Kronecker product structure: $$P = \\lambda_s (I_t \\otimes P_s) + \\lambda_t (P_t \\otimes I_s)$$","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/pspline.html","id":null,"dir":"Reference","previous_headings":"","what":"P-spline Smoothing for Functional Data — pspline","title":"P-spline Smoothing for Functional Data — pspline","text":"Fits penalized B-splines (P-splines) functional data automatic manual selection smoothing parameter.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/pspline.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"P-spline Smoothing for Functional Data — pspline","text":"","code":"pspline(   fdataobj,   nbasis = 20,   lambda = 1,   order = 2,   lambda.select = FALSE,   criterion = c(\"GCV\", \"AIC\", \"BIC\"),   lambda.range = 10^seq(-4, 4, length.out = 50) )"},{"path":"https://sipemu.github.io/fdars-r/reference/pspline.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"P-spline Smoothing for Functional Data — pspline","text":"fdataobj fdata object. nbasis Number B-spline basis functions (default 20). lambda Smoothing parameter. Higher values give smoother curves. NULL lambda.select = TRUE, selected automatically. order Order difference penalty (default 2, second derivative penalty). lambda.select Logical. TRUE, select lambda automatically using specified criterion. criterion Criterion lambda selection: \"GCV\" (default), \"AIC\", \"BIC\". lambda.range Range lambda values search (log10 scale). Default: 10^seq(-4, 4, length.= 50).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/pspline.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"P-spline Smoothing for Functional Data — pspline","text":"list class \"pspline\" : fdata Smoothed fdata object coefs Coefficient matrix lambda Used selected lambda value edf Effective degrees freedom gcv/aic/bic Criterion values nbasis Number basis functions used","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/pspline.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"P-spline Smoothing for Functional Data — pspline","text":"P-splines minimize: $$||y - B c||^2 + \\lambda c' D' D c$$ B B-spline basis matrix, c coefficients, D difference matrix specified order.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/pspline.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"P-spline Smoothing for Functional Data — pspline","text":"Eilers, P.H.C. Marx, B.D. (1996). Flexible smoothing B-splines penalties. Statistical Science, 11(2), 89-121.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/pspline.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"P-spline Smoothing for Functional Data — pspline","text":"","code":"# Create noisy data t <- seq(0, 1, length.out = 100) true_signal <- sin(2 * pi * t) noisy <- true_signal + rnorm(100, sd = 0.3) fd <- fdata(matrix(noisy, nrow = 1), argvals = t)  # Smooth with P-splines result <- pspline(fd, nbasis = 20, lambda = 10) plot(fd)  lines(t, result$fdata$data[1, ], col = \"red\", lwd = 2) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet  # Automatic lambda selection result_auto <- pspline(fd, nbasis = 20, lambda.select = TRUE)"},{"path":"https://sipemu.github.io/fdars-r/reference/r.bridge.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Brownian Bridge — r.bridge","title":"Generate Brownian Bridge — r.bridge","text":"Simulate sample paths Brownian bridge, Brownian motion conditioned return 0 time 1.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/r.bridge.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Brownian Bridge — r.bridge","text":"","code":"r.bridge(n, t, sigma = 1, seed = NULL)"},{"path":"https://sipemu.github.io/fdars-r/reference/r.bridge.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Brownian Bridge — r.bridge","text":"n Number sample paths. t Evaluation points (include 0 1 standard bridge). sigma Volatility (default 1). seed Optional random seed.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/r.bridge.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Brownian Bridge — r.bridge","text":"fdata object containing simulated paths.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/r.bridge.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Brownian Bridge — r.bridge","text":"","code":"t <- seq(0, 1, length.out = 100) bb_data <- r.bridge(n = 20, t = t) plot(bb_data)"},{"path":"https://sipemu.github.io/fdars-r/reference/r.brownian.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Brownian Motion — r.brownian","title":"Generate Brownian Motion — r.brownian","text":"Simulate sample paths standard Brownian motion (Wiener process).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/r.brownian.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Brownian Motion — r.brownian","text":"","code":"r.brownian(n, t, sigma = 1, x0 = 0, seed = NULL)"},{"path":"https://sipemu.github.io/fdars-r/reference/r.brownian.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Brownian Motion — r.brownian","text":"n Number sample paths. t Evaluation points. sigma Volatility (standard deviation per unit time, default 1). x0 Initial value (default 0). seed Optional random seed.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/r.brownian.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Brownian Motion — r.brownian","text":"fdata object containing simulated paths.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/r.brownian.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Brownian Motion — r.brownian","text":"","code":"t <- seq(0, 1, length.out = 100) bm_data <- r.brownian(n = 20, t = t) plot(bm_data)"},{"path":"https://sipemu.github.io/fdars-r/reference/r.ou.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Ornstein-Uhlenbeck Process — r.ou","title":"Generate Ornstein-Uhlenbeck Process — r.ou","text":"Simulate sample paths Ornstein-Uhlenbeck process using Euler-Maruyama discretization scheme.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/r.ou.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Ornstein-Uhlenbeck Process — r.ou","text":"","code":"r.ou(n, t, mu = 0, theta = 1, sigma = 1, x0 = 0, seed = NULL)"},{"path":"https://sipemu.github.io/fdars-r/reference/r.ou.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Ornstein-Uhlenbeck Process — r.ou","text":"n Number sample paths generate. t Evaluation points (numeric vector). mu Long-term mean (default 0). theta Mean reversion rate (default 1). sigma Volatility (default 1). x0 Initial value (default 0). seed Optional random seed.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/r.ou.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Ornstein-Uhlenbeck Process — r.ou","text":"fdata object containing simulated paths.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/r.ou.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Ornstein-Uhlenbeck Process — r.ou","text":"OU process satisfies SDE: dX(t) = -theta * X(t) dt + sigma * dW(t)","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/r.ou.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Ornstein-Uhlenbeck Process — r.ou","text":"","code":"t <- seq(0, 1, length.out = 100) ou_data <- r.ou(n = 20, t = t, theta = 2, sigma = 1) plot(ou_data)"},{"path":"https://sipemu.github.io/fdars-r/reference/register.fd.html","id":null,"dir":"Reference","previous_headings":"","what":"Curve Registration (Alignment) — register.fd","title":"Curve Registration (Alignment) — register.fd","text":"Aligns functional data horizontal shifting target curve. reduces phase variation sample.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/register.fd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Curve Registration (Alignment) — register.fd","text":"","code":"register.fd(fdataobj, target = NULL, max.shift = 0.2)"},{"path":"https://sipemu.github.io/fdars-r/reference/register.fd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Curve Registration (Alignment) — register.fd","text":"fdataobj object class 'fdata'. target Target curve align . NULL (default), uses mean. max.shift Maximum allowed shift proportion domain (default 0.2).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/register.fd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Curve Registration (Alignment) — register.fd","text":"list class 'register.fd' components: registered fdata object registered (aligned) curves. shifts Numeric vector shift amounts curve. target target curve used alignment. fdataobj Original (unregistered) functional data.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/register.fd.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Curve Registration (Alignment) — register.fd","text":"Shift registration finds horizontal translation maximizes cross-correlation curve target. appropriate curves similar shapes differ mainly timing. complex warping, consider DTW-based methods.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/reference/register.fd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Curve Registration (Alignment) — register.fd","text":"","code":"# Create phase-shifted curves set.seed(42) t <- seq(0, 1, length.out = 100) X <- matrix(0, 20, 100) for (i in 1:20) {   phase <- runif(1, -0.1, 0.1)   X[i, ] <- sin(2*pi*(t + phase)) + rnorm(100, sd = 0.1) } fd <- fdata(X, argvals = t)  # Register curves reg <- register.fd(fd) print(reg) #> Curve Registration #> ================== #> Number of curves: 20  #> Shift statistics: #>   Min: -0.1212  #>   Max: 0.1212  #>   Mean: -5e-04  #>   SD: 0.0856   # Compare original vs registered par(mfrow = c(1, 2)) plot(fd)  plot(reg$registered)"},{"path":"https://sipemu.github.io/fdars-r/reference/sazed.html","id":null,"dir":"Reference","previous_headings":"","what":"SAZED: Spectral-ACF Zero-crossing Ensemble Detection — sazed","title":"SAZED: Spectral-ACF Zero-crossing Ensemble Detection — sazed","text":"parameter-free ensemble method robust period detection combines five different detection approaches uses majority voting determine consensus period.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/sazed.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SAZED: Spectral-ACF Zero-crossing Ensemble Detection — sazed","text":"","code":"sazed(fdataobj, tolerance = 0.1, detrend_method = c(\"none\", \"linear\", \"auto\"))"},{"path":"https://sipemu.github.io/fdars-r/reference/sazed.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SAZED: Spectral-ACF Zero-crossing Ensemble Detection — sazed","text":"fdataobj fdata object. tolerance Relative tolerance considering periods equal voting. Default: 0.1 (10% relative difference). Use smaller values stricter matching, larger values lenient matching. detrend_method Detrending method apply period estimation: \"none\" detrending (default) \"linear\" Remove linear trend \"auto\" Automatic AIC-based selection detrending method","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/sazed.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"SAZED: Spectral-ACF Zero-crossing Ensemble Detection — sazed","text":"list class \"sazed_result\" components: period Consensus period (average agreeing components) confidence Confidence score (0-1, proportion agreeing components) agreeing_components Number components agreed period components List individual component estimates:","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/sazed.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"SAZED: Spectral-ACF Zero-crossing Ensemble Detection — sazed","text":"SAZED combines five detection methods: Spectral: Finds peaks FFT periodogram noise floor ACF Peak: Identifies first significant peak autocorrelation function ACF Average: Computes weighted mean ACF peak locations Zero-crossing: Estimates period ACF zero-crossing intervals Spectral Diff: Applies FFT first-differenced signal (trend removal) final period chosen majority voting: periods within tolerance grouped together, group members determines consensus. returned period average agreeing estimates. method particularly robust : requires tuning parameters (tolerance sensible defaults) Multiple methods must agree high confidence Differencing component handles trends automatically Works well across different signal types","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/reference/sazed.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"SAZED: Spectral-ACF Zero-crossing Ensemble Detection — sazed","text":"","code":"# Generate seasonal data with period = 2 t <- seq(0, 20, length.out = 400) X <- matrix(sin(2 * pi * t / 2) + 0.1 * rnorm(400), nrow = 1) fd <- fdata(X, argvals = t)  # Detect period using SAZED result <- sazed(fd) print(result)  # Shows consensus period and component details #> SAZED Period Detection #> ---------------------- #> Period:     2.0029 #> Confidence: 1.00 (5/5 components agree) #>  #> Component estimates: #>   Spectral:      2.0050 #>   ACF Peak:      2.0050 #>   ACF Average:   2.0036 #>   Zero-crossing: 2.0010 #>   Spectral Diff: 2.0000  # With trend - SAZED's spectral_diff component handles this X_trend <- matrix(0.3 * t + sin(2 * pi * t / 2), nrow = 1) fd_trend <- fdata(X_trend, argvals = t) result <- sazed(fd_trend)"},{"path":"https://sipemu.github.io/fdars-r/reference/scale_minmax.html","id":null,"dir":"Reference","previous_headings":"","what":"Min-Max scaling for functional data — scale_minmax","title":"Min-Max scaling for functional data — scale_minmax","text":"Scales curve range \\([0, 1]\\) (custom range). preserves shape normalizing range.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/scale_minmax.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Min-Max scaling for functional data — scale_minmax","text":"","code":"scale_minmax(fdataobj, min = 0, max = 1)  # S3 method for class 'fdata' scale_minmax(fdataobj, min = 0, max = 1)  # S3 method for class 'irregFdata' scale_minmax(fdataobj, min = 0, max = 1)"},{"path":"https://sipemu.github.io/fdars-r/reference/scale_minmax.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Min-Max scaling for functional data — scale_minmax","text":"fdataobj object class 'fdata'. min Target minimum value (default 0). max Target maximum value (default 1).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/scale_minmax.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Min-Max scaling for functional data — scale_minmax","text":"scaled 'fdata' object curve specified range.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/scale_minmax.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Min-Max scaling for functional data — scale_minmax","text":"","code":"fd <- fdata(matrix(rnorm(100) * 10 + 50, 10, 10), argvals = seq(0, 1, length.out = 10)) fd_scaled <- scale_minmax(fd) # Check: each curve now in [0, 1] apply(fd_scaled$data, 1, range) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] #> [1,]    0    0    0    0    0    0    0    0    0     0 #> [2,]    1    1    1    1    1    1    1    1    1     1"},{"path":"https://sipemu.github.io/fdars-r/reference/sd.html","id":null,"dir":"Reference","previous_headings":"","what":"Functional Standard Deviation — sd","title":"Functional Standard Deviation — sd","text":"Computes pointwise standard deviation function functional data.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/sd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functional Standard Deviation — sd","text":"","code":"sd(fdataobj, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/sd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functional Standard Deviation — sd","text":"fdataobj object class 'fdata'. ... Additional arguments (currently ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/sd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Functional Standard Deviation — sd","text":"fdata object containing standard deviation function (1D 2D).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/sd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Functional Standard Deviation — sd","text":"","code":"# 1D functional data fd <- fdata(matrix(rnorm(100), 10, 10)) s <- sd(fd)  # 2D functional data X <- array(rnorm(500), dim = c(5, 10, 10)) fd2d <- fdata(X, argvals = list(1:10, 1:10), fdata2d = TRUE) s2d <- sd(fd2d)"},{"path":"https://sipemu.github.io/fdars-r/reference/seasonal.strength.curve.html","id":null,"dir":"Reference","previous_headings":"","what":"Time-Varying Seasonal Strength — seasonal.strength.curve","title":"Time-Varying Seasonal Strength — seasonal.strength.curve","text":"Computes seasonal strength time point using sliding window, allowing detection seasonality changes time.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/seasonal.strength.curve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Time-Varying Seasonal Strength — seasonal.strength.curve","text":"","code":"seasonal.strength.curve(   fdataobj,   period,   window_size = NULL,   method = c(\"variance\", \"spectral\") )"},{"path":"https://sipemu.github.io/fdars-r/reference/seasonal.strength.curve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Time-Varying Seasonal Strength — seasonal.strength.curve","text":"fdataobj fdata object. period Known estimated period. window_size Width sliding window. Recommended: 2 * period. method Method computing strength: \"variance\" \"spectral\".","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/seasonal.strength.curve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Time-Varying Seasonal Strength — seasonal.strength.curve","text":"fdata object containing time-varying seasonal strength curve.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/seasonal.strength.curve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Time-Varying Seasonal Strength — seasonal.strength.curve","text":"","code":"# Signal that transitions from seasonal to non-seasonal t <- seq(0, 20, length.out = 400) X <- ifelse(t < 10, sin(2 * pi * t / 2), rnorm(length(t[t >= 10]), sd = 0.5)) X <- matrix(X, nrow = 1) fd <- fdata(X, argvals = t)  # Compute time-varying strength ss <- seasonal.strength.curve(fd, period = 2, window_size = 4) # plot(ss)  # Shows strength declining around t = 10"},{"path":"https://sipemu.github.io/fdars-r/reference/seasonal.strength.html","id":null,"dir":"Reference","previous_headings":"","what":"Measure Seasonal Strength — seasonal.strength","title":"Measure Seasonal Strength — seasonal.strength","text":"Computes strength seasonality functional data. Values range 0 (seasonality) 1 (pure seasonal signal).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/seasonal.strength.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Measure Seasonal Strength — seasonal.strength","text":"","code":"seasonal.strength(   fdataobj,   period = NULL,   method = c(\"variance\", \"spectral\", \"wavelet\"),   n_harmonics = 3,   detrend_method = c(\"none\", \"linear\", \"auto\") )"},{"path":"https://sipemu.github.io/fdars-r/reference/seasonal.strength.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Measure Seasonal Strength — seasonal.strength","text":"fdataobj fdata object. period Known estimated period. NULL, period estimated automatically using FFT. method Method computing strength: \"variance\" Variance decomposition: Var(seasonal) / Var(total) \"spectral\" Spectral: power seasonal frequencies / total power \"wavelet\" Wavelet: Morlet wavelet power seasonal period / total variance n_harmonics Number Fourier harmonics use (variance method). Default: 3. detrend_method Detrending method apply computing strength: \"none\" detrending (default) \"linear\" Remove linear trend \"auto\" Automatic AIC-based selection detrending method","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/seasonal.strength.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Measure Seasonal Strength — seasonal.strength","text":"numeric value 0 1 representing seasonal strength.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/seasonal.strength.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Measure Seasonal Strength — seasonal.strength","text":"variance method decomposes signal seasonal component (using Fourier basis specified period) computes proportion variance explained seasonal component. spectral method computes proportion total spectral power falls seasonal frequency harmonics. wavelet method uses Morlet wavelet measure power target period. provides time-localized frequency information robust non-stationary signals. Trends can artificially lower seasonal strength measure contributing non-seasonal variance. Use detrend_method remove trends computing strength.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/seasonal.strength.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Measure Seasonal Strength — seasonal.strength","text":"","code":"# Pure seasonal signal t <- seq(0, 10, length.out = 200) X <- matrix(sin(2 * pi * t / 2), nrow = 1) fd_seasonal <- fdata(X, argvals = t) seasonal.strength(fd_seasonal, period = 2)  # Should be close to 1 #> [1] 1  # Pure noise X_noise <- matrix(rnorm(200), nrow = 1) fd_noise <- fdata(X_noise, argvals = t) seasonal.strength(fd_noise, period = 2)  # Should be close to 0 #> [1] 0.02096016  # Trending data - detrending improves strength estimate X_trend <- matrix(2 + 0.5 * t + sin(2 * pi * t / 2), nrow = 1) fd_trend <- fdata(X_trend, argvals = t) seasonal.strength(fd_trend, period = 2, detrend_method = \"linear\") #> [1] 0.9763512"},{"path":"https://sipemu.github.io/fdars-r/reference/select.basis.auto.html","id":null,"dir":"Reference","previous_headings":"","what":"Automatic Per-Curve Basis Type and Number Selection — select.basis.auto","title":"Automatic Per-Curve Basis Type and Number Selection — select.basis.auto","text":"Selects optimal basis type (Fourier P-spline) number basis functions curve individually using model selection criteria. useful working mixed datasets containing seasonal non-seasonal curves.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/select.basis.auto.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Automatic Per-Curve Basis Type and Number Selection — select.basis.auto","text":"","code":"select.basis.auto(   fdataobj,   criterion = c(\"GCV\", \"AIC\", \"BIC\"),   nbasis.range = NULL,   lambda.pspline = NULL,   use.seasonal.hint = TRUE )"},{"path":"https://sipemu.github.io/fdars-r/reference/select.basis.auto.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Automatic Per-Curve Basis Type and Number Selection — select.basis.auto","text":"fdataobj fdata object. criterion Model selection criterion: \"GCV\" (default), \"AIC\", \"BIC\". nbasis.range Optional numeric vector length 2 specifying c(min, max) nbasis search range. NULL, automatic ranges used: Fourier 3-25, P-spline 6-40 (limited data length). lambda.pspline Smoothing parameter P-splines. NULL (default), lambda automatically selected grid curve. use.seasonal.hint Logical. TRUE (default), uses FFT-based seasonality detection inform basis preference. Seasonal curves start Fourier search 5 basis functions.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/select.basis.auto.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Automatic Per-Curve Basis Type and Number Selection — select.basis.auto","text":"list class \"basis.auto\" : basis.type Character vector (\"pspline\" \"fourier\") curve nbasis Integer vector selected nbasis per curve score Numeric vector best criterion scores coefficients List coefficient vectors curve fitted fdata object fitted values edf Numeric vector effective degrees freedom seasonal.detected Logical vector indicating detected seasonality lambda Numeric vector lambda values (NA Fourier curves) criterion Character string criterion used original Original fdata object","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/select.basis.auto.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Automatic Per-Curve Basis Type and Number Selection — select.basis.auto","text":"curve, function searches : Fourier basis: odd nbasis values 3 (5 seasonal) min(m/3, 25) P-spline basis: nbasis 6 min(m/2, 40), lambda grid {0.001, 0.01, 0.1, 1, 10, 100} lambda.pspline NULL function uses parallel processing (via Rust/rayon) efficiency processing multiple curves.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/reference/select.basis.auto.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Automatic Per-Curve Basis Type and Number Selection — select.basis.auto","text":"","code":"# Generate mixed data: some seasonal, some polynomial set.seed(42) t <- seq(0, 10, length.out = 100)  # 3 seasonal curves X_seasonal <- matrix(0, 3, 100) for (i in 1:3) {   X_seasonal[i, ] <- sin(2 * pi * t / 2.5) + rnorm(100, sd = 0.2) }  # 3 polynomial curves X_poly <- matrix(0, 3, 100) for (i in 1:3) {   X_poly[i, ] <- 0.1 * t^2 - t + rnorm(100, sd = 0.5) }  fd <- fdata(rbind(X_seasonal, X_poly), argvals = t)  # Auto-select optimal basis for each curve result <- select.basis.auto(fd) print(result) #> Automatic Basis Selection Results #> ================================== #> Curves: 6  #> Criterion: GCV  #>  #> Basis type distribution: #>   Fourier: 3 (50%) #>   P-spline:3 (50%) #>  #> Mean GCV score: 0.1484  #> Mean EDF: 6.86  #> Seasonal detected: 6 curves  # Should detect: first 3 as Fourier, last 3 as P-spline table(result$basis.type) #>  #> fourier pspline  #>       3       3"},{"path":"https://sipemu.github.io/fdars-r/reference/semimetric.basis.html","id":null,"dir":"Reference","previous_headings":"","what":"Semi-metric based on Basis Expansion — semimetric.basis","title":"Semi-metric based on Basis Expansion — semimetric.basis","text":"Computes semi-metric based L2 distance basis expansion coefficients. Supports B-spline Fourier basis.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/semimetric.basis.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Semi-metric based on Basis Expansion — semimetric.basis","text":"","code":"semimetric.basis(   fdataobj,   fdataref = NULL,   nbasis = 5,   basis = \"bspline\",   nderiv = 0,   ... )"},{"path":"https://sipemu.github.io/fdars-r/reference/semimetric.basis.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Semi-metric based on Basis Expansion — semimetric.basis","text":"fdataobj object class 'fdata'. fdataref object class 'fdata'. NULL, uses fdataobj. nbasis Number basis functions. Default 5. basis Type basis: \"bspline\" (default) \"fourier\". nderiv Derivative order compute distance (default 0). ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/semimetric.basis.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Semi-metric based on Basis Expansion — semimetric.basis","text":"distance matrix based basis coefficients.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/semimetric.basis.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Semi-metric based on Basis Expansion — semimetric.basis","text":"","code":"# Create curves t <- seq(0, 1, length.out = 100) X <- matrix(0, 10, 100) for (i in 1:10) X[i, ] <- sin(2*pi*t + i/5) + rnorm(100, sd = 0.1) fd <- fdata(X, argvals = t)  # Compute distance based on B-spline coefficients D <- semimetric.basis(fd, nbasis = 7)"},{"path":"https://sipemu.github.io/fdars-r/reference/semimetric.deriv.html","id":null,"dir":"Reference","previous_headings":"","what":"Semi-metric based on Derivatives — semimetric.deriv","title":"Semi-metric based on Derivatives — semimetric.deriv","text":"Computes semi-metric based Lp distance nderiv-th derivative functional data.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/semimetric.deriv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Semi-metric based on Derivatives — semimetric.deriv","text":"","code":"semimetric.deriv(fdataobj, fdataref = NULL, nderiv = 1, lp = 2, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/semimetric.deriv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Semi-metric based on Derivatives — semimetric.deriv","text":"fdataobj object class 'fdata'. fdataref object class 'fdata'. NULL, uses fdataobj. nderiv Derivative order (1, 2, ...). Default 1. lp p Lp metric. Default 2 (L2 distance). ... Additional arguments passed deriv.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/semimetric.deriv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Semi-metric based on Derivatives — semimetric.deriv","text":"distance matrix based derivative distances.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/semimetric.deriv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Semi-metric based on Derivatives — semimetric.deriv","text":"","code":"# Create smooth curves t <- seq(0, 2*pi, length.out = 100) X <- matrix(0, 10, 100) for (i in 1:10) X[i, ] <- sin(t + i/5) fd <- fdata(X, argvals = t)  # Compute distance based on first derivative D <- semimetric.deriv(fd, nderiv = 1)"},{"path":"https://sipemu.github.io/fdars-r/reference/semimetric.fourier.html","id":null,"dir":"Reference","previous_headings":"","what":"Semi-metric based on Fourier Coefficients (FFT) — semimetric.fourier","title":"Semi-metric based on Fourier Coefficients (FFT) — semimetric.fourier","text":"Computes semi-metric based L2 distance Fourier coefficients computed via Fast Fourier Transform (FFT). efficient Fourier basis option semimetric.basis large nfreq.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/semimetric.fourier.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Semi-metric based on Fourier Coefficients (FFT) — semimetric.fourier","text":"","code":"semimetric.fourier(fdataobj, fdataref = NULL, nfreq = 5, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/semimetric.fourier.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Semi-metric based on Fourier Coefficients (FFT) — semimetric.fourier","text":"fdataobj object class 'fdata'. fdataref object class 'fdata'. NULL, uses fdataobj. nfreq Number Fourier frequencies use (excluding DC). Default 5. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/semimetric.fourier.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Semi-metric based on Fourier Coefficients (FFT) — semimetric.fourier","text":"distance matrix based Fourier coefficients.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/semimetric.fourier.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Semi-metric based on Fourier Coefficients (FFT) — semimetric.fourier","text":"Fourier coefficients computed using FFT normalized number points. distance L2 distance magnitude first nfreq+1 coefficients (DC + nfreq frequencies). function uses Rust's rustfft library efficient FFT computation, making faster R's base fft large datasets.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/semimetric.fourier.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Semi-metric based on Fourier Coefficients (FFT) — semimetric.fourier","text":"","code":"# Create curves with different frequency content t <- seq(0, 1, length.out = 100) X <- matrix(0, 10, 100) for (i in 1:10) X[i, ] <- sin(2*pi*i*t) + rnorm(100, sd = 0.1) fd <- fdata(X, argvals = t)  # Compute distance based on Fourier coefficients D <- semimetric.fourier(fd, nfreq = 10)"},{"path":"https://sipemu.github.io/fdars-r/reference/semimetric.hshift.html","id":null,"dir":"Reference","previous_headings":"","what":"Semi-metric based on Horizontal Shift (Time Warping) — semimetric.hshift","title":"Semi-metric based on Horizontal Shift (Time Warping) — semimetric.hshift","text":"Computes semi-metric based minimum L2 distance optimal horizontal shifting curves. useful comparing curves may phase differences.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/semimetric.hshift.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Semi-metric based on Horizontal Shift (Time Warping) — semimetric.hshift","text":"","code":"semimetric.hshift(fdataobj, fdataref = NULL, max_shift = -1, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/semimetric.hshift.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Semi-metric based on Horizontal Shift (Time Warping) — semimetric.hshift","text":"fdataobj object class 'fdata'. fdataref object class 'fdata'. NULL, uses fdataobj. max_shift Maximum shift number grid points. Default m/4 m number evaluation points. Use -1 automatic. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/semimetric.hshift.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Semi-metric based on Horizontal Shift (Time Warping) — semimetric.hshift","text":"distance matrix based minimum L2 distance shift.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/semimetric.hshift.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Semi-metric based on Horizontal Shift (Time Warping) — semimetric.hshift","text":"pair curves, function computes: $$d(f, g) = \\min_{|h| \\le h_{max}} ||f(t) - g(t+h)||$$ h horizontal shift discrete units. semi-metric useful comparing curves phase shifts, ECG signals different heart rates periodic signals different phases.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/semimetric.hshift.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Semi-metric based on Horizontal Shift (Time Warping) — semimetric.hshift","text":"","code":"# Create curves with phase shifts t <- seq(0, 2*pi, length.out = 100) X <- matrix(0, 10, 100) for (i in 1:10) X[i, ] <- sin(t + i*0.2) + rnorm(100, sd = 0.1) fd <- fdata(X, argvals = t)  # Compute distance accounting for phase shifts D <- semimetric.hshift(fd, max_shift = 10)"},{"path":"https://sipemu.github.io/fdars-r/reference/semimetric.pca.html","id":null,"dir":"Reference","previous_headings":"","what":"Semi-metric based on Principal Components — semimetric.pca","title":"Semi-metric based on Principal Components — semimetric.pca","text":"Computes semi-metric based first ncomp principal component scores.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/semimetric.pca.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Semi-metric based on Principal Components — semimetric.pca","text":"","code":"semimetric.pca(fdataobj, fdataref = NULL, ncomp = 2, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/semimetric.pca.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Semi-metric based on Principal Components — semimetric.pca","text":"fdataobj object class 'fdata'. fdataref object class 'fdata'. NULL, uses fdataobj. ncomp Number principal components use. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/semimetric.pca.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Semi-metric based on Principal Components — semimetric.pca","text":"distance matrix based PC scores.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/semimetric.pca.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Semi-metric based on Principal Components — semimetric.pca","text":"","code":"fd <- fdata(matrix(rnorm(200), 20, 10)) D <- semimetric.pca(fd, ncomp = 3)"},{"path":"https://sipemu.github.io/fdars-r/reference/simFunData.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate Functional Data via Karhunen-Loeve Expansion — simFunData","title":"Simulate Functional Data via Karhunen-Loeve Expansion — simFunData","text":"Generates functional data samples using truncated Karhunen-Loeve representation: f_i(t) = mean(t) + sum_{k=1}^M xi_{ik} * phi_k(t) xi_{ik} ~ N(0, lambda_k).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/simFunData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate Functional Data via Karhunen-Loeve Expansion — simFunData","text":"","code":"simFunData(   n,   argvals,   M,   eFun.type = c(\"Fourier\", \"Poly\", \"PolyHigh\", \"Wiener\"),   eVal.type = c(\"linear\", \"exponential\", \"wiener\"),   mean = NULL,   seed = NULL )"},{"path":"https://sipemu.github.io/fdars-r/reference/simFunData.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate Functional Data via Karhunen-Loeve Expansion — simFunData","text":"n Number curves generate. argvals Numeric vector evaluation points. M Number basis functions (eigenfunctions) use. eFun.type Type eigenfunction basis: \"Fourier\", \"Poly\", \"PolyHigh\", \"Wiener\". eVal.type Type eigenvalue decay: \"linear\", \"exponential\", \"wiener\". mean Mean function. Can : NULL zero mean numeric vector length equal argvals function takes argvals input seed Optional integer random seed reproducibility.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/simFunData.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate Functional Data via Karhunen-Loeve Expansion — simFunData","text":"fdata object containing simulated functional data.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/simFunData.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate Functional Data via Karhunen-Loeve Expansion — simFunData","text":"Karhunen-Loeve expansion provides natural way simulate Gaussian functional data specified covariance structure. eigenvalues control variance contribution mode, eigenfunctions determine shape variation. theoretical covariance function : Cov(X(s), X(t)) = sum_{k=1}^M lambda_k * phi_k(s) * phi_k(t)","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/reference/simFunData.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate Functional Data via Karhunen-Loeve Expansion — simFunData","text":"","code":"t <- seq(0, 1, length.out = 100)  # Basic simulation with Fourier basis fd <- simFunData(n = 20, argvals = t, M = 5,                  eFun.type = \"Fourier\", eVal.type = \"linear\") plot(fd, main = \"Simulated Functional Data (Fourier, Linear)\")   # Smoother curves with exponential decay fd_smooth <- simFunData(n = 20, argvals = t, M = 10,                         eFun.type = \"Fourier\", eVal.type = \"exponential\") plot(fd_smooth, main = \"Smooth Simulated Data (Exponential Decay)\")   # Wiener process simulation fd_wiener <- simFunData(n = 20, argvals = t, M = 10,                         eFun.type = \"Wiener\", eVal.type = \"wiener\", seed = 42) plot(fd_wiener, main = \"Wiener Process Simulation\")   # With mean function mean_fn <- function(t) sin(2 * pi * t) fd_mean <- simFunData(n = 20, argvals = t, M = 5, mean = mean_fn, seed = 42) plot(fd_mean, main = \"Simulated Data with Sinusoidal Mean\")"},{"path":"https://sipemu.github.io/fdars-r/reference/simMultiFunData.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate Multivariate Functional Data — simMultiFunData","title":"Simulate Multivariate Functional Data — simMultiFunData","text":"Generates multivariate (vector-valued) functional data component simulated via Karhunen-Loeve expansion potentially different eigenfunctions, eigenvalues, domains.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/simMultiFunData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate Multivariate Functional Data — simMultiFunData","text":"","code":"simMultiFunData(   n,   argvals,   M,   eFun.type = \"Fourier\",   eVal.type = \"linear\",   mean = NULL,   seed = NULL )"},{"path":"https://sipemu.github.io/fdars-r/reference/simMultiFunData.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate Multivariate Functional Data — simMultiFunData","text":"n Number multivariate curves generate. argvals List numeric vectors, one per component. M Integer integer vector. Number basis functions per component. single integer, used components. eFun.type Character character vector specifying eigenfunction type component. See eFun options. eVal.type Character character vector specifying eigenvalue decay component. See eVal options. mean List mean functions (one per component), NULL. seed Optional integer random seed.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/simMultiFunData.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate Multivariate Functional Data — simMultiFunData","text":"list class multiFunData containing: components List fdata objects, one per component n Number observations p Number components","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/reference/simMultiFunData.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate Multivariate Functional Data — simMultiFunData","text":"","code":"# Two-component multivariate functional data t1 <- seq(0, 1, length.out = 100) t2 <- seq(0, 0.5, length.out = 50)  mfd <- simMultiFunData(   n = 20,   argvals = list(t1, t2),   M = c(5, 3),   eFun.type = c(\"Fourier\", \"Wiener\"),   eVal.type = c(\"exponential\", \"linear\") )  # Plot first component plot(mfd$components[[1]], main = \"Component 1\")"},{"path":"https://sipemu.github.io/fdars-r/reference/sparsify.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert Regular Functional Data to Irregular by Subsampling — sparsify","title":"Convert Regular Functional Data to Irregular by Subsampling — sparsify","text":"Creates irregFdata object regular fdata randomly selecting subset observation points curve.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/sparsify.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert Regular Functional Data to Irregular by Subsampling — sparsify","text":"","code":"sparsify(fdataobj, minObs = 5, maxObs = NULL, prob = NULL, seed = NULL)"},{"path":"https://sipemu.github.io/fdars-r/reference/sparsify.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert Regular Functional Data to Irregular by Subsampling — sparsify","text":"fdataobj object class fdata. minObs Minimum number observations keep per curve. maxObs Maximum number observations keep per curve. NULL, uses total number points. prob Sampling probability function. NULL, uniform sampling used. Otherwise, function takes argvals returns sampling weights (necessarily normalized). seed Optional integer random seed reproducibility.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/sparsify.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert Regular Functional Data to Irregular by Subsampling — sparsify","text":"object class irregFdata.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/sparsify.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert Regular Functional Data to Irregular by Subsampling — sparsify","text":"curve, function: Draws random number points keep minObs maxObs Samples many points (without replacement) grid prob provided, sampling weighted accordingly Common probability functions: Uniform: NULL (default) points middle: function(t) dnorm(t, mean = 0.5, sd = 0.2) points ends: function(t) 1 - dnorm(t, mean = 0.5, sd = 0.2)","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/reference/sparsify.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert Regular Functional Data to Irregular by Subsampling — sparsify","text":"","code":"# Create regular functional data t <- seq(0, 1, length.out = 100) fd <- simFunData(n = 20, argvals = t, M = 5, seed = 42)  # Uniform sparsification ifd <- sparsify(fd, minObs = 10, maxObs = 30, seed = 123) print(ifd) #> Irregular Functional Data Object #> ================================= #>   Number of observations: 20  #>   Points per curve: #>     Min: 10  #>     Median: 24  #>     Max: 29  #>     Total: 441  #>   Domain: [ 0 , 1 ] plot(ifd)   # Non-uniform: more observations in the middle prob_middle <- function(t) dnorm(t, mean = 0.5, sd = 0.2) ifd_middle <- sparsify(fd, minObs = 15, maxObs = 25, prob = prob_middle, seed = 123) plot(ifd_middle, main = \"More Observations in Middle\")"},{"path":"https://sipemu.github.io/fdars-r/reference/ssa.fd.html","id":null,"dir":"Reference","previous_headings":"","what":"Singular Spectrum Analysis (SSA) for Time Series Decomposition — ssa.fd","title":"Singular Spectrum Analysis (SSA) for Time Series Decomposition — ssa.fd","text":"Performs Singular Spectrum Analysis functional data decompose curve trend, seasonal (oscillatory), noise components. SSA model-free, non-parametric technique based singular value decomposition trajectory matrix.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/ssa.fd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Singular Spectrum Analysis (SSA) for Time Series Decomposition — ssa.fd","text":"","code":"ssa.fd(fdataobj, window.length = NULL, n.components = 10)"},{"path":"https://sipemu.github.io/fdars-r/reference/ssa.fd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Singular Spectrum Analysis (SSA) for Time Series Decomposition — ssa.fd","text":"fdataobj fdata object. window.length Embedding window length (L). NULL, automatically determined min(n/2, 50). Larger values capture longer-term patterns. n.components Number SVD components extract. Default: 10. components allow finer decomposition increase noise.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/ssa.fd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Singular Spectrum Analysis (SSA) for Time Series Decomposition — ssa.fd","text":"list class \"ssa_result\" components: trend fdata object containing reconstructed trend component seasonal fdata object containing reconstructed seasonal component noise fdata object containing noise/residual component singular.values Singular values SVD (sorted descending) contributions Proportion variance explained component window.length Window length used n.components Number components extracted detected.period Auto-detected period () confidence Confidence score detected period call function call","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/ssa.fd.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Singular Spectrum Analysis (SSA) for Time Series Decomposition — ssa.fd","text":"SSA algorithm consists four stages: 1. Embedding: time series converted trajectory matrix arranging lagged versions series columns. 2. SVD Decomposition: Singular value decomposition trajectory matrix produces orthogonal components. 3. Grouping: Components grouped trend (slowly varying), seasonal (oscillatory), noise. Auto-detection uses sign change analysis autocorrelation. 4. Reconstruction: Diagonal averaging (Hankelization) converts grouped trajectory matrices back time series. SSA particularly suited : Short time series spectral methods fail Noisy data weak periodic signals Non-stationary data changing trend Separating multiple periodicities","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/ssa.fd.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Singular Spectrum Analysis (SSA) for Time Series Decomposition — ssa.fd","text":"Golyandina, N., & Zhigljavsky, . (2013). Singular Spectrum Analysis Time Series. Springer. Elsner, J. B., & Tsonis, . . (1996). Singular Spectrum Analysis: New Tool Time Series Analysis. Plenum Press.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/reference/ssa.fd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Singular Spectrum Analysis (SSA) for Time Series Decomposition — ssa.fd","text":"","code":"# Signal with trend + seasonal + noise t <- seq(0, 10, length.out = 200) X <- matrix(0.05 * t + sin(2 * pi * t / 1.5) + rnorm(length(t), sd = 0.3), nrow = 1) fd <- fdata(X, argvals = t)  # Perform SSA result <- ssa.fd(fd) print(result) #> Singular Spectrum Analysis (SSA) #> -------------------------------- #> Window length:    50 #> N components:     10 #> Detected period:  2.00 #> Confidence:       0.4804 #>  #> Number of curves: 1 #> Series length:    200 #>  #> Top component contributions: #>   Component 1: 40.2% #>   Component 2: 35.7% #>   Component 3: 9.3% #>   Component 4: 0.7% #>   Component 5: 0.7% #>   Cumulative:   86.5% #>  #> Variance decomposition: #>   Trend:    83.6% #>   Seasonal: 6.0% #>   Noise:    10.5%  # Plot components plot(result)   # Examine singular value spectrum (scree plot) plot(result, type = \"spectrum\")"},{"path":"https://sipemu.github.io/fdars-r/reference/standardize.html","id":null,"dir":"Reference","previous_headings":"","what":"Standardize functional data (z-score normalization) — standardize","title":"Standardize functional data (z-score normalization) — standardize","text":"Transforms curve mean 0 standard deviation 1. useful comparing curve shapes regardless level scale.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/standardize.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Standardize functional data (z-score normalization) — standardize","text":"","code":"standardize(fdataobj)  # S3 method for class 'fdata' standardize(fdataobj)  # S3 method for class 'irregFdata' standardize(fdataobj)"},{"path":"https://sipemu.github.io/fdars-r/reference/standardize.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Standardize functional data (z-score normalization) — standardize","text":"fdataobj object class 'fdata'.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/standardize.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Standardize functional data (z-score normalization) — standardize","text":"standardized 'fdata' object curve mean 0 sd 1.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/standardize.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Standardize functional data (z-score normalization) — standardize","text":"","code":"fd <- fdata(matrix(rnorm(100) * 10 + 50, 10, 10), argvals = seq(0, 1, length.out = 10)) fd_std <- standardize(fd) # Check: each curve now has mean ~0 and sd ~1 rowMeans(fd_std$data) #>  [1] -3.996803e-16  4.773959e-16  2.442491e-16  3.441691e-16  2.997602e-16 #>  [6]  7.299716e-16  3.330669e-17  3.941292e-16  1.776357e-16  2.664535e-16 apply(fd_std$data, 1, sd) #>  [1] 1 1 1 1 1 1 1 1 1 1"},{"path":"https://sipemu.github.io/fdars-r/reference/stl.fd.html","id":null,"dir":"Reference","previous_headings":"","what":"STL Decomposition: Seasonal and Trend decomposition using LOESS — stl.fd","title":"STL Decomposition: Seasonal and Trend decomposition using LOESS — stl.fd","text":"Performs STL (Seasonal Trend decomposition using LOESS) functional data following Cleveland et al. (1990). robust iterative procedure separates time series trend, seasonal, remainder components.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/stl.fd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"STL Decomposition: Seasonal and Trend decomposition using LOESS — stl.fd","text":"","code":"stl.fd(fdataobj, period, s.window = NULL, t.window = NULL, robust = TRUE)"},{"path":"https://sipemu.github.io/fdars-r/reference/stl.fd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"STL Decomposition: Seasonal and Trend decomposition using LOESS — stl.fd","text":"fdataobj fdata object. period Integer. seasonal period (number observations per cycle). s.window Seasonal smoothing window. Must odd. NULL, defaults 7. Larger values produce smoother seasonal components. t.window Trend smoothing window. Must odd. NULL, automatically calculated based period s.window. robust Logical. TRUE, performs robustness iterations downweight outliers using bisquare weighting. Default: TRUE.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/stl.fd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"STL Decomposition: Seasonal and Trend decomposition using LOESS — stl.fd","text":"list class \"stl_result\" components: trend fdata object containing trend components seasonal fdata object containing seasonal components remainder fdata object containing remainder (residual) components weights Matrix robustness weights (1 = full weight, 0 = outlier) period period used s.window Seasonal smoothing window used t.window Trend smoothing window used inner.iterations Number inner loop iterations outer.iterations Number outer (robustness) iterations call function call","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/stl.fd.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"STL Decomposition: Seasonal and Trend decomposition using LOESS — stl.fd","text":"STL algorithm proceeds follows: Inner Loop (repeated n.inner times): Detrending: Subtract current trend estimate Cycle-subseries smoothing: Smooth values seasonal position across cycles Low-pass filtering: Remove high-frequency noise Detrending smoothed cycle-subseries Deseasonalizing: Subtract seasonal original data Trend smoothing: Apply LOESS deseasonalized data Outer Loop (robustness): Compute residuals current decomposition Calculate robustness weights using bisquare function Re-run inner loop weighted smoothing STL particularly effective : Long time series many cycles Data outliers (robust=TRUE) Slowly changing seasonal patterns","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/stl.fd.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"STL Decomposition: Seasonal and Trend decomposition using LOESS — stl.fd","text":"Cleveland, R. B., Cleveland, W. S., McRae, J. E., & Terpenning, . (1990). STL: Seasonal-Trend Decomposition Procedure Based Loess. Journal Official Statistics, 6(1), 3-73.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/reference/stl.fd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"STL Decomposition: Seasonal and Trend decomposition using LOESS — stl.fd","text":"","code":"# Create seasonal data with trend t <- seq(0, 20, length.out = 400) period <- 2  # corresponds to 40 observations period_obs <- 40 X <- matrix(0.05 * t + sin(2 * pi * t / period) + rnorm(length(t), sd = 0.2), nrow = 1) fd <- fdata(X, argvals = t)  # Perform STL decomposition result <- stl.fd(fd, period = period_obs) print(result) #> STL Decomposition #> ----------------- #> Period:           40 observations #> Seasonal window:  7 #> Trend window:     77 #> Inner iterations: 2 #> Outer iterations: 15 (robust=TRUE) #>  #> Number of curves: 1 #> Series length:    400 #>  #> Variance decomposition: #>   Trend:     11.9% #>   Seasonal:  82.7% #>   Remainder: 5.3%  # Plot the decomposition plot(result)   # Non-robust version (faster but sensitive to outliers) result_fast <- stl.fd(fd, period = period_obs, robust = FALSE)"},{"path":"https://sipemu.github.io/fdars-r/reference/sub-.fdata.html","id":null,"dir":"Reference","previous_headings":"","what":"Subset method for fdata objects — [.fdata","title":"Subset method for fdata objects — [.fdata","text":"Subset method fdata objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/sub-.fdata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Subset method for fdata objects — [.fdata","text":"","code":"# S3 method for class 'fdata' x[i, j, drop = FALSE]"},{"path":"https://sipemu.github.io/fdars-r/reference/sub-.fdata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Subset method for fdata objects — [.fdata","text":"x object class 'fdata'. Row indices (curves keep). j Column indices (time points keep). drop Logical. TRUE one curve selected, return vector.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/sub-.fdata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Subset method for fdata objects — [.fdata","text":"fdata object containing selected subset.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/sub-.irregFdata.html","id":null,"dir":"Reference","previous_headings":"","what":"Subset method for irregFdata objects — [.irregFdata","title":"Subset method for irregFdata objects — [.irregFdata","text":"Subset method irregFdata objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/sub-.irregFdata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Subset method for irregFdata objects — [.irregFdata","text":"","code":"# S3 method for class 'irregFdata' x[i, ...]"},{"path":"https://sipemu.github.io/fdars-r/reference/sub-.irregFdata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Subset method for irregFdata objects — [.irregFdata","text":"x irregFdata object. Indices observations select. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/sub-.irregFdata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Subset method for irregFdata objects — [.irregFdata","text":"irregFdata object containing selected subset.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/summary.basis.auto.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary method for basis.auto objects — summary.basis.auto","title":"Summary method for basis.auto objects — summary.basis.auto","text":"Summary method basis.auto objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/summary.basis.auto.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary method for basis.auto objects — summary.basis.auto","text":"","code":"# S3 method for class 'basis.auto' summary(object, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/summary.basis.auto.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary method for basis.auto objects — summary.basis.auto","text":"object basis.auto object. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/summary.basis.auto.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary method for basis.auto objects — summary.basis.auto","text":"Invisibly returns data frame per-curve basis selection details.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/summary.fdata.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary method for fdata objects — summary.fdata","title":"Summary method for fdata objects — summary.fdata","text":"Summary method fdata objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/summary.fdata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary method for fdata objects — summary.fdata","text":"","code":"# S3 method for class 'fdata' summary(object, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/summary.fdata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary method for fdata objects — summary.fdata","text":"object object class 'fdata'. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/summary.fdata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary method for fdata objects — summary.fdata","text":"Invisibly returns summary list descriptive statistics.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/summary.irregFdata.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary method for irregFdata objects — summary.irregFdata","title":"Summary method for irregFdata objects — summary.irregFdata","text":"Summary method irregFdata objects","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/summary.irregFdata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary method for irregFdata objects — summary.irregFdata","text":"","code":"# S3 method for class 'irregFdata' summary(object, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/summary.irregFdata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary method for irregFdata objects — summary.irregFdata","text":"object irregFdata object. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/summary.irregFdata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary method for irregFdata objects — summary.irregFdata","text":"Invisibly returns input object.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/trimmed.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Functional Trimmed Mean — trimmed","title":"Compute Functional Trimmed Mean — trimmed","text":"Computes trimmed mean excluding curves lowest depth.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/trimmed.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Functional Trimmed Mean — trimmed","text":"","code":"trimmed(   fdataobj,   trim = 0.1,   method = c(\"FM\", \"mode\", \"RP\", \"RT\", \"BD\", \"MBD\", \"FSD\", \"KFSD\", \"RPD\"),   ... )"},{"path":"https://sipemu.github.io/fdars-r/reference/trimmed.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Functional Trimmed Mean — trimmed","text":"fdataobj object class 'fdata'. trim Proportion curves trim (default 0.1). method Depth method use. One \"FM\", \"mode\", \"RP\", \"RT\", \"BD\", \"MBD\", \"FSD\", \"KFSD\", \"RPD\". Default \"FM\". ... Additional arguments passed depth function.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/trimmed.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Functional Trimmed Mean — trimmed","text":"fdata object containing trimmed mean function.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/trimmed.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Functional Trimmed Mean — trimmed","text":"","code":"fd <- fdata(matrix(rnorm(100), 10, 10)) tm <- trimmed(fd, trim = 0.2) tm_mode <- trimmed(fd, trim = 0.2, method = \"mode\")"},{"path":"https://sipemu.github.io/fdars-r/reference/trimvar.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Functional Trimmed Variance — trimvar","title":"Compute Functional Trimmed Variance — trimvar","text":"Computes trimmed variance excluding curves lowest depth.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/trimvar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Functional Trimmed Variance — trimvar","text":"","code":"trimvar(   fdataobj,   trim = 0.1,   method = c(\"FM\", \"mode\", \"RP\", \"RT\", \"BD\", \"MBD\", \"FSD\", \"KFSD\", \"RPD\"),   ... )"},{"path":"https://sipemu.github.io/fdars-r/reference/trimvar.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Functional Trimmed Variance — trimvar","text":"fdataobj object class 'fdata'. trim Proportion curves trim (default 0.1). method Depth method use. One \"FM\", \"mode\", \"RP\", \"RT\", \"BD\", \"MBD\", \"FSD\", \"KFSD\", \"RPD\". Default \"FM\". ... Additional arguments passed depth function.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/trimvar.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Functional Trimmed Variance — trimvar","text":"fdata object containing trimmed variance function.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/trimvar.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Functional Trimmed Variance — trimvar","text":"","code":"fd <- fdata(matrix(rnorm(100), 10, 10)) tv <- trimvar(fd, trim = 0.2) tv_mode <- trimvar(fd, trim = 0.2, method = \"mode\")"},{"path":"https://sipemu.github.io/fdars-r/reference/var.html","id":null,"dir":"Reference","previous_headings":"","what":"Functional Variance — var","title":"Functional Variance — var","text":"Computes pointwise variance function functional data.","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/var.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functional Variance — var","text":"","code":"var(fdataobj, ...)"},{"path":"https://sipemu.github.io/fdars-r/reference/var.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functional Variance — var","text":"fdataobj object class 'fdata'. ... Additional arguments (currently ignored).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/var.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Functional Variance — var","text":"fdata object containing variance function (1D 2D).","code":""},{"path":"https://sipemu.github.io/fdars-r/reference/var.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Functional Variance — var","text":"","code":"# 1D functional data fd <- fdata(matrix(rnorm(100), 10, 10)) v <- var(fd)  # 2D functional data X <- array(rnorm(500), dim = c(5, 10, 10)) fd2d <- fdata(X, argvals = list(1:10, 1:10), fdata2d = TRUE) v2d <- var(fd2d)"},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/news/index.html","id":"internal-0-3-0","dir":"Changelog","previous_headings":"","what":"Internal","title":"fdars 0.3.0","text":"Upgraded Rust backend (fdars-core) v0.4.0 New FdMatrix type safer matrix handling (internal) New streaming depth module core (internal) Reduced package size removing non-essential vendored files user-facing API changes","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/news/index.html","id":"test-coverage--quality-0-2-0","dir":"Changelog","previous_headings":"","what":"Test Coverage & Quality","title":"fdars 0.2.0","text":"Improved Rust core test coverage 84%+ Improved R package test coverage 80%+ Added pre-commit hooks cargo fmt clippy","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/news/index.html","id":"optimal-cluster-selection-0-2-0","dir":"Changelog","previous_headings":"New Features","what":"Optimal Cluster Selection","title":"fdars 0.2.0","text":"Added optim.kmeans.fd() function automatically determine optimal number clusters functional k-means Silhouette score: Measures cluster cohesion vs separation (-1 1, higher better) Calinski-Harabasz index: Ratio /within cluster variance (higher better) Elbow method: Visual inspection within-cluster sum squares Added print() plot() methods optim.kmeans.fd objects Silhouette Calinski-Harabasz computations implemented Rust performance","code":""},{"path":"https://sipemu.github.io/fdars-r/news/index.html","id":"k-nn-bandwidth-selection-for-nonparametric-regression-0-2-0","dir":"Changelog","previous_headings":"New Features","what":"k-NN Bandwidth Selection for Nonparametric Regression","title":"fdars 0.2.0","text":"\"kNN.gCV\": Global cross-validation (single k observations) \"kNN.lCV\": Local cross-validation (adaptive k per observation) Extended predict.fregre.np() handle k-NN models","code":""},{"path":"https://sipemu.github.io/fdars-r/news/index.html","id":"flexible-metrics-in-clustering-0-2-0","dir":"Changelog","previous_headings":"New Features","what":"Flexible Metrics in Clustering","title":"fdars 0.2.0","text":"kmeans.fd() now accepts string metrics (\"L2\", \"L1\", \"Linf\") metric/semimetric functions String metrics use fast Rust-path; function metrics provide flexibility custom distances","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/news/index.html","id":"ggplot2-visualizations-0-2-0","dir":"Changelog","previous_headings":"Improvements","what":"ggplot2 Visualizations","title":"fdars 0.2.0","text":"plot.fdata(): Functional data curves minimal theme plot.kmeans.fd(): Cluster-colored curves dashed cluster centers plot.optim.kmeans.fd(): Criterion scores optimal k highlighted plot.outliers.fdata(): Outlier/normal curves color legend","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars-r/news/index.html","id":"vignettes-0-2-0","dir":"Changelog","previous_headings":"Documentation","what":"Vignettes","title":"fdars 0.2.0","text":"Added 6 comprehensive vignettes: - Introduction fdars - Functional Depth Functions - Distance Metrics Semimetrics - Functional Regression - Functional Clustering - Outlier Detection","code":""},{"path":"https://sipemu.github.io/fdars-r/news/index.html","id":"api-documentation-0-2-0","dir":"Changelog","previous_headings":"Documentation","what":"API Documentation","title":"fdars 0.2.0","text":"Complete roxygen2 documentation exported functions","code":""},{"path":"https://sipemu.github.io/fdars-r/news/index.html","id":"bug-fixes-0-2-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"fdars 0.2.0","text":"Fixed namespace issues stats utils imports Fixed ggplot2 .data pronoun import R CMD check compliance","code":""},{"path":"https://sipemu.github.io/fdars-r/news/index.html","id":"fdars-010","dir":"Changelog","previous_headings":"","what":"fdars 0.1.0","title":"fdars 0.1.0","text":"Initial release Core functional data class (fdata) 1D 2D support 7 depth functions: FM, mode, RP, RT, FSD, KFSD, RPD Distance metrics: Lp, Hausdorff, DTW, KL Semimetrics: PCA, derivative, basis, Fourier, hshift Functional regression: PC, basis, nonparametric K-means clustering k-means++ initialization Outlier detection: depth-based LRT methods Statistical tests: flm.test, fmean.test Bootstrap inference confidence intervals High-performance Rust backend parallel processing","code":""}]
